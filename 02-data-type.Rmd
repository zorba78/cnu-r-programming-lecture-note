---
output: html_document
editor_options: 
  chunk_output_type: console
---
# 데이터 타입(Data Type) {#data-type}

```{r chunk-setup, echo=FALSE, message=FALSE}
require(knitr)
opts_chunk$set(size="footnotesize",
                      comment = NA,
                      highlight = TRUE)
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
opts_chunk$set(tidy.opts=list(width.cutoff=80))
# options(width = 85)
```

```{block2, type="rmdnote"}
**학습목표(2 주차)**: R의 데이터 차입 중 가장 기본이 되는 스칼라, 백터, 리스트에 대한 이해와 해당 객체를 생성하고, 이와 연관된 함수들을 익힌다.
```



#### 학습 필요성 {#ch2-abstract .unnumbered}

- R언어는 타 프로그래밍 언어와 유사한 자료형(정수형, 실수형, 문자형 등)을 제공
- R 언어가 다른 언어와 차이점 $\rightarrow$ **데이터 분석**에 특화된 벡터(vector), 행렬(matrix), 데이터프레임(data frame), 리스트(list)와 같은 객체^[R에서 사용자가 데이터 입력을 위해 생성 또는 읽어온 객체(object)는 종종 변수(variable)라는 말과 혼용. 본 문서에서는 최상위 데이터 저장장소를 객체라고 명명하며 데이터프레임과 같이 여러 종류의 데이터타입으로 이루어진 객체의 1차원 속성을 변수라고 칭함] 제공
- R 패키지에서 제공되는 함수 사용 방법은 R의 데이터 타입(객체)에 따라 달라질 수 있음  
- R 언어를 원활히 다룰 수 있으려면 R에서 데이터 객체의 형태, 자료 할당 및 그 연산 방법에 대한 이해가 필수적으로 선행되어야 함


#### R 객체의 종류 {#ch2-object-type .unnumbered}

- 스칼라(상수형, scalar 또는 atomic)
- 벡터(vector): **R의 기본연산 단위**
- 리스트(list)
- 행렬(matrix)
- 배열(array)
- 데이터프레임(data frame)
- 함수(function)
- 연산자(operator) ...


R 객체 중 scalar, vector, matrix, data.frame $\rightarrow$ 데이터 객체(object)


#### 객체에 입력 가능한 값 {#object-value .unnumbered}

- **수치형(numeric)**: 숫자(정수, 소수)

- **문자열(string)**: `"충남대학교"`, `"R강의"`

- **논리형(logical)**: `TRUE`/`FALSE`

- **결측값(`NA`)**: 자료에서 발생한 결측 표현

- **공백(`NULL`)**: 지정하지 않은 값

- **요인(factor)**: 범주형 자료 표현(수치 + 문자 결합 형태로 이해하면 편함)

- **기타**: 결측(`NA`), 숫자아님(`NaN`), 무한대(`Inf`) 등


**아래 그림은 2~4 주차에 배울 R의 데이터 타입에 대한 개요도임**

```{r rmarkdown-part, fig.align='center', echo=FALSE, fig.show="hold", out.width='80%', fig.cap="R 데이터 타입 구조 다이어그램: [R, Python 분석과 프로그래밍 (by R Friend)]( http://rfriend.tistory.com/)에서 발췌 후 수정"}
knitr::include_graphics('figures/datatype-diagram.png', dpi = NA)
```



## 스칼라(scalar) {#scalar}

- 단일 차원의 값(하나의 값): $1 \times 1$ 백터로 표현 $\rightarrow$ R 데이터 객체의 기본은 벡터!!
- 데이터 객체의 유형은 크게 숫자형, 문자열, 논리형이 있음

```{block2, type="rmdtip"}
스칼라를 입력시 R의 벡터 지정 함수인 `c()`(벡터 부분에서 상세 내용 학습)를 꼭 사용해서 입력할 필요가 없다. 단, 두 개 이상 스칼라면 벡터이므로 꼭 c()를 써야 한다.
```

### 선언

- 일반적으로 컴파일이 필요한 언어(예: `C` 언어)의 경우 변수 또는 객체를 사용 전에 선언이 필요

```{c, eval=FALSE}
int x; 
x = 1;
```

- 위 코드에서 `int x;` 없이 `x = 1`을 입력 후 컴파일 하면 에러가 나타나지만 `R` 언어에서는 **변수를 선언할 필요가 전혀 없음** 

- `z` 가 어떤 데이터 타입인지 언급할 필요가 전혀 없음 $\rightarrow$ `Python`, `Perl`, `Matlab` 등과 같은 스크립트 언어의 특징. 아래 코드 참조

```{r, comment=NA, prompt=FALSE}
z <- 3
z
```


### 숫자형 {#numeric}

- 정수형(integer)과 실수형(double)로 구분됨
- 정수형 구분시 숫자 뒤 `L`을 표시

```{r, comment=NA}
# 정수형 구분자 사용 예시
# typeof(): R 객체의 데이터 타입 반환하는 함수
typeof(10L)
typeof(10)
```

- 수치연산(`+, -, *, ^, **, /, %%, %/%`) 가능: R은 함수형 언어이기 때문에 앞에 기술한 연산자도 하나의 함수로 인식함. 
- 수치 연산자(operator) 및 기본 수학 함수

```{r operation, echo=FALSE, message=FALSE}
require(tidyverse)
require(rmarkdown)
require(knitr)
require(kableExtra)

`수치형 연산자` <- c("+, -, *, /", 
            "n %% m", 
            "n %/% m", 
            "n ^ m 또는 n ** m")
`설명` <- c("사칙연산", 
          "n을 m 으로 나눈 나머지", 
          "n을 m 으로 나눈 몫", 
          "n 의 m 승")
tab2_01 <- data.frame(`수치형 연산자`, `설명`, check.names = F)
options(kableExtra.html.bsTable = T)
knitr::opts_knit$set(kable.force.latex = FALSE)
kable(tab2_01,
      align = "ll",
      escape = TRUE, 
      booktabs = T, caption = "R언어의 기본 수치 연산자") %>%
  kable_styling(bootstrap_options = c("condensed", "striped"),
                position = "center", 
                font_size = 10, 
                latex_options = c("striped", "HOLD_position")) %>% 
  column_spec(1, width = "4cm") %>% 
  column_spec(2, width = "6cm")

```

**숫자형 스칼라 연산 적용 예시**

```{r ex-operator, comment=NA, prompt=FALSE}
# 숫자형 스칼라
a <- 3
b <- 10
a; b

# 덧셈
c <- a + b
c
# 덧셈을 함수로 입력
# "+"(a, b)로 입력한 결과
c <- "+"(a, b)

# 뺄셈
d <- b - a
d

# 곱셈
m <- a * b
m
# 나누기
dd <- b/a
dd
# 멱승
b^a

# 나누기의 나머지(remainder) 반환
r <- b %% a
r
# 나누기의 몫(quotient) 반환
q <- b %/% a
q
# 연산 우선 순위
nn <- (3 + 5)*3 - 4**2/4
nn

```

### 문자형 {#character}

- 수치형이 아닌 문자 형식의 단일 원소
- C와 같은 언어에서 볼수 있는 한개 문자에 대한 데이터 타입 존재하지 않음
- 수치연산 불가능
- 따옴표(`"` 또는 `'`)로 문자를 묶어서 문자열 표시
- 문자열을 다루는 자세한 설명은 5주차에서 자세히 설명할 예정임

```{r ex-char, comment=NA, prompt=FALSE, error=TRUE}
h1 <- c("Hello CNU!!")
h2 <- c("R is not too difficult.")
typeof(h1); typeof(h2)
h1
h2
# 문자열의 문자 수 반환
nchar(h1); nchar(h2)

# 문자열 연산 error 예시
h1 - h2
  
```

### 논리형 스칼라 {#logical}

- 참(`TRUE`, `T`) 또는 거짓(`FALSE`, `F`)를 나타내는 값
- `TRUE`/`FALSE`: 예약어(reversed word)
- `T`/`F`: `TRUE`와 `FALSE`로 초기화된 전역 변수 
   - `T`에 `FALSE` 또는 어떤 값도 할당 가능 $\rightarrow$ 가급적 `TRUE/FALSE`를 명시하는 것이 편함
- 논리형 연산자(logical operator)

```{r logic-op-tab, echo=FALSE, message=FALSE}
`논리형 연산자` <- c("&", "&&", "|", "||", "!")
`설명` <- c("AND (vectorized)", "AND (atomic)", 
            "OR (vectorized)", "OR (atomic)", "NOT")

tab2_02 <- data.frame(`논리형 연산자`, `설명`, check.names = F)
options(kableExtra.html.bsTable = T)
# knitr::opts_knit$set(kable.force.latex = FALSE)
kable(tab2_02,
      align = "ll",
      escape = TRUE, 
      booktabs = T, caption = "R언어의 논리형 연산자") %>%
  kable_styling(bootstrap_options = c("condensed", "striped"),
                position = "center", 
                font_size = 10, 
                latex_options = c("striped", "HOLD_position")) %>% 
  column_spec(1, width = "3cm") %>% 
  column_spec(2, width = "7cm")
```


- 비교 연산자를 적용할 경우 논리값을 반환

```{r comp-op-tab, echo=FALSE, message=FALSE}
`비교 연산자` <- c(">", "<", "==", ">=", "<=", "!=")
`설명` <- c("크다(greater-than)", "작다(less-than)", "같다(equal)", 
          "크거나 같다(greater than equal)", "작거나 같다(less than equal)", "같지 않다(not equal)")

tab2_03 <- data.frame(`비교 연산자`, `설명`, check.names = F)
options(kableExtra.html.bsTable = T)
# knitr::opts_knit$set(kable.force.latex = FALSE)
kable(tab2_03,
      align = "ll",
      escape = TRUE, 
      booktabs = T, caption = "R언어의 비교 연산자") %>%
  kable_styling(bootstrap_options = c("condensed", "striped"),
                position = "center", 
                font_size = 10, 
                latex_options = c("striped", "HOLD_position")) %>% 
  column_spec(1, width = "3cm") %>% 
  column_spec(2, width = "7cm") %>% 
  kableExtra::footnote(general = "기술한 비교 연산자는 수치형 및 논리형 데이터 타입 모두에 적용 가능 하지만, 문자형은 비교 연산은 ==, != 만 가능함", 
                       threeparttable = TRUE)
```


```{block2, type="rmdnote"}
**참고**

- 논리형 스칼라도 숫자형 연산 가능 $\rightarrow$ 컴퓨터는 `TRUE`/`FALSE`를 1과 0 숫자로 인식
- 수치 연산자는 스칼라 뿐 아니라 아래에서 다룰 벡터, 행렬, 리스트, 데이터프레임 객체의 연산에 사용 가능
- `&`/`|`와 `&&`/`||`는 동일하게 AND/OR를 의미하지만 연산 결과가 다름.
- `&`의 연산 대상이 벡터인 경우 백터 구성 값 각각에 대해 `&` 연산을 실행 하지만 `&&`는 하나의 값(스칼라)에만  논리 연산이 적용(아래 예시 참고)

```


- 논리형 스칼라의 논리 및 비교 연산 예시

```{r logic-op-result, comment=NA, prompt=FALSE, tidy=TRUE, error=TRUE}
typeof(TRUE) # TRUE의 데이터 타입
TRUE & TRUE # TRUE 반환
TRUE & FALSE # FALSE 반환

# 아래 연산은 모두 TRUE 반환
TRUE | TRUE 
TRUE | FALSE

# TRUE와 FALSE의 반대
!TRUE; !FALSE

# 전역변수 T에 FALSE 값 할당
T <- FALSE
T
T <- TRUE # 원상복귀

# TRUE/FALSE에 값을 할당할 수 없음
TRUE <- 1; TRUE <- FALSE

# &(|)와 &&(||)의 차이
l.01 <- c(TRUE, TRUE, FALSE, TRUE) # 논리형 값으로 구성된 벡터
l.02 <- c(FALSE, TRUE, TRUE, TRUE)

l.01 & l.02 # l.01과 l.02 각 원소 별 & 연산
l.01 && l.02 # l.01과 l.02의 첫 번째 원소에 대해 & 연산

# 비교 연산자 
x <- 9; y <- 4

# x > y 의 반환값 데이터 타입
typeof(x > y)
# 논리형 값 반환
x > y 
x < y
x == y
x != y

```

### 결측값(missing value) {#missing-value}

- 결측치 지정 **상수**: `NA` $\rightarrow$ R과 다른 언어의 가장 큰 차이점 중 하나
- 예를 들어 4명의 통계학과 학생 중 3명의 통계학 개론 중간고사 점수가 각각 80, 90, 75점이고 4번 째 학생의 점수가 없는 경우 `NA`로 결측값 표현
- `is.na()` 함수를 이용해 해당 값이 결측을 포함하고 있는지 확인

```{r}
one <- 80; two <- 90; three <- 75; four <- NA
four

# 'is.na()' 결측 NA가 포함되어 있으면 TRUE 
is.na(four)
```

```{block2, type="rmdtip"}
`is.na(object_name)`: 객체를 구성하고 있는 원소 중 `NA`를 포함하고 있는지 확인 $\rightarrow$ `NA`를 포함하면 `TRUE`, 아니면 `FALSE` 반환

**참고**: 자료에 `NA`가 포함된 경우 연산 결과는 모두 `NA`가 반환

```

```{r, comment=NA, prompt=FALSE}
NA + 1
NA & TRUE
NA <= 3
```

### NULL 값 {#null}

- `NULL`: 초기화 되지 않은 변수 또는 **객체**를 지칭함
- `is.null()` 함수를 통해 객체가 `NULL`인지 판단

```{r comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- NULL # NULL 지정
is.null(x) # NULL 객체인지 판단

x <- 1
is.null(x) 

```

```{block2, type="rmdnote"}
**`NA`와 `NULL`의 차이점**: 자료의 공백을 의미한다는 점에서 유사한 측면이 있으나 아래 내용처럼 큰 차이가 있음

- `NULL`: 값을 지정하지 않은 객체를 표현하는데 사용. 즉 아직 변수 또는 객체의 상태가 아직 미정인 상태를 나타냄
- `NA`: 데이터 값이 결측임을 지정해주는 논리형 상수

```


```{r, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# NA와 NULL은 다름
x <- NA
is.null(NA)
is.na(NULL)

# 데이터에서 NA와 NULL의 차이점
x <- c(80, 90, 75, NA)
x

x <- c(80, 90, 75, NULL)
x

```

### 무한대/무한소/숫자아님 {#finite}

- `Inf`: 무한대($+\infty$, $1/0$)
- `-Inf`: 무한소($-\infty$, $-1/0$)
- `NaN`: 숫자아님(Not a Number, $0/0$)
- `is.finite()`, `is.infinite()`, `is.nan()` 함수를 통해 객체가 `Inf` 또는 `NaN`을 포함하는지 확인

```{r, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- Inf
is.finite(x)
is.infinite(x)

x <- 0/0
is.nan(x)
is.infinite(x)
```

```{block2, type="rmdnote"}
지금까지 요인형(factor)을 제외하고 R 언어에서 객체가 가질 수 있는 데이터 유형에 대해 알아봄. 요인형은 4주 차에 예정된 "R 자료형: 팩터, 테이블, 데이터 프레임"에서 상세하게 배울 예정임. 

```


## 벡터(vector) {#vector}

### 벡터의 특징 {#vector-prop}

- 타 프로그래밍 언어의 배열(array)의 개념으로 **동일한 유형**의 데이터 원소가 하나 이상($n \times 1$, $n \geq 1$) 으로 구성된 자료 형태
- R 언어의 가장 기본적인 데이터 형태로 R에서 행해지는 모든 연산의 기본(vectorization) $\rightarrow$ 벡터 연산 시 반복구문(예: `for loop`)이 필요 없음. 
- \@ref(scalar) 절에서 기술한 [스칼라(scalar)]는 사실 $1 \times 1$ 벡터임
- 수학적으로 벡터는 아래와 같이 나타낼 수 있음

$$\mathrm{\mathbf x} = [x_1, x_2, x_3, \ldots, x_n]^T
$$


- 벡터는 앞의 예시에서 본 바와 같이 `c()` 함수를 사용해 생성

```{r vector-ex1, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 숫자형 벡터 
x <- c(2, 0, 2, 0, 0, 3, 2, 4)
x
# 문자형 벡터
y <- c("Boncho Ku", "R programming", "Male", "sophomore", "2020-03-24")
y

```

- 두 개 이상의 벡터는 `c()` 함수를 통해 결합 가능
   - 함수 내 `,` 구분자를 통해 결합

```{r vector-ex2, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 두 벡터의 결합 (1)
x <- 1:5
y <- 10:6
z <- c(x, y)
x
y
z

x <- 5:10
x1 <- x[1:3] # x 벡터에서 1에서 4번째 원소 추출
x2 <- c(x1, 15, x[4])
x2

```


- 서로 다른 자료형으로 벡터를 구성한 경우 표현력이 높은 자료형으로 변환한 값 반환
    - 예: 문자열 + 숫자로 구성된 벡터 $\rightarrow$ 문자형 벡터

```{r vector-ex3, comment=NA, prompt=FALSE, error=TRUE}
# 숫자형 벡터와 문자열 벡터 혼용
k <- c(1, 2, "3", "4")
k
is.numeric(k) # 벡터가 숫자형인지 판단하는 함수
is.character(k) # 벡터가 문자열인지 판단하는 함수

# 숫자형 벡터와 문자열 벡터 결합
x <- 1:3
y <- c("a", "b", "c")
z <- c(x, y)
z
is.numeric(z)
is.character(z)

# 숫자형 벡터와 논리형 벡터 결합
x <- 9:4
y <- c(TRUE, TRUE, FALSE)
z <- c(x, y)

z # TRUE/FALSE 가 1과 0으로 변환

is.numeric(z)
is.logical(z)

```

- 두 벡터는 중첩이 불가능 $\rightarrow$ 동일한 벡터 2개를 결합 시 단일 차원 벡터 생성

```{r vector-ex4, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- y <- 1:3 # x와 y 동시에 [1, 2, 3] 할당
x 
y
z <- c(x, y)
z
```
    

- 벡터 각 원소에 이름 부여 가능
    - `names()` 함수를 이용해 원소 이름 지정
    - 사용 프로토타입: `names(x) <- 문자열 벡터`, 단 `x`와 이름에 입력할 문자열 벡터의 길이는 같아야 함. 

```{r vector-ex5, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- c("Boncho Ku", "R programming", "Male", "sophomore", "2020-03-24")

# 벡터 원소 이름 지정
names(x) <- c("name", "course", "gender", "grade", "date") 
x
```
    
- 벡터의 길이(차원) 확인
   - `length()` 또는 `NROW()` 사용

```{r vector-ex6, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- 1:50
# 객체의 길이 반환
# length(): 벡터, 행렬인 경우 원소의 개수, 데이터프레임인 경우 열의 개수 반환
length(x) 

# NROW(): 벡터인 경우 원소의 개수, 행렬, 데이터 프레임인 경우 행의 개수 반환
NROW(x)
```

### 벡터의 연산

- 원소 단위 사칙연산 및 비교연산 
- 연산 순서는 일반적인 사칙연산의 순서를 준용
   - 단 1단위 수열을 생성하는 `:` 연산자가 사칙연산을 우선함
- `*` 연산 시 행렬 대수학에서 벡터의 곱(내적)과 다름을 주의
- 차원이 서로 맞지 않는 경우 작은 차원(짧은 쪽)의 백터를 재사용함

```{r vector-ex7, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- 1:10; y <- 20:11
length(x); length(y)
x; y

# 사칙연산(+, -, *, /)
# 백터 vs. 백터
x + y
x - y
x * y
x / y

# 그외 연산
# 나머지(remainder)
y %% x

# 몫(quotient)
y %/% x

# 멱승(exponent)
y ^ x

# 연산 우선 순위
1:5 * 3
1:(5 * 3)


# 벡터(n by 1) vs. 스칼라(1 by 1)
x * 3 # 3을 x의 길이 만큼 재사용(반복) 후 곱 연산 수행

x <- c(2, 1, 3, 5, 4); y <- c(2, 3, 4)
x
y
length(x); length(y)

# x의 길이가 5이고 y의 길이가 3이기 때문에 5를 맞추기 위헤
# y의 원소 중 1-2 번째 원소를 재사용
x + y
x / y

# 논리형 벡터
b1 <- c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE)
b2 <- c(FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE)

is.numeric(b1); is.numeric(b2)
is.logical(b1); is.logical(b2)

# 논리형 벡터 연산
b3 <- b1 + b2
is.numeric(b3)
b3
b1 - b2
b1 * b2
b1/b2

# 두 벡터의 비교 연산
x <- c(2, 4, 3, 10, 5, 9)
y <- c(3, 4, 6, 2, 10, 7)

x == y
x != y
x > y
x < y
x >= y
x <= y

# 비교 연산 시 두 벡터의 길이가 다른 경우
x <- 1:5; y <- 2:4

x == y
x != y
x > y
x < y
x >= y
x <= y

# 결측을 포함한 벡터
x <- c(1:10, c(NA, NA))
y <- c(NA, NA, 1:10)
x
y
is.na(x); is.na(y)

# 결측을 포함한 벡터의 연산 
x + y
x / y

# NULL을 포함한 벡터 
x <- c(NULL, 1, NULL, 2, NULL, 3) # 길이가 6?
length(x)
x

# 문자열 벡터 연산 (==, !=)
c1 <- letters[1:5]
# a-z로 구성된 벡터에서 1-2, 6-8 번째 원소 추출
c2 <- letters[c(1:2, 6:8)] 
c1
c2

c1 == c2
c1 != c2

```

### 벡터의 색인(indexing) {#vector-index}

- 벡터의 특정 위치에 있는 원소를 추출   
- 색인(indexing)을 통해 벡터의 원소에 접근 가능
- 타 언어는 대체로 첫 번째 색인이 0에서 시작하지만, R은 1부터 시작
- `x[i]`: 벡터 `x`의 `i`번 째 요소
- `x[start:end]`: `x`의 `start`부터 `end`까지 값 반환 $\rightarrow$ 

```{r vector-ex8, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- c(1.2, 3.1, 4.2, 2.8, 3.3)
x[3] # x 원소 중 3 번째 원소 추출

# x 원소 중 2-3번째 원소 추출
# 아래 예시는 모두 동일한 결과 반환
x[2:3]

```

- `x[-i]`: 벡터 `x`에서 `i`번 째 요소를 제외한 나머지 값 반환


```{r vector-ex9, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# x의 3 번째 원소 제거
x[-3]

# 맨 마지막 원소(5 번째) 제거
# 아래 script는 동일한 결과 출력
x[1:(length(x) - 1)]
x[-length(x)]
```



- `x[idx_vec]`: `idx_vec`가 인덱싱 벡터라고 할 때 `idx_vec`에 지정된 요소를 얻어옴. 일반적으로 `idx_vec`는 백터의 행 순서 번호 또는 각 벡터 원소의 이름에 대응하는 문자열 벡터를 인덱싱 벡터로 사용할 수 있음. 

```{r vector-ex10, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 벡터를 이용한 인덱싱
# x 원소 중 1, 5번째 원소 추출
x[c(1, 5)] # c(1,5)는 벡터

v <- c(1, 4)
x[v]


# 인덱스 번호 중복 가능
x[c(1, 2, 2, 4)]

# 원소 이름으로 인덱싱
# 원소 이름 지정
names(x) <- paste0("x", 1:length(x)) # 문자열 "x"와 숫자 1:5(벡터 길이)를 결합한 문자열 반환
x["x3"]
x[c("x2", "x4")]

```

### 벡터 관련 함수







