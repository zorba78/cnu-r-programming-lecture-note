
# R 객체(R object) {#data-type}

```{r chunk-setup, echo=FALSE, message=FALSE}
require(knitr)
opts_chunk$set(size="footnotesize",
                      comment = NA,
                      highlight = TRUE)
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
opts_chunk$set(tidy.opts=list(blank=FALSE, width.cutoff=80))
options(linewidth = 60)
```

```{block2, type="rmdnote"}
**학습목표(2 주차)**: R에서 사용 가능한 데이터 타입에 대해 알아보고, 고유 데이터 타입으로 구성한 객체(스칼라, 백터, 리스트)와 이와 연관된 함수들을 익힌다.
```



#### 학습 필요성 {#ch2-abstract .unnumbered}

- R언어는 타 프로그래밍 언어와 유사한 데이터 타입(정수형, 실수형, 문자형 등)을 제공
- R 언어가 다른 언어와 차이점 $\rightarrow$ **데이터 분석**에 특화된 벡터(vector), 행렬(matrix), 데이터프레임(data frame), 리스트(list)와 같은 객체^[R에서 사용자가 데이터 입력을 위해 생성 또는 읽어온 객체(object)는 종종 변수(variable)라는 말과 혼용. 본 문서에서는 최상위 데이터 저장장소를 객체라고 명명하며 데이터프레임과 같이 여러 종류의 데이터타입으로 이루어진 객체의 1차원 속성을 변수라고 칭함] 제공
- R 패키지에서 제공되는 함수 사용 방법은 R의 객체에 따라 달라질 수 있음  
- R 언어를 원활히 다룰 수 있으려면 R에서 데이터 객체의 형태, 자료 할당 및 그 연산 방법에 대한 이해가 필수적으로 선행되어야 함


#### R의 데이터 타입 {#object-value .unnumbered}

- **수치형(numeric)**: 숫자(정수, 소수)

- **문자열(string)**: `"충남대학교"`, `"R강의"`

- **논리형(logical)**: `TRUE`/`FALSE`

- **결측값(`NA`)**: 자료에서 발생한 결측 표현

- **공백(`NULL`)**: 지정하지 않은 값

- **요인(factor)**: 범주형 자료 표현(수치 + 문자 결합 형태로 이해하면 편함)

- **기타**: 숫자아님(`NaN`), 무한대(`Inf`) 등


#### R 객체의 종류 {#ch2-object-type .unnumbered}

- 스칼라(상수형, scalar 또는 atomic)
- 벡터(vector): **R의 기본연산 단위**
- 리스트(list)
- 행렬(matrix)
- 배열(array)
- 데이터프레임(data frame)
<!-- - 함수(function) -->
<!-- - 연산자(operator) -->
<!-- - 표현식(expression) -->

<!-- R 객체 중 scalar, vector, matrix, data.frame $\rightarrow$ 데이터 객체(object) -->


**아래 그림은 2~4 주차에 배울 R 주요 객체에 대한 개요도임**

```{r rmarkdown-part, fig.align='center', echo=FALSE, fig.show="hold", out.width='100%', fig.cap="R 데이터 타입 구조 다이어그램: [R, Python 분석과 프로그래밍 (by R Friend)]( http://rfriend.tistory.com/)에서 발췌 후 수정"}
knitr::include_graphics('figures/datatype-diagram.png', dpi = NA)
```



## 스칼라(scalar) {#scalar}

- 단일 차원의 값(하나의 값): $1 \times 1$ 백터로 표현 $\rightarrow$ R 데이터 객체의 기본은 벡터!!
- 데이터 객체의 유형은 크게 숫자형, 문자열, 논리형이 있음

```{block2, type="rmdtip"}
스칼라를 입력시 R의 벡터 지정 함수인 `c()`(벡터 부분에서 상세 내용 학습)를 꼭 사용해서 입력할 필요가 없다. 단, 연속되지 않은 두 개 이상 스칼라면 벡터이므로 꼭 c()를 써야 한다.
```

### 선언 {#definition}

- 일반적으로 컴파일이 필요한 언어(예: `C` 언어)의 경우 변수 또는 객체를 사용 전에 선언이 필요

```{c, eval=FALSE}
int x; 
x = 1;
```

- 위 코드에서 `int x;` 없이 `x = 1`을 입력 후 컴파일 하면 에러가 나타나지만 `R` 언어에서는 **변수를 선언할 필요가 전혀 없음** 

- `z` 가 어떤 데이터 타입인지 언급할 필요가 전혀 없음 $\rightarrow$ `Python`, `Perl`, `Matlab` 등과 같은 스크립트 언어의 특징. 아래 코드 참조

```{r, comment=NA, prompt=FALSE}
z <- 3
z
```


### 숫자형 {#numeric}

- 정수형(integer)과 실수형(double)로 구분됨
- 정수형 구분시 숫자 뒤 `L`을 표시

```{r, comment=NA}
# 정수형 구분자 사용 예시
# typeof(): R 객체의 데이터 타입 반환하는 함수
typeof(10L)
typeof(10)
```

- 수치연산(`+, -, *, ^, **, /, %%, %/%`) 가능: R은 함수형 언어이기 때문에 앞에 기술한 연산자도 하나의 함수로 인식함. 
- 수치 연산자(operator) 및 기본 수학 함수

```{r operation, echo=FALSE, message=FALSE, warning=FALSE}
require(tidyverse)
require(rmarkdown)
require(knitr)
require(kableExtra)

`수치형 연산자` <- c("+, -, *, /", 
            "n %% m", 
            "n %/% m", 
            "n ^ m 또는 n ** m")
`설명` <- c("사칙연산", 
          "n을 m 으로 나눈 나머지", 
          "n을 m 으로 나눈 몫", 
          "n 의 m 승")
tab2_01 <- data.frame(`수치형 연산자`, `설명`, check.names = F)
options(kableExtra.html.bsTable = T)
knitr::opts_knit$set(kable.force.latex = FALSE)
kable(tab2_01,
      align = "ll",
      escape = TRUE, 
      booktabs = T, caption = "R언어의 기본 수치 연산자") %>%
  kable_styling(bootstrap_options = c("condensed", "striped"),
                position = "center", 
                font_size = 10, 
                latex_options = c("striped", "HOLD_position")) %>% 
  column_spec(1, width = "4cm") %>% 
  column_spec(2, width = "6cm") %>% 
  row_spec(1:4, monospace = TRUE)

```

**숫자형 스칼라 연산 적용 예시**

```{r ex-operator, comment=NA, prompt=FALSE}
# 숫자형 스칼라
a <- 3
b <- 10
a; b

# 덧셈
c <- a + b
c
# 덧셈을 함수로 입력
# "+"(a, b)로 입력한 결과
c <- "+"(a, b)

# 뺄셈
d <- b - a
d

# 곱셈
m <- a * b
m
# 나누기
dd <- b/a
dd
# 멱승
b^a

# 나누기의 나머지(remainder) 반환
r <- b %% a
r
# 나누기의 몫(quotient) 반환
q <- b %/% a
q
# 연산 우선 순위
nn <- (3 + 5)*3 - 4**2/4
nn

```

### 문자형 {#character}

- 수치형이 아닌 문자 형식의 단일 원소
- C와 같은 언어에서 볼수 있는 한개 문자에 대한 데이터 타입 존재하지 않음
- 수치연산 불가능
- 따옴표(`"` 또는 `'`)로 문자를 묶어서 문자열 표시
- 문자열을 다루는 자세한 설명은 5주차에서 자세히 설명할 예정임

```{r ex-char, comment=NA, prompt=FALSE, error=TRUE}
h1 <- c("Hello CNU!!")
h2 <- c("R is not too difficult.")
typeof(h1); typeof(h2)
h1
h2
# 문자열의 문자 수 반환
nchar(h1); nchar(h2)

# 문자열 연산 error 예시
h1 - h2
  
```

### 논리형 스칼라 {#logical}

- 참(`TRUE`, `T`) 또는 거짓(`FALSE`, `F`)를 나타내는 값
- `TRUE`/`FALSE`: 예약어(reserved word)
- `T`/`F`: `TRUE`와 `FALSE`로 초기화된 전역 변수 
   - `T`에 `FALSE` 또는 어떤 값도 할당 가능 $\rightarrow$ 가급적 `TRUE/FALSE`를 명시하는 것이 편함
- 논리형 연산자(logical operator)

```{r logic-op-tab, echo=FALSE, message=FALSE}
`논리형 연산자` <- c("&", "&&", "|", "||", "!")
`설명` <- c("AND (vectorized)", "AND (atomic)", 
            "OR (vectorized)", "OR (atomic)", "NOT")

tab2_02 <- data.frame(`논리형 연산자`, `설명`, check.names = F)
options(kableExtra.html.bsTable = T)
# knitr::opts_knit$set(kable.force.latex = FALSE)
kable(tab2_02,
      align = "ll",
      escape = TRUE, 
      booktabs = T, caption = "R언어의 논리형 연산자") %>%
  kable_styling(bootstrap_options = c("condensed", "striped"),
                position = "center", 
                font_size = 10, 
                latex_options = c("striped", "HOLD_position")) %>% 
  column_spec(1, width = "3cm") %>% 
  column_spec(2, width = "7cm") %>% 
  row_spec(1:5, monospace = TRUE)
  
```


- 비교 연산자를 적용할 경우 논리값을 반환

```{r comp-op-tab, echo=FALSE, message=FALSE}
`비교 연산자` <- c(">", "<", "==", ">=", "<=", "!=")
`설명` <- c("크다(greater-than)", "작다(less-than)", "같다(equal)", 
          "크거나 같다(greater than equal)", "작거나 같다(less than equal)", "같지 않다(not equal)")

tab2_03 <- data.frame(`비교 연산자`, `설명`, check.names = F)
options(kableExtra.html.bsTable = T)
# knitr::opts_knit$set(kable.force.latex = FALSE)
kable(tab2_03,
      align = "ll",
      escape = TRUE, 
      booktabs = T, caption = "R언어의 비교 연산자") %>%
  kable_styling(bootstrap_options = c("condensed", "striped"),
                position = "center", 
                font_size = 10, 
                latex_options = c("striped", "HOLD_position")) %>% 
  column_spec(1, width = "3cm") %>% 
  column_spec(2, width = "7cm") %>% 
  kableExtra::footnote(general = "기술한 비교 연산자는 수치형 및 논리형 데이터 타입 모두에 적용 가능 하지만, 문자형은 비교 연산은 ==, != 만 가능함", 
                       threeparttable = TRUE) %>% 
  row_spec(1:6, monospace = TRUE)
```


```{block2, type="rmdnote"}
**참고**

- 논리형 스칼라도 숫자형 연산 가능 $\rightarrow$ 컴퓨터는 `TRUE`/`FALSE`를 1과 0 숫자로 인식
- 수치 연산자는 스칼라 뿐 아니라 아래에서 다룰 벡터, 행렬, 리스트, 데이터프레임 객체의 연산에 사용 가능
- `&`/`|`와 `&&`/`||`는 동일하게 AND/OR를 의미하지만 연산 결과가 다름.
- `&`의 연산 대상이 벡터인 경우 백터 구성 값 각각에 대해 `&` 연산을 실행 하지만 `&&`는 하나의 값(스칼라)에만  논리 연산이 적용(아래 예시 참고)

```


- 논리형 스칼라의 논리 및 비교 연산 예시

```{r logic-op-result, comment=NA, prompt=FALSE, tidy=TRUE, error=TRUE}
typeof(TRUE) # TRUE의 데이터 타입
TRUE & TRUE # TRUE 반환
TRUE & FALSE # FALSE 반환

# 아래 연산은 모두 TRUE 반환
TRUE | TRUE 
TRUE | FALSE

# TRUE와 FALSE의 반대
!TRUE; !FALSE

# 전역변수 T에 FALSE 값 할당
T <- FALSE
T
T <- TRUE # 원상복귀

# TRUE/FALSE에 값을 할당할 수 없음
TRUE <- 1; TRUE <- FALSE

# &(|)와 &&(||)의 차이
l.01 <- c(TRUE, TRUE, FALSE, TRUE) # 논리형 값으로 구성된 벡터
l.02 <- c(FALSE, TRUE, TRUE, TRUE)

l.01 & l.02 # l.01과 l.02 각 원소 별 & 연산
l.01 && l.02 # l.01과 l.02의 첫 번째 원소에 대해 & 연산

# 비교 연산자 
x <- 9; y <- 4

# x > y 의 반환값 데이터 타입
typeof(x > y)
# 논리형 값 반환
x > y 
x < y
x == y
x != y

```

### 결측값(missing value) {#missing-value}

- 결측치 지정 **상수**: `NA` $\rightarrow$ R과 다른 언어의 가장 큰 차이점 중 하나
- 예를 들어 4명의 통계학과 학생 중 3명의 통계학 개론 중간고사 점수가 각각 80, 90, 75점이고 4번 째 학생의 점수가 없는 경우 `NA`로 결측값 표현
- `is.na()` 함수를 이용해 해당 값이 결측을 포함하고 있는지 확인

```{r}
one <- 80; two <- 90; three <- 75; four <- NA
four

# 'is.na()' 결측 NA가 포함되어 있으면 TRUE 
is.na(four)
```

```{block2, type="rmdtip"}
`is.na(object_name)`: 객체를 구성하고 있는 원소 중 `NA`를 포함하고 있는지 확인 $\rightarrow$ `NA`를 포함하면 `TRUE`, 아니면 `FALSE` 반환

**참고**: 자료에 `NA`가 포함된 경우 연산 결과는 모두 `NA`가 반환

```

```{r, comment=NA, prompt=FALSE}
NA + 1
NA & TRUE
NA <= 3
```

### NULL 값 {#null}

- `NULL`: 초기화 되지 않은 변수 또는 **객체**를 지칭함
- `is.null()` 함수를 통해 객체가 `NULL`인지 판단

```{r comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- NULL # NULL 지정
is.null(x) # NULL 객체인지 판단

x <- 1
is.null(x) 

```

```{block2, type="rmdnote"}
**`NA`와 `NULL`의 차이점**: 자료의 공백을 의미한다는 점에서 유사한 측면이 있으나 아래 내용처럼 큰 차이가 있음

- `NULL`: 값을 지정하지 않은 객체를 표현하는데 사용. 즉 아직 변수 또는 객체의 상태가 아직 미정인 상태를 나타냄
- `NA`: 데이터 값이 결측임을 지정해주는 논리형 상수

```


```{r, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# NA와 NULL은 다름
x <- NA
is.null(NA)
is.na(NULL)

```

<!-- # 데이터에서 NA와 NULL의 차이점 -->
<!-- x <- c(80, 90, 75, NA) -->
<!-- x -->

<!-- x <- c(80, 90, 75, NULL) -->
<!-- x -->

### 무한대/무한소/숫자아님 {#finite}

- `Inf`: 무한대($+\infty$, $1/0$)
- `-Inf`: 무한소($-\infty$, $-1/0$)
- `NaN`: 숫자아님(Not a Number, $0/0$)
- `is.finite()`, `is.infinite()`, `is.nan()` 함수를 통해 객체가 `Inf` 또는 `NaN`을 포함하는지 확인

```{r, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- Inf
is.finite(x)
is.infinite(x)

x <- 0/0
is.nan(x)
is.infinite(x)
```

```{block2, type="rmdnote"}
지금까지 요인형(factor)을 제외하고 R 언어에서 객체가 가질 수 있는 데이터 유형에 대해 알아봄. 요인형은 4주 차에 예정된 "R 자료형: 팩터, 테이블, 데이터 프레임"에서 상세하게 배울 예정임. 

```


## 벡터(vector) {#vector}

### 벡터의 특징 {#vector-prop}

- 타 프로그래밍 언어의 배열(array)의 개념으로 **동일한 유형**의 데이터 원소가 하나 이상($n \times 1$, $n \geq 1$) 으로 구성된 자료 형태
- R 언어의 가장 기본적인 데이터 형태로 R에서 행해지는 모든 연산의 기본(vectorization) $\rightarrow$ 벡터 연산 시 반복구문(예: `for loop`)이 필요 없음. 
- \@ref(scalar) 절에서 기술한 [스칼라(scalar)]는 사실 $1 \times 1$ 벡터임
- 수학적으로 벡터는 아래와 같이 나타낼 수 있음

$$\mathrm{\mathbf x} = [x_1, x_2, x_3, \ldots, x_n]^T
$$


- 벡터는 앞의 예시에서 본 바와 같이 `c()` 함수를 사용해 생성

```{r vector-ex1, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 숫자형 벡터 
x <- c(2, 0, 2, 0, 0, 3, 2, 4)
x
# 문자형 벡터
y <- c("Boncho Ku", "R programming", "Male", "sophomore", "2020-03-24")
y

```

- 두 개 이상의 벡터는 `c()` 함수를 통해 결합 가능
   - 함수 내 `,` 구분자를 통해 결합

```{r vector-ex2, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 두 벡터의 결합 (1)
x <- 1:5
y <- 10:6
z <- c(x, y)
x
y
z

x <- 5:10
x1 <- x[1:3] # x 벡터에서 1에서 4번째 원소 추출
x2 <- c(x1, 15, x[4])
x2

```


- 서로 다른 자료형으로 벡터를 구성한 경우 표현력이 높은 자료형으로 변환한 값 반환
    - 예: 문자열 + 숫자로 구성된 벡터 $\rightarrow$ 문자형 벡터
    - 변환규칙: `NULL < raw < logical < integer < double < complex < character < list < expression`


```{r vector-ex3, comment=NA, prompt=FALSE, error=TRUE}
# 숫자형 벡터와 문자열 벡터 혼용
k <- c(1, 2, "3", "4")
k
is.numeric(k) # 벡터가 숫자형인지 판단하는 함수
is.character(k) # 벡터가 문자열인지 판단하는 함수

# 숫자형 벡터와 문자열 벡터 결합
x <- 1:3
y <- c("a", "b", "c")
z <- c(x, y)
z
is.numeric(z)
is.character(z)

# 숫자형 벡터와 논리형 벡터 결합
x <- 9:4
y <- c(TRUE, TRUE, FALSE)
z <- c(x, y)

z # TRUE/FALSE 가 1과 0으로 변환

is.numeric(z)
is.logical(z)

```

- 두 벡터는 중첩이 불가능 $\rightarrow$ 동일한 벡터 2개를 결합 시 단일 차원 벡터 생성

```{r vector-ex4, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- y <- 1:3 # x와 y 동시에 [1, 2, 3] 할당
x 
y
z <- c(x, y)
z
```
    

- 벡터 각 원소에 이름 부여 가능
    - `names()` 함수를 이용해 원소 이름 지정
    - 사용 프로토타입: `names(x) <- 문자열 벡터`, 단 `x`와 이름에 입력할 문자열 벡터의 길이는 같아야 함. 
    - `c()` 함수에서 직접 이름 지정 $\rightarrow$ `c(atom_name1 = value, atom_name2 = value, ...)`

```{r vector-ex5, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- c("Boncho Ku", "R programming", "Male", "sophomore", "2020-03-24")

# 벡터 원소 이름 지정
names(x) <- c("name", "course", "gender", "grade", "date") 
x
y <- c(a = 10, b = 6, c = 9)
names(y)

```
    
- 벡터의 길이(차원) 확인
   - `length()` 또는 `NROW()` 사용

```{r vector-ex6, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- 1:50
# 객체의 길이 반환
# length(): 벡터, 행렬인 경우 원소의 개수, 데이터프레임인 경우 열의 개수 반환
length(x) 

# NROW(): 벡터인 경우 원소의 개수, 행렬, 데이터 프레임인 경우 행의 개수 반환
NROW(x)
```

### 벡터의 연산 {#vector-operation}

- 원소 단위 사칙연산 및 비교연산 수행 $\rightarrow$ 벡터화 연산(vectorized operation)
   - 예를 들어 $\mathrm{\mathbf x} = [1, 2, 3]^T$ 이고, $\mathrm{\mathbf y} = [2, 3, 4]^T$ 라고 할 때 $\mathrm{\mathbf x} + \mathrm{\mathbf y}$의 연산은 아래와 같음

$$\begin{bmatrix}
1 \\ 2\\ 3
\end{bmatrix} + 
\begin{bmatrix}
2 \\ 3\\ 4
\end{bmatrix} = 
\begin{bmatrix}
3 \\ 5 \\ 7
\end{bmatrix}
$$


- `*` 연산 시 행렬 대수학에서 벡터의 곱(product)과 다름을 주의

$$\begin{bmatrix}
1 \\ 2\\ 3
\end{bmatrix} * 
\begin{bmatrix}
2 \\ 3\\ 4
\end{bmatrix} = 
\begin{bmatrix}
2 \\ 6 \\ 12
\end{bmatrix}
$$

```{r vector-ex7, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- 1:3; y <- 2:4
length(x); length(y)
x; y

# 사칙연산(+, -, *, /)
# 백터 vs. 백터
x + y
x - y
x * y
x / y

# 그외 연산
# 나머지(remainder)
y %% x

# 몫(quotient)
y %/% x

# 멱승(exponent)
y ^ x

```


- 차원이 서로 맞지 않는 경우 작은 차원(짧은 쪽)의 백터를 재사용함

$$\begin{bmatrix}
1 \\ 2\\ 3
\end{bmatrix} + [5] = 
\begin{bmatrix}
1 \\ 2\\ 3
\end{bmatrix} + 
\begin{bmatrix}
5 \\ 5\\ 5
\end{bmatrix} = 
\begin{bmatrix}
6 \\ 7 \\ 8
\end{bmatrix}
$$


```{r vector-ex8, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 벡터(n by 1) vs. 스칼라(1 by 1)
x * 5 # 5을 x의 길이 만큼 재사용(반복) 후 곱 연산 수행

x <- c(2, 1, 3, 5, 4); y <- c(2, 3, 4)
x
y
length(x); length(y)


# x의 길이가 5이고 y의 길이가 3이기 때문에 5를 맞추기 위헤
# y의 원소 중 1-2 번째 원소를 재사용
x + y
x / y

```


- 연산 순서는 일반적인 사칙연산의 순서를 준용
   - 단 1단위 수열을 생성하는 `:` 연산자가 사칙연산을 우선함

```{r vector-ex9, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 연산 우선 순위
1:5 * 3
1:(5 * 3)

```


- 논리형 값으로 구성된 벡터의 기본 연산 시 수치형으로 변환된 연산 결과를 반환


```{r vector-ex10, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 논리형 벡터
b1 <- c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE)
b2 <- c(FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE)

is.numeric(b1); is.numeric(b2)
is.logical(b1); is.logical(b2)

# 논리형 벡터 연산
b3 <- b1 + b2
is.numeric(b3)
b3
b1 - b2
b1 * b2
b1/b2


```


- 두 벡터 간 비교 연산은 사칙연산과 마찬가지로 각 원소단위 연산을 수행하고 논리형 벡터 반환
  - 재사용 규칙은 그대로 적용됨


```{r vector-ex11, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 두 벡터의 비교 연산
x <- c(2, 4, 3, 10, 5, 9)
y <- c(3, 4, 6, 2, 10, 7)

x == y
x != y
x > y
x < y
x >= y
x <= y

# 비교 연산 시 두 벡터의 길이가 다른 경우
x <- 1:5; y <- 2:4

x == y
x != y
x > y
x < y
x >= y
x <= y

```


- 문자열 벡터의 연산은 `==` 또는 `!=` 만 가능(사칙연산 불가능)


```{r vector-ex12, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 문자열 벡터 연산 (==, !=)
c1 <- letters[1:5]
# a-z로 구성된 벡터에서 1-2, 6-8 번째 원소 추출
c2 <- letters[c(1:2, 6:8)] 
c1
c2

c1 == c2
c1 != c2

```


- `NA`를 포함한 두 벡터 연산 시 동일 위치에 `NA`가 존재하면 어떤 연산이든 `NA` 값을 반환


```{r vector-ex13, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 결측을 포함한 벡터
x <- c(1:10, c(NA, NA))
y <- c(NA, NA, 1:10)
x
y
is.na(x); is.na(y)

# 결측을 포함한 벡터의 연산 
x + y
x / y
x < y
x > y

```

- `NULL`이 벡터에 포함되더라도 벡터의 길이에는 변동이 없음


```{r vector-ex14, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# NULL을 포함한 벡터 
x <- c(1, 2, 3, NULL, NULL, NULL) # 길이가 6?
length(x)
x

```


### 벡터의 색인(indexing) {#vector-index}

- 벡터의 특정 위치에 있는 원소를 추출   
- 색인(indexing)을 통해 벡터의 원소에 접근 가능
- 타 언어는 대체로 첫 번째 색인이 0에서 시작하지만, R은 1부터 시작
- `x[i]`: 벡터 `x`의 `i`번 째 요소
- `x[start:end]`: `x`의 `start`부터 `end`까지 값 반환


```{r vector-ex15, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- c(1.2, 3.1, 4.2, 2.8, 3.3)
x[3] # x 원소 중 3 번째 원소 추출

# x 원소 중 2-3번째 원소 추출
x[2:3]

```

- `x[-i]`: 벡터 `x`에서 `i`번 째 요소를 제외한 나머지 값 반환


```{r vector-ex16, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# x의 3 번째 원소 제거
x[-3]

# 맨 마지막 원소(5 번째) 제거
# 아래 script는 동일한 결과 출력
x[1:(length(x) - 1)]
x[-length(x)]
```

- `x[idx_vec]`: `idx_vec`가 인덱싱 벡터라고 할 때 `idx_vec`에 지정된 요소를 얻어옴. 일반적으로 `idx_vec`는 백터의 행 순서 번호 또는 각 벡터 원소의 이름에 대응하는 문자열 벡터를 인덱싱 벡터로 사용할 수 있음. 

```{r vector-ex17, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 벡터를 이용한 인덱싱
# x 원소 중 1, 5번째 원소 추출
x[c(1, 5)] # c(1,5)는 벡터

v <- c(1, 4)
x[v]


# 인덱스 번호 중복 가능
x[c(1, 2, 2, 4)]

# 원소 이름으로 인덱싱
# 원소 이름 지정
names(x) <- paste0("x", 1:length(x)) # 문자열 "x"와 숫자 1:5(벡터 길이)를 결합한 문자열 반환
x["x3"]
x[c("x2", "x4")]

```

- 필터링(filtering): 특정한 조건을 만족하는 원소 추출
   - 비교 연산자를 이용한 조건 생성 $\rightarrow$ 논리값을 이용한 원소 추출

```{r vector-ex18-1, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
z <- c(5, 2, -3, 8)
# z의 원소 중 z의 제곱이 8보다 큰 원소 추출
w <- z[z^2 > 8]
w
```

- 작동 원리 
   - `z^2 > 8`은 벡터 `z`의 모든 원소 제곱값이 8 보다 큰 케이스를 논리형 값으로 반환
   
```{r vector-ex18-2, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
z^2
idx <- z^2 > 8
idx
z[idx]
```

- 특정 조건을 만족하는 벡터의 위치에 임의의 값을 치환할 수 있음

```{r}
# 위 벡터 z 의 원소 중 z^2 > 8 인 원소의 값을 0으로 치환
z[idx] <- 0
```


### 벡터 관련 함수 {#vector-function}

- `c()` 함수 외에 R은 벡터 생성을 위해 몇 가지 유용한 함수를 제공함


#### **`seq`** 계열 함수 {#fun-seq .unnumbered}

> 보다 자세한 사용 설명은 `help(seq)` 참고

**`seq()`**: 등차 수열 생성하는 함수로 `from`에서 `end` 까지 숫자 내에서 공차(간격)가 `by` 인 수열 생성 

```{r, eval=FALSE}
# seq(): 수열 생성 함수
seq(
  from, # 시작값
  to,   # 끝값
  by    # 공차(증가치)
)

# 기타 인수
# length.out = n
#   - 생성하고자 하는 벡터의 길이가 n인 수열 생성
# along.with = 1:n 
#   - index가 1에서 n 까지 길이를 갖는 수열 생성

```

- **사용 예시**


```{r seq-example, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- seq(from = 2, to = 30, by = 2)
x 

# 간격이 꼭 정수가 아니어도 사용 가능
x <- seq(from = 0, to = 3, by = 0.2)

# by 대신 length.out 으로 생성된 수열의 길이 조정
x <- seq(from = -3, to = 3, length.out = 10)
x

# from, to 인수 없이 length.out=10 인 경우
seq(length.out = 10)

# by 대신 along.width 
seq(along.with=1:10)

seq(1, 5, along.with=1:10)

# 벡터 x에 seq() 함수 적용 시 1:length(x) 값 반환
seq(x)

```


**`seq_along()`**: 주어진 객체의 길이 만큼 1부터 1 간격의 수열 생성

- `seq()` 함수와 매우 유사하나, 무조건 1부터 시작해서 인수로 `seq()`의 `along.with` 값을 이용한 함수
- `seq()` 함수보다 조금 빠름
- **사용 예시**

```{r seq_along_ex, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 1부터 x 벡터의 길이 까지 1 단위 수열 값 반환
seq_along(x)
```

**`seq_len()`**: 인수로 받은 값 만큼 1부터 해당 값 까지 1 간격의 수열 생성

- `seq()` 함수의 인수 중 `length.out` 값을 이용한 함수
- **사용 예시**

```{r seq_len_ex, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 1부터 n 까지 1 단위 수열 값 반환
seq_len(10)
```


#### **`rep`** 계열 함수 {#fun-rep .unnumbered}

> `help(rep)`을 통해 상세 내용 참고

**`rep()`**: 주어진 벡터의 원소를 반복


```{r, eval=FALSE}
# rep(): 벡터 또는 벡터의 개별 원소를 반복한 값 반환
rep(
  x, # 반복할 값이 저장된 벡터
  times, # 전체 벡터의 반복 횟수
  each # 개별 원소의 반복 횟수
)

```


- **사용 예시**

```{r rep-ex1, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- rep(4, 5) # 4를 5번 반복
x

# x <- c(1:3) 전체를 3번 반복한 벡터 반환
x <- c(1:3)
xr1 <- rep(x, times = 3)
xr1

# 벡터 x 의 각 원소를 4번씩 반복한 벡터 반환
xr2 <- rep(x, each = 4)
xr2

# 벡터 x 의 각 원소를 3번 반복하고 해당 벡터를 2회 반복
xr3 <- rep(x, each = 3, times = 2)
xr3

# 문자형 벡터의 반복
# 아래 sex 벡터의 각 원소를 2 번 반복하고 해당 벡터를 4회 반복
sex <- c("Male", "Female")
sexr <- rep(sex, each = 2, times = 4)
sexr
```


**`rep.int()` & `rep_len()`**: `rep()` 함수의 simple 버전으로 속도(performance)가 요구되는 프로그래밍 시 사용

- **사용 예시**

```{r rep-ex2, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 1:5 벡터를 3 번 반복
rep.int(1:5, 3)

# 불완전한 사이클로 벡터 반복
rep_len(1:5, length.out = 7)
```


#### **Filtering 관련 함수** {#fun-filtering .unnumbered}

> `help(subset)` 참고

**`subset()`**: 기존 필터링 방식과 비교할 때 `NA`를 처리하는 방식에서 차이를 보임

- 벡터 뿐 아니라 앞으로 배울 행렬 및 데이터프레임 객체에도 적용 가능


```{r subset-ex, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- c(6, 1:3, NA, NA, 12)
x

# 일반적 필터링 적용 
x[x > 5]

# subset() 함수 적용
subset(x, x > 5)

```

**`which()`**: 한 벡터에서 특정 조건에 맞는 위치(인덱스)를 반환

```{r, eval=FALSE}
# which(): 논리형 벡터를 인수로 받고 해당 논리형 벡터가 참인 index 반환
which(
  logical_vec # 논리형 벡터
)
```


- **사용 예시**

```{r which-ex, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- c(3, 8, 3, 1, 7)

# x의 원소값이 3인 index 반환
which(x == 3)

# x의 원소가 4보다 큰 원소의 index 반환
which(x > 4)

# 9월(Sep)과 12월(Dec)와 같은 원소 index
# month.abb: R 내장 벡터로 월 약어(Jan ~ Dec)를 저장한 문자열 벡터
which(month.abb == c("Sep", "Dec"))

# 조건을 만족하는 원소가 존재하지 않는다면?
x <- which(x > 9)
x
length(x) # 길이가 0인 벡터 반환 is.null(x) == TRUE ??
is.null(x)

# 특정 조건 만족 여부를 확인 
# any(condition) -> 하나라도 condition을 만족하는 원소가 존재하는지 판단
# TRUE 또는 FALSE 값 반환
any(x > 9)

```

#### **집합 관련 함수** {#set-function .unnumbered}

- 벡터는 숫자, 문자열의 묶음, 즉 원소들의 집합(set)으로 볼 수 있기 때문에 집합 연산이 가능
- 두 집합을 $X$와 $Y$로 정의 했을 때 아래와 같은 집합 연산 가능
- **`setequal(X, Y)`**: `X`와 `Y`가 동일한지 판단 ($X = Y$) $\rightarrow$ 논리값 `TRUE` 또는 `FALSE` 반환
 
```{r set-equal-ex, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- y <- c(1, 9, 7, 3, 6)
setequal(x, y)

```

- **`union(X, Y)`**: `X`와 `Y`의 합집합 ($X \cup Y$)

```{r set-union-ex, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
y <- c(1, 9, 8, 2, 0, 3)
union(x, y)

```


- **`intersect(X, Y)`**: `X`와 `Y`의 교집합 ($X \cap Y$)

```{r set-intersect-ex, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
intersect(x, y)
```

- **`setdiff(X, Y)`**: `X`와 `Y`의 차집합 ($X - Y$)

```{r set-diff-ex, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
setdiff(x, y)
setdiff(y, x)
```

- **`X %in% Y`**: `X`(기준)가 집합 `Y`의 원소인지 논리값 반환

```{r in-op-ex, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- c("apple", "banana", "strawberry", "mango", "peach", "orange")
y <- c("strawberry", "orange", "mango")

x %in% y
y %in% x

```

#### **두 벡터의 동일성 테스트** {#vec-identical .unnumbered}

- 두 벡터가 동일한지 테스트 하기 위해 `x == y` 연산의 반환 값은 위의 예제에서 확인한 것 처럼 각 원소에 대한 논리값을 반환(아래 예제 확인)

```{r identical-ex, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- 1:3
y <- c(1, 3, 4)
x == y
```

- 단지 두 벡터가 동일한지 아닌지를 확인하기 위해서는 하나의 논리값만 필요한 경우 `all()` 사용

```{r all-ex, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
all(x == y)
```

- 보다 나은 방법으로 `identical()` 함수 적용

```{r identical-ex1, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 두 객체의 동일성 여부 테스트
identical(x, y)
```

- `identical()` 함수는 벡터가 갖는 데이터 타입의 동일성 까지 체크함

```{r identical-ex2, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- 1:5; y <- c(1, 2, 3, 4, 5)
x
y

# all() 함수로 동일성 확인
all(x == y)

# identical 함수로 동일성 확인
identical(x, y)

# x, y 데이터 타입 확인
typeof(x)
typeof(y)

```

## 리스트(list) {#list}

- **리스트(list)**: `(key, value)` 형태로 데이터를 저장한 배열(벡터)
- 서로 다른 데이터 타입을 가진 객체를 원소로 가질 수 있는 벡터
   - 예: 한 리스트 안에는 상이한 데이터 타입(숫자형, 문자형, 논리형 등)을 갖는 원소(객체)들을 포함할 수 있음

```{block2, type="rmdnote"}
**리스트 예시**: 통계프로그래밍언어 중간고사 성적 테이블

- 중간고사 성적 테이블은 이름, 학번, 출석률, 점수, 등급으로 이루어졌다고 가정하면 "김상자"의 성적 리스트는 다음과 같이 나타낼 수 있음
- `LIST(이름 = "김상자", 학번 = "202015115", 점수 = 95, 등급 = "A-")`
- 위 record에서 보듯이 문자형과 숫자형이 LIST 안에 같이 표현되고 있음

```

- 위 record를 벡터 생성함수 `c()`로 생성한 경우

```{r, comment=NA, prompt=FALSE}
# 벡터로 위 record를 입력한 경우
vec <- c(`이름` = "김상자", `학번` = "202015115", 
         `점수` = 95, `등급` = "A-")
vec
typeof(vec)

```

```{block2, type="rmdtip"}
객체 명칭 규칙을 벗어나는 이름을 객제명으로 사용하고 싶다면 다음과 같이 홀따옴표 \``object_name`\` 표시를 통해 사용 가능함

```

```{r, comment=NA, prompt=TRUE}
#공백이 있는 이름을 객체 명칭으로 사용
`golf score` <- c(75, 82, 92)
`golf score`

`3x` <- c(3, 6, 9, 12)
`3x`

```




### 리스트 생성 {#make-list}

- **`list()`** 함수를 사용해 list 객체 생성

```{r, eval=FALSE}
# list 함수 사용 prototype
list(name_1 = object_1, ..., name_m = object_m)

# name_1, ..., name_m: 리스트 원소 이름
# object_1, ..., object_m: 리스트 원소에 대응한 객체

```


- 중간고사 성적 테이블 예시


```{r list-ex1, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# lst 객체 생성
lst <- list(`이름` = "김상자", 
            `학번` = "202015115", 
            `점수` = 95, 
            `등급` = "A-")
lst

# lst 내 객체의 데이터 타입 확인
# lapply(): lst 객체에 동일한 함수 적용 (추후 학습)
lapply(lst, typeof)

```

- 리스트 원소에 이름이 부여된 경우 `names()`를 통해 확인 가능

```{r, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
names(lst)
```


- 이름(`name_1, .., name_n`) 없이도 리스트 생성 가능하나, 가급적 이름을 부여 하는 것이 더 명확


```{r list-ex2, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
list("김상자", "202015115", 95, "A-")
```


- 리스트는 벡터이므로 `vector()` 함수를 통해 생성 가능


```{r list-ex3, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
# 길이가 1이고 객체가 NULL인 리스트 생성
z <- vector(mode = "list", length=1)
z

```

- 리스트의 값이 어떤 객체든 관계 없음

```{r list-ex4, comment=NA, prompt=FALSE, error=TRUE, warning=TRUE}
x <- list(name = c("A", "B", "C"), 
          salary = c(500, 450, 600), union = T)
x
```

### 리스트 색인 {#list-index}


- 리스트에 포함된 객체에 접근는 기본적으로 벡터의 색인 방법과 동일하게 색인 번호 또는 키(이름)을 통해 접근 가능
- 리스트에 포함된 모든 객체의 원소값을 쉽게 확인하는 함수는 `unlist()`임 

```{r}
lval <- unlist(x)
typeof(lval)
```


```{r list-tab, echo=FALSE}
`색인방법` <- c("x$name", "x[[i]] 또는 x[[name]]", "x[i] 또는 x[name]")
`동작` <- c("리스트 x 에서 객체명(name)에 해당하는 객체에 접근", 
            "리스트 x 에서 i 번째 또는 name에 해당하는 객체 반환", 
            "리스트 x 에서 i 번째 또는 name에 해당하는 부분 리스트 반환")
tab2_04 <- data.frame(`색인방법`, `동작`, check.names = F)
options(kableExtra.html.bsTable = T)
# knitr::opts_knit$set(kable.force.latex = FALSE)
kable(tab2_04,
      align = "ll",
      escape = TRUE, 
      booktabs = T, caption = "리스트 데이터 접근 방법") %>%
  kable_styling(bootstrap_options = c("condensed", "striped"),
                position = "center", 
                font_size = 10, 
                latex_options = c("striped", "HOLD_position")) %>% 
  column_spec(1, width = "3cm") %>% 
  column_spec(2, width = "7cm") %>% 
  row_spec(1:3, monospace = TRUE)

```


- `x$name`을 통해 리스트 내 객체 접근

```{r list-ex5, comment=NA, prompt=FALSE, error=TRUE}
lst$`학번`
```

- `x[[i]]` 또는 `x[[name]]` 을 통해 리스트 내 객체 접근


```{r list-ex6, comment=NA, prompt=FALSE, error=TRUE}
lst[[2]]
z <- lst[["학번"]]
z
typeof(z)

```

- `x[i]` 또는 `x[name]` 을 통해 리스트 내 부분 리스트 추출

```{r list-ex7, comment=NA, prompt=FALSE, error=TRUE}
lst[2]
j <- lst["학번"]
j
typeof(j)

```


- 리스트 또한 벡터로 볼 수 있기 때문에 여러 개의 부분 리스트 추출 가능

```{r lst-ex8, comment=NA, prompt=FALSE, error=TRUE}
# 리스트 lst 에서 1 ~ 3 번째 까지 부분 리스트 추출
lst[1:3]

```

- 리스트를 구성하는 객체 내 색인 

```{r lst-ex9, comment=NA, prompt=FALSE, error=TRUE}
x
# salary에서 2-3번째 원소 추출
x$salary[2:3]
x[[2]][2:3]
x[["salary"]][2:3]

# 부분 리스트도 길이가 1인 리스트이므로, 
# 부분 리스트 내 객제 접근 시 리스트 접근이 선행
# x의 2번째 부분 리스트에서 첫 번째 객체의 2-3번째 원소 추출
x[2][[1]][2:3]


```

- 리스트의 길이 반환: 벡터와 마찬가지로 `length()` 함수 적용 가능

```{r lst-ex10, comment=NA, prompt=FALSE, error=TRUE}
length(lst); length(x)
```


### 리스트에 원소 추가/제거 {#list-add-delete}

- 주어진 리스트 `x`에 새로운 원소를 `x$new_obj <- value` 명령어 형태로 추가
- 이미 존재하고 있는 리스트 원소 제거는 `x$exist_obj <- NULL` 형태로 제거

```{r lst-ex11, comment=NA, prompt=FALSE, error=TRUE}
# 리스트 lst 에 5회 차 퀴즈 점수 추가
lst$quiz <- c(10, 8, 9, 9, 8)

# 리스트 lst이 원소 quiz 제거
lst$quiz <- NULL
lst

# 벡터 색인을 이용해 원소 추가 가능
lst[[5]] <- c(10, 8, 9, 9, 8)
lst

# 부분 리스트 괄호에서도 색인 통해 추가/삭제 가능
lst[5] <- NULL
lst

# 여러 개의 리스트 동시 추가/삭제 가능
lst[5:9] <-  c(10, 8, 9, 9, 8)
lst
lst[5:9] <-  NULL
lst

```


### 리스트의 결합 {#list-combine}

- 두 개 이상의 리스트를 결합 시 `c()` 사용 

```{r lst-ex12, comment=NA, prompt=FALSE, error=TRUE}
# 리스트 lst와 x 결합
c(lst, x)

```


```{block2, type="rmdnote"}
리스트 내에 리스트를 가질 수 있다. 이를 재귀 리스트(recursive list)라고 한다. 예를 들어 위 예제에서 각 학생의 성적 데이터가 리스트로 구성되어 있다면, 전체 성적 데이터베이스는 리스트로 구성된 리스트임. 아래 예제 처럼 간단한 재귀 리스트 구현이 가능
```

```{r recursive-list, comment=NA, prompt=FALSE, error=TRUE}
kim <- list(id = "20153345", sex = "Male", score = 85, grade = "B+")
lee <- list(id = "20153348", sex = "Female", score = 75, grade = "B0")

gr <- list(kim=kim, lee=lee)
gr
```


## 행렬(matrix) {#matrix}

```{block2, type="rmdnote"}
**학습목표(3 주차)**: 행렬, 배열, 요인형과 테이블에 대해 살펴보고, 이들 객체에 대한 연산과 연관된 함수에 대해 익힌다.
```

#### **행렬의 정의** {#def-matrix .unnumbered}

- 동일한 데이터 타입의 원소로 구성된 2차원 데이터 구조
-  $n \times 1$ 차원 벡터 $p$개로 묶여진 데이터 덩어리 $\rightarrow$ $n \times p$ 행렬로 명칭함
- 행렬의 형태

$$\begin{bmatrix}
x_{11} & x_{12} & \cdots & x_{1p} \\
x_{21} & x_{22} & \cdots & x_{2p} \\
\vdots & \vdots & \cdots & \vdots \\
x_{n1} & x_{n2} & \cdots & x_{np}
\end{bmatrix}
$$

- R에서 행렬은 동일한 유형의 데이터 타입으로 구성 가능 $\rightarrow$ 첫 번째 행은 숫자형, 두 번째 행은 문자열로 입력해도 행렬을 만들 수 있지만, 표현력이 더 높은 문자형 행렬 반환
- 행렬의 내부 저장공간은 "열 우선 배열"
- 행렬 생성을 위한 R 함수는 `matrix()` 함수이고 사용 형태는 아래와 같음

```{r, eval=FALSE}
# matrix(): 행렬 생성 함수
# 상세 내용은 help(matrix)를 통해 확인

matrix(data, # 행렬을 생성할 데이터 벡터 
       nrow, # 행의 개수 (정수)
       ncol, # 열의 개수 (정수)
       byrow, # TRUE: 행 우선, FALSE: 열 우선
              # default = FALSE
       dimnames # 행렬읠 각 차원에 부여할 이름 (리스트)
       )
```

- 행렬 생성 예시 

```{r make-matrix-ex1, comment=NA}
# byrow = FALSE
x <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3)
x

# byrow = TRUE
x <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3, byrow = T)
x

```

- 행의 개수(`nrow`)나 열의 개수(`ncol`)로 나머지를 추정 가능하다면 둘 중 어떤 인수도 생략 가능

```{r make-matrix-ex2, comment=NA}
x <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol = 3)
x
x <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3)
x
```

- `nrow` $\times$ `ncol` 이 입력한 데이터(벡터)의 길이보다 작거나 큰 경우

```{r make-matrix-ex3, comment=NA}
# length(x) < nrow * ncol 인 경우 
# nrow * ncol에 해당하는 길이 만큼
# x의 원소를 사용해 행렬 생성
x <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
y <- matrix(x, nrow = 3, ncol = 4)
y

# length(x) > nrow * ncol 인 경우 
# x의 첫 번쨰 원소부터 초과하는 만큼 
# x 원소의 값을 재사용
z <- matrix(x, nrow = 2, ncol = 3)
z

```

- 행렬 구성 시 길이에 대한 약수가 아닌 값을  `nrow` 또는 `ncol`의 인수로 받은 경우

```{r make-matrix-ex4, comment=NA}
# x (length=9)로 행렬 생성 시 nrow=4 를
# 인수로 입력한 경우
h <- matrix(x, nrow = 4)
h

# x (length=9)로 행렬 생성 시 ncol=2 만 
# 인수로 입력한 경우
h <- matrix(x, nrow = 2)
h

```

### 행렬의 연산 {#matrix-operation}

- 선형대수(linear algebra)에서 배우는 행렬-스칼라, 행렬-행렬 간 연산 가능

#### **행렬-스칼라 연산** {#mat-op-s .unnumbered}

**합 연산**: 스칼라가 자동적으로 행렬의 차원에 맞춰서 재사용

$$\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\ 
7 & 8 & 9
\end{bmatrix} + 4 = 
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\ 
7 & 8 & 9
\end{bmatrix} + 
\begin{bmatrix}
4 & 4 & 4 \\
4 & 4 & 4 \\ 
4 & 4 & 4
\end{bmatrix} = 
\begin{bmatrix}
5 &  6  & 7 \\
8 &  9  & 10 \\ 
11 & 12 & 13
\end{bmatrix}
$$

```{r mat-op-ex1, comment=NA}
x <-matrix(1:9, 3, 3, byrow = T)
x + 4
```


**곱 연산**

$$\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\ 
7 & 8 & 9
\end{bmatrix} \times 4 = 
\begin{bmatrix}
4  &  8 & 12 \\
16 & 20 & 24 \\ 
28 & 32 & 36
\end{bmatrix} 
$$

```{r mat-op-ex2, comment=NA}
x*4
```

#### **행렬-행렬 연산** {#mat-op-m .unnumbered}

- 행렬 간 연산에서 스칼라 연산(일반 연산)과 다른 점은 차원이 개입

**행렬 간 합(차)**

- 두 행렬의 동일 차원 간 합 연산 수행(`+` 또는 `-` 연산자 사용)

$$\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\ 
7 & 8 & 9
\end{bmatrix} +  
\begin{bmatrix}
1 & -1 & ~~~2 \\
3 & ~~~2 & ~~~4 \\ 
-6 & ~~~3 & -7
\end{bmatrix} 
 = 
\begin{bmatrix}
2  & 1  & 5 \\
7  & 7  & 10 \\ 
1  & 11 & 2
\end{bmatrix}
$$

```{r mat-op-sum, comment=NA}
x <- matrix(1:9, 3, 3, byrow = T)
y <- matrix(c(1, 3, -6, -1, 2, 3, 2, 4, -7), ncol = 3)
x + y
```

**행렬 곱/나누기(elementwise product/division)** 

- 연산자 `*` 또는 `/`  사용

$$\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\ 
7 & 8 & 9
\end{bmatrix} *  
\begin{bmatrix}
~~~1 & -1 &  ~~~2 \\
~~~3 & ~~~2 & ~~~4 \\ 
-6 & ~~~3 & -7
\end{bmatrix} 
 = 
\begin{bmatrix}
~~~~~ 1  & -2  &  ~~~~6 \\
~~~  12  & ~10 &  ~~~24 \\ 
    -42  & ~24 & -63
\end{bmatrix}
$$

```{r mat-op-eprod-1, comment=NA}
x * y
```

- 행렬-행렬 합(차) 또는 곱(나누기) 연산 시 행렬의 열단위 원소가 재사용되지 않음

> **동일 차원 간 연산만 가능!!**

```{r mat-op-eprod-2, comment=NA, error=TRUE}
z <- y[, 1:2] # y 행렬에서 1-2 번째 열 추출
z # 3 by 2 행렬
x + z
x * z
x / z

```

**행렬 간 곱(matrix product)** 

- 두 행렬 $\mathrm{\mathbf X}_{n\times m}$, $\mathrm{\mathbf Y}_{m\times k}$ 이 주어졌을 때 두 행렬의 곱(matrix product) $\mathrm{\mathbf Z} = \mathrm{\mathbf {X\cdot Y}}$는 $n \times k$ 행렬이고 $\mathrm{\mathbf Z}$  원소 $z_{ij}$ ($i={1,\ldots,n}$, $j={1,\ldots,k}$) 아래와 같이 정의됨

$$
 z_{ij} = \sum_{r=1}^{m}x_{ir}y_{rj},~~~~\forall~\{i, j\}
$$
- R에서 위와 같은 연산은 `%*%`를 사용

- 예시: 행렬 $\mathrm{\mathbf X}_{2\times 4}$, $\mathrm{\mathbf Y}_{4\times 3}$ 이 아래와 같이 주어졌을 때 두 행렬의 곱 $\mathrm{\mathbf Z}_{2\times 3} = \mathrm{\mathbf{X}}_{2\times 4}\mathrm{\mathbf{Y}}_{4 \times 3}$는 아래와 같음

$$
\mathrm{\mathbf X}=
\begin{bmatrix}
1 &~~~ 1 &   -1 & 1 \\
1 &   -1 &~~~ 1 & 1
\end{bmatrix}, ~~~~~
\mathrm{\mathbf{Y}}=
\begin{bmatrix}
1 &  -2 &  -1 \\
1 &~~~1 &~~~2 \\
1 &~~~3 &~~~1 \\
1 &~~~2 &~~~2
\end{bmatrix}
$$



$$
\mathrm{\mathbf{Z}} = \mathrm{\mathbf{X}}\mathrm{\mathbf{Y}} = 
\begin{bmatrix}
1 &~~~ 1 &   -1 & 1 \\
1 &   -1 &~~~ 1 & 1 \\ 
\end{bmatrix} \cdot  
\begin{bmatrix}
1 &  -2 &  -1 \\
1 &~~~1 &~~~2 \\ 
1 &~~~3 &~~~1 \\
1 &~~~2 &~~~2 
\end{bmatrix} 
 = 
\begin{bmatrix}
2  &  -2 & 2 \\
2  &~~~2 & 0 
\end{bmatrix}
$$

```{r mat-op-mprod-1, comment=NA}
X <- matrix(c(1,1,1,-1,-1,1,1,1), nrow = 2, ncol = 4)
Y <- matrix(c(1,1,1,1, -2, 1, 3, 2, -1, 2, 1, 2), nrow = 4, ncol = 3)
Z <- X %*% Y
Z
```

**행렬-벡터 연산**

- 행렬 $\mathrm{\mathbf{X}}$의 행 길이와  벡터 $\mathrm{\mathbf y}$의 길이가 같은 경우 $\rightarrow$ $\mathrm{\mathbf y}$를 열 단위로 재사용

$$\mathrm{\mathbf{X}} = 
\begin{bmatrix}
1 & 2 & 4\\
1 & 3 & 2\\
1 & 2 & 1
\end{bmatrix}, ~~~~~
\mathrm{\mathbf y} = [20, 18, 23]^T
$$


$$\mathrm{\mathbf{X}} + \mathrm{\mathbf{y}} = 
\begin{bmatrix}
1 & 2 & 4\\
1 & 3 & 2\\
1 & 2 & 1
\end{bmatrix} + 
\begin{bmatrix}
20 & 20 & 20\\
18 & 18 & 18\\
23 & 23 & 23
\end{bmatrix} = 
\begin{bmatrix}
21 & 22 & 24\\
19 & 21 & 20\\
24 & 25 & 24
\end{bmatrix}
$$


```{r mat-vec-op-01, comment=NA}
#행렬-벡터 합 연산
# X = 3 by 3 행렬; y = 3 by 1 벡터
x <- c(1, 1, 1, 2, 3, 2, 4, 2, 1)
X <- matrix(x, nrow = 3)
y <- c(20, 18, 23)# 재사용

X + y
```

- 행렬 $\mathrm{\mathbf{X}}$의 길이와  벡터 $\mathrm{\mathbf y}$의 길이가 같은 경우 $\rightarrow$ 벡터 $\mathrm{\mathbf y}$를 자동으로 원소를 행렬(열단위)로 변환

$$\mathrm{\mathbf{X}} = 
\begin{bmatrix}
1 & 2 & 3\\
4 & 5 & 6\\
7 & 8 & 9
\end{bmatrix}, ~~~~~
\mathrm{\mathbf y} = [1, 2, \ldots, 9]^T
$$



$$\mathrm{\mathbf{X}} + \mathrm{\mathbf{y}} = 
\begin{bmatrix}
1 & 4 & 7\\
2 & 5 & 8\\
3 & 6 & 9
\end{bmatrix} + 
\begin{bmatrix}
1 & 4 & 7\\
2 & 5 & 8\\
3 & 6 & 9
\end{bmatrix} = 
\begin{bmatrix}
2 &  8  & 14\\
4 &  10 & 16\\
6 &  12 & 18
\end{bmatrix}
$$



```{r mat-vec-op-02, comment=NA, error=TRUE}
#행렬-벡터 합 연산
# 행렬 X의 길이와 벡터 y의 길이가 같은 경우
x <- c(1:9); X <- matrix(x, nrow = 3)
length(X); y <- x
X + y

# 길이가 다른 경우
# 1) 행렬 길이보다 큰 경우
y <- c(1:10)
X + y

# 1) 행렬 길이의 약수가 아닌 경우
# y 재사용
y <- c(1:4)
X + y
```


- 행렬-벡터 `%*%` 적용 시 벡터는 $n \times 1$ 행렬로 간주하고 행렬 곱 연산 수행(단 $\mathrm{\mathbf X}$와 벡터 $\mathrm{\mathbf y}$의 길이는 같아야 함).


$$\mathrm{\mathbf{X}}_{4\times 3} = 
\begin{bmatrix}
1 & 2 & 1 \\
1 & 1 & 1 \\
1 & 3 & 3 \\
1 & 4 & 4 
\end{bmatrix}, ~~~~~
\mathrm{\mathbf y}_{3\times 1} = [7, 6, 8]^T
$$


$$\mathrm{\mathbf{X}}\mathrm{\mathbf{y}} = 
\begin{bmatrix}
1 & 2 & 1 \\
1 & 1 & 1 \\
1 & 3 & 3 \\
1 & 4 & 4 
\end{bmatrix} \cdot 
\begin{bmatrix}
7 \\
6 \\
8
\end{bmatrix} = 
\begin{bmatrix}
27 \\
21 \\
49 \\
63
\end{bmatrix}
$$ 


```{r comment=NA}
x <- c(1, 1, 1, 1, 2, 1, 3, 4, 1, 1, 3, 4)
y <- c(7, 6, 8)
X <- matrix(x, nrow = 4, ncol = 3)
X %*% y
```


**행렬의 전치(transpose)**

- 전치 행렬(transpose matrix)는 임의의 행렬의 행과 열을 서로 맞바꾼 행렬임 
- 행렬 $\mathrm{\mathbf X}$의 전치 행렬은 $\mathrm{\mathbf X}^T$ 또는 $\mathrm{\mathbf X}'$ 으로 나타냄
- 행렬 $\mathrm{\mathbf X}$가 다음과 같이 주어졌을 때 전치 행렬 결과

$$\mathrm{\mathbf{X}} = \begin{bmatrix}
1 & 2 & 3\\
4 & 5 & 6
\end{bmatrix} ~~~~~
\mathrm{\mathbf{X}}^T = 
\begin{bmatrix}
1 & 4 \\
2 & 5 \\ 
3 & 6
\end{bmatrix} 
$$

- R에서 행렬을 전치시키는 함수는 `t()` 임

```{r transpose-ex, comment=NA}
# t(object_name): 전치행렬 반환
x <- 1:6
X <- matrix(x, nrow = 2, ncol = 3, byrow = T)
t(X)

# 전치행렬과 행렬 간 곱
x <- c(1, 1, 1, 1, 1, 22.3, 23.2, 21.5, 25.3, 28.0)
X <- matrix(x, nrow = 5)
t(X) %*% X
```

- 벡터-벡터 곱 연산(`%*%` 사용)


$$
\mathrm{\mathbf x} = [1, 2, 3, 4]^T
$$


$$\mathrm{\mathbf x}\mathrm{\mathbf x}^T = 
\begin{bmatrix}
1 \\
2 \\
3 \\
4
\end{bmatrix} \cdot
\begin{bmatrix}
1 & 2 & 3 & 4
\end{bmatrix} = 
\begin{bmatrix}
1 & 2 & 3 & 4 \\
2 & 4 & 6 & 8 \\
3 & 6 & 9 & 12 \\
4 & 8 & 12 & 16
\end{bmatrix}
$$


$$\mathrm{\mathbf x}^T\mathrm{\mathbf x} = 
\begin{bmatrix}
1 & 2 & 3 & 4
\end{bmatrix} \cdot
\begin{bmatrix}
1 \\
2 \\
3 \\
4
\end{bmatrix} = 1 + 4 + 9 + 16 = 30
$$


```{r vec-vec-transpose, comment=NA}
x <- 1:4
x %*% t(x) # 행렬 반환
t(x) %*% x # 스칼라 반환 x %*% x와 동일 결과 출력

```



```{block2, type="rmdtip"}
**참고**: 전치행렬의 성질(통계수학 II 강의내용 참고)

  - $(\mathrm{\mathbf{X}}^T)^T = \mathrm{\mathbf{X}}$
  - $(\mathrm{\mathbf{X} + \mathbf{Y}})^T = \mathrm{\mathbf{X}}^T + \mathrm{\mathbf{Y}}^T$
  - $(\mathrm{\mathbf{X}\mathbf{Y}})^T = \mathrm{\mathbf{Y}}^T\mathrm{\mathbf{X}}^T$
  - $(c\mathrm{\mathbf{X}})^T = c\mathrm{\mathbf{X}}^T$, $c$는 임의의 상수

  
```

**역행렬(inverse matrix)**

- 행렬의 나눗셈 형태
- 행렬 $\mathrm{\mathbf{X}}$ 가 $n \times n$ 정방행렬(square matrix)일 때, 아래를 만족하는 행렬 $\mathrm{\mathbf{Y}}_{n \times n}$가 존재하면 $\mathrm{\mathbf{Y}}$를 $\mathrm{\mathbf{X}}$의 역행렬(inverse matrix)라고 하고 $\mathrm{\mathbf{X}}^{-1}$로 나타냄.

$$
 \mathrm{\mathbf{X}\mathbf{X}^{-1}} = \mathrm{\mathbf{X}^{-1}\mathbf{X}} = \mathrm{\mathbf{I}}_{n\times n}
$$

- 여기서 $\mathrm{\mathbf{I}}_{n\times n}$은 대각 원소가 1이고 나머지 원소는 0인 항등 행렬임
- $2 \times 2$ 행렬의 역행렬은 아래와 같이 구함($3\times 3$ 이상 역행렬 구하는 방법은 **통계수학 II** 강의 참고)

$$\mathrm{\mathbf{X}} = 
 \begin{bmatrix}
 a & b \\
 c & d 
 \end{bmatrix}, ~~~~
 \mathrm{\mathbf{X}}^{-1} = 
 \frac{1}{ad - bc}
 \begin{bmatrix}
~~~d &  -b \\
  -c &~~~a
 \end{bmatrix}
$$

- R에서 정방 행렬의 역행렬은 `solve()` 함수를 사용해 구함

```{r inv-mat, comment=NA}
# 2 by 2 행렬의 역행렬
x <- c(1, 2, 3, 4)
X <- matrix(x, 2)
solve(X)

# 항등 행렬이 나오는지 확인
X %*% solve(X)

```


```{block2, type="rmdtip"}
**참고**: 역행렬의 성질(통계수학 II 강의내용 참고)


  - $(\mathrm{\mathbf{X}}^{-1})^{-1} = \mathrm{\mathbf{X}}$
  - $(\mathrm{\mathbf{X}}^T)^{-1} = (\mathrm{\mathbf{X}}^{-1})^T$
  - $(\mathrm{\mathbf{XY}})^{-1} = \mathrm{\mathbf{Y}}^{-1}\mathrm{\mathbf{X}}^{-1}$


```



**행렬식(determinant)**

- 행렬의 성질을 대표할 수 있는 하나의 값으로 $n \times n$ 정방행렬(square matrix)에서 정의
- 역행렬을 구할 때 임의의 행렬이 0, 즉 위 $2\times 2$ 행렬에서 $ad - bc$의 값이 0이라면 역행렬이 존재할 수 없는데 여기서 $ad - bc$가 $2\times 2$ 행렬의 정방행렬임
- 임의의 정방행렬 $\mathrm{\mathbf X}$의 행렬식은 $|\mathrm{\mathbf X}|$ 또는 $\det(\mathrm{\mathbf{X}})$로 표시함
- $2\times 2$ 행렬의 행렬식은 넓이, $3\times 3$ 이상인 정방 행렬에서는 부피의 개념으로 이해할 수 있음
- 정방행렬 $\mathrm{\mathbf X}_{n\times n}=\{x_{ij}\}$가 주어졌을 때, $i$ 번째 행과 $j$ 번째 열을 제외한 나머지 $(n-1)\times (n-1)$ 정방행렬의 행렬식을 $|\mathrm{\mathbf{X}}_{ij}|$ 라고 하면 이를 $x_{ij}$의 소행렬식(minor)이라 부르고 $x_{ij}$의 여인수(co-factor) $\mathrm{\mathbf{C}}_{ij}$ 는 아래와 같이 정의됨

$$
 c_{ij} = (-1)^{i+j}|\mathrm{\mathbf{X}}_{ij}|
$$

- 이때 $\mathrm{\mathbf X}_{n\times n}$ 행렬식은 임의의 $i$ 또는 $j$에 대해 아래의 식을 통해 구할 수 있음

$$
 \det(\mathrm{\mathbf{X}}) = \sum_{i=1}^{n}x_{ij}c_{ij} = \sum_{j=1}^n x_{ij}c_{ij}
$$

- 행렬식 계산 예시


$$\mathrm{\mathbf{X}} = 
\begin{bmatrix}
1 &~~~5 &~~~0\\
2 &~~~4 & -1\\
0 & -2  &~~~0
\end{bmatrix}
$$



$$\begin{aligned}
\det(\mathrm{\mathbf{X}}) &= x_{11}\det(\mathrm{\mathbf{X}}_{11}) - x_{12}\det(\mathrm{\mathbf{X}}_{12}) + x_{13}\det(\mathrm{\mathbf{X}}_{13}) \\
& \\
& = 1
\begin{vmatrix} 
~~~4 &  -1 \\ 
  - 2&~~~0
\end{vmatrix} -5
\begin{vmatrix}
2 &  -1 \\
0 &~~~0
\end{vmatrix} + 0
\begin{vmatrix}
2 &~~~4 \\
0 &  -2
\end{vmatrix} = -2
\end{aligned}
$$


- R에서 임의 행렬의 행렬식은 `det()` 함수를 이용해 구함


```{r det-example, comment=NA}
X <- matrix(c(1, 2, 0, 5, 4, -2, 0, -1, 0), ncol = 3)
det(X)
```


```{block2, type="rmdtip"}
**참고**: 행렬식의 성질(통계수학 II 강의내용 참고)


   - 행렬 $\mathrm{\mathbf{X}}$, $\mathrm{\mathbf{Y}}$가 정방행렬이면 $\det(\mathrm{\mathbf{XY}}) = \det(\mathrm{\mathbf{X}})\det(\mathrm{\mathbf{Y}})$ 
   - $\det(\mathrm{\mathbf{X}}) = \det(\mathrm{\mathbf{X}}^T)$
   - $\det(c\mathrm{\mathbf{X}}) = c^n \det(\mathrm{\mathbf{X}})$ 여기서 $c$는 임의의 상수
   - $\det(\mathrm{\mathbf{X}}^{-1}) = \det(\mathrm{\mathbf{X}})^{-1}$
  
  
그외 정칙(non-singluar), 비정칙(non-singular), 양정치(positive definite) 행렬 모두 행렬식으로 정의할 수 있고 자세한 내용은 통계수학 II를 통해 학습. 추가적으로 여인수 $c_{ij}$ 를 이용한 역행렬 공식은 아래와 같음


$$\mathrm{\mathbf{X}}^{-1} = \frac{1}{\det(\mathrm{\mathbf{X}})}
\begin{bmatrix}
c_{11} & c_{12} &  \cdots & c_{1n} \\
c_{21} & c_{22} &  \cdots & c_{2n} \\
\vdots & \vdots & \cdots & \vdots \\
c_{n1} & c_{n2}  & \cdots & c_{nn}
\end{bmatrix}
$$

```

```{block2, type="rmdimportant"}
**예습**: $3\times 3$ 정방행렬 $\mathrm{\mathbf{X}}$가 아래와 같이 주어졌을 때, $\mathrm{\mathbf{X}}$의 행렬식과 역행렬 $\mathrm{\mathbf{X}}^{-1}$을 직접 계산해 보고, R에서 각각을 구하는 함수를 사용하여 계산 결과가 맞는지 확인


$$\mathrm{\mathbf{X}} = 
\begin{bmatrix}
6 & 1 & 4 \\
2 & 5 & 3 \\
1 & 1 & 2
\end{bmatrix}
$$

  
```


### 행렬의 색인 {#mat-index}

- R의 행렬 객체 내 데이터 접근은 벡터와 유사하게 행과 열에 대응하는 색인 또는 이름으로 접근 가능
- 행렬의 행과 열은 꺽쇠 `[]' 안에서 ,(콤마)로 구분
- `X[idx_row, idx_col]`: 행렬 `X`의 `idx_row` 행, `idx_col`행에 저장된 값 반환(색인번호는 1부터 시작)
- `idx_row`, `idx_col`을 지정하지 않으면 전체 행 또는 열을 선택

```{r mat-index, comment=NA}
x <- 1:12
X <- matrix(x, ncol = 4)
X

# 1행만 선택
X[1, ]

# 3열만 선택
X[, 3]

# 1:3행만 선택
X[1:3, ]

# 1-2행, 3-4열 선택
X[1:2, 3:4]

```

- 행렬의 각 행과 열에 이름 부여 가능 $\rightarrow$ `matrix()` 함수 인수 중 `dimnames` 에 속성 부여와 동일
- `dimnames()` 함수를 통해 각 행과 열의 이름 확인 및 부여 가능
- `dimnames(object)[[i]], i = 1, 2` 를 통해 행(`i = 1`)과 열(`i = 2`) 이름 변경 및 부여 가능
- 위와 유사한 기능을 하는 함수
   - `rownames()`: 헹 이름 반환 및 부여
   - `colnames()`: 열 이름 반환 및 부여

```{r mat-row-col-name, comment=NA}
# matrix 함수 내에서 행렬 이름 동시 부여
X <- matrix(1:9, ncol = 3, 
            dimnames = list(c("1", "2", "3"), # 행 이름
                            c("A", "B", "C")))# 열 이름
X

# dimnames()를 이용한 이름 확인
dimnames(X) # 행렬에 대한 리스트 반환

# dimnames() 함수로 행 이름 변경
dimnames(X)[[1]] <- c("r1", "r2", "r3")

# dimnames() 함수로 열 이름 변경
dimnames(X)[[2]] <- c("c1", "c2", "c3")
dimnames(X)
X

# rownames()를 통해 행 이름 확인
rownames(X)
# colnames()를 통해 열 이름 확인
colnames(X)


# rownames()를 이용해 행 이름 변경
rownames(X) <- c("apple", "strawberry", "orange")
rownames(X)
# colnames()를 이용해 행 이름 변경
colnames(X) <- c("costco", "emart", "homeplus")
colnames(X)
X

```

- 행과 열에 대한 이름이 존재한다면 벡터와 마찬가지로 이름으로 색인 가능

```{r mat-name-index, comment=NA}
X[c("apple", "orange"), c("emart")]

# 2번째 열에 해당(emart)를 제외한 나머지 열 반환
X[, colnames(X)[-2]]

```


- 색인한 행렬 원소에 다른 값 할당

```{r mat-idx-assign, comment=NA}
y <- c(1:12); Y <- matrix(y, ncol = 3)
Y

# 2, 4 행과 2-3열에 다른 값 할당
Y[c(2, 4), 2:3] <- matrix(c(1, 2, 1, 4), ncol = 2)

# 행렬 값 할당 다른 예시
X <- matrix(nrow = 4, ncol = 3) # NA 값으로 구성된 4 by 3 행렬
X
y <- c(1, 0, 0, 1); Y <- matrix(y, ncol = 2)
X[3:4, 2:3] <- Y
X

```

- 행렬 필터링 $\rightarrow$ 색인 대신 조건 사용(벡터와 동일)

```{r mat-filtering, comment=NA}
X = matrix(c(1,2,4,3,2,3,5,6), nrow = 4, ncol = 2)

# X의 1열이 3보다 작거나 같은 행 필터링
X[X[,1] <= 3, ]

# 논리값을 활용한 필터링
idx <- X[, 1] <= 3; idx
X[idx, ]
```


### 행과 열 추가 및 제거

- 행렬 재할당(re-assignment)를 통해 열이나 행을 직접 추가하거나 삭제 가능
- `cbind()` (열 붙이기, column bind), `rbind()` (행 붙이기, row bind) 함수 사용

```{r binding, comment=NA}
j <- rep(1, 4)
Z <- matrix(c(1:4, 1, 1, 0, 0, 1, 0, 1, 0), nrow = 4, ncol = 3)
Z
cbind(j, Z) # 열 기준으로 붙이기
# 길이가 다른 경우 재사용
cbind(1, Z)

# Z 행렬 앞에 j 열 붙혀서 새로운 Z 생성
Z <- cbind(j, Z)

# 행 기준으로 붙이기
Z <- rbind(Z, 2)

```

- 행 또는 열의 제거는 벡터에서와 마찬가지로 색인 앞에 `-` 사용

```{r mat-element-delete, comment=NA}
# 첫 번째 행 제거
Z[-1, ]

# 1, 5행 , 3열 제거
Z[-c(1, 5), -3]
```


```{block2, type="rmdnote"}
`cbind()` 또는 `rbind()` 함수는 다음 주에 배울 데이터 프레임에도 적용 가능하다.
```


### 행렬 관련 함수


- `diag()`: 대각행렬 생성 또는 대각원소(diagonal elements) 추출
- 대각행렬: 주 대각선을 제외한 모든 원소가 0인 $n\times n$ 정방행렬로 다음과 같이 정의

$$
 \mathrm{\mathbf{D}} = \{d_{ij}\},~~~~i, j \in \{1, 2, \ldots, n\},~~~~\forall~ i \neq j \rightarrow d_{ij} = 0
$$
```{r diag-mat, comment=NA}
D <- diag(c(1:5), 5)
D
# 3차원 항등 행렬(모든 대각원소가 1인 행렬)
I3 <- diag(1, 3)

#대각원소 추출
diag(D)

# 대각원소 재할당
diag(D) <- rep(1, 5)
```

```{block2, type="rmdnote"}
객체는 속성(attribute)을 갖고 그 속성에 따라 데이터의 구조가 정해짐. 즉 속성은 데이터에 대한 메타 데이터임. 객체의 속성은 대표적으로 이름(names), 차원(dimension), 클래스(class)로 정의되고 객제에 대한 자세한 정보를 파악하기 위해 제공되는 몇 가지 함수들에 대해 알아봄. 

R은 앞서 언급한 바와 같이 객체지향언어(object oriented program, OOP)이고 세 가지 유형의 객체지향 시스템(S3, S4, S5)이 존재함. R의 핵심적인 함수 및 패키지는 S3 객체 시스템을 사용하고 있기 때문에 알아둘 필요가 있으나 본 강의의 범위를 벗어나기 때문에 이번 학기에는 다루지 않을 것임. 

```


- `dim(object_name)`: 행렬 또는 데이터 프레임의 행과 열의 개수(차원)를 반환

```{r dim-ex, comment=NA}
# dim(): 객체의 차원(dimension)을 반환
Z
dim(Z)
```

- `nrow()` 또는 `NROW()`: 행렬의 행 길이 반환
- `ncol()` 또는 `NCOL()`: 행렬의 행 길이 반환

```{r ncol-row-ex, comment=NA}
nrow(Z); ncol(Z)
```


> `nrow()/ncol()`과 `NROW()/NCOL()`의 차이점
> 
> - `nrow()/ncol()`은 행렬 또는 데이터 프레임에 적용되며 벡터가 인수로 사용될 때 `NULL` 값을 반환하는데 비해 `NROW()/NCOL()`은 벡터의 길이도 반환 가능



- `attributes()`: 객체가 갖는 속성을 반환함

```{r attribute-ex-1, comment=NA}
x <- 1:9; X <- matrix(x, ncol = 3)
# 객체의 속성 확인
attributes(x)
attributes(X)
```


- `class()`: 객체의 클래스 명칭 반환 및 클래스 부여

```{r attribute-ex-2, comment=NA}
# 객체의 class 확인
class(x); class(X)
# 객체의 class 부여
class(x) <- "this is a vector"
```

- `str()`: 객체가 갖고 있는 데이터의 구조 확인

```{r attribute-ex-3, comment=NA }
# 객체의 구조 파악
str(x); str(X)

# x와 X에 이름(name) 속성을 추가한 경우
names(x) <- paste0("x", 1:9)
dimnames(X) <- list(paste0("r", 1:3), 
                    paste0("c", 1:3))
attributes(x); attributes(X)
class(x); class(X)
str(x); str(X)
```


- `attr(object, "attribute_name")`: 객체가 갖고 있는 속성을 지정해서 확인

```{r attributes-ex-4, comments=NA}
# 객체 속성 요소 확인
attr(x, "names")
attr(X, "dimnames")
```


### 벡터와 행렬의 차이점 {#vec-mat-diff}

- 행렬은 개념적으로 $n \times 1$ 벡터가 2 개 이상 묶어져서 행과 열의 속성을 갖지만 기본적으로는 벡터

```{r vec-mat-ex1, comment=NA}
z <- 1:8
U <- matrix(z, 4, 2)
length(z) # 입력 벡터 원소의 길이가 8
```

- R에서 `U`가 행렬임을 나타내기 위해 추가적인 속성(attribute)를 부여


```{r vec-mat-ex2, comment=NA}
class(z) # 벡터
attributes(z)

class(U) # 행렬
attributes(U)
```


### 의도치 않은 차원축소 피하기 {#mat-dim-reduc-sway}

- 다음 행렬에서 한 행을 추출

```{r}
Z <- matrix(c(1:8), 4, 2)
z <- Z[2, ]

attributes(Z) # 행과 열의 차원 수를 표시

# 객체 z의 속성및 형태는? 
attributes(z) # 차원이 존재하지 않음

```

- 차원축소를 방지하는 방법 $\rightarrow$ `r`을 벡터가 아닌 $1 \times 2$ 행렬로 인식

```{r}
z <- Z[2, , drop = FALSE]
attributes(z)
```

- `as.matrix()`를 이용한 직접 변환

```{r}
z <- as.matrix(Z[2, ])
class(z)
z # 행렬이 변환됨을 유의
```



## 배열(array) {#array}


- 통계학의 관점에서 R의 행렬의 행은 조사 대상이 되는 사람, 동물 등 관측 대상에 해당하고, 열은 대상의 특성을 표현하는 변수(예: 몸무게, 키, 혈압 등)에 해당 $\rightarrow$ 2차원 구조
- 위와 같은 데이터를 년 단위로 수집한다면? $\rightarrow$ 한 대상자에 해당하는 변수들은 시간에 따라 변함 $\rightarrow$ 시간 차원이 하나 더 존재!
- R에서 이러한 형태의 데이터 구조를 배열(array)이라고 지칭함


### 배열의 생성 및 색인 {#make-array}

- 동일한 유형의 데이터가 2차원 이상으로 구성된 데이터 구조
- 동일한 차원($n\times p$)의 배열(행렬)이 $k$ 개 방에 저장된 데이터 구조
- 배열 생성 함수

```{r, eval=FALSE}
# array() 함수 인수 구조
array(data, # 저장할 데이터 벡터 또는 행렬
      dim,  # 배열의 차원 지정
      dimnames # 배열 차원 명칭
      )
```

- 통계학과 3명의 학생에 대한 중간고사 보기 전까지 한 번의 퀴즈와 중간고사 점수, 그리고 기말고사 보기 전까지 한 번의 퀴즈와 기말고사 점수 데이터 가정

```{r}
x <- c(75, 84, 93, 65, 78, 92)
y <- c(82, 78, 85, 88, 75, 88)

first_term <- matrix(x, nrow = 3, ncol = 2)
second_term <- matrix(y, nrow = 3, ncol = 2)

first_term
second_term

# 위 두 데이터를 2층 짜리 배열로 구성
Z <- array(data = c(first_term, second_term), 
           dim = c(3, 2, 2))
Z

# Z의 속성
attributes(Z)

# Z의 클래스
class(Z)

# Z의 구조
str(Z)
```

- 배열 내 데이터 접근은 색인을 통해 가능(벡터 행렬과 동일)

```{r array-index, comment=NA}
# 첫 번째 층만 추출
Z[, , 1]

# 두 번째 층에서 2-3행 만 추출
Z[2:3, , 2]
```


### 배열의 확장 예제 {#rray-extend-example}

> [데이터 사이언스 스쿨](https://datascienceschool.net/view-notebook/9af8d8e93c084bc49f0ac2bb8a20e2a4/) 참고

- 배열 구조를 갖는 가장 대표적인 데이터 중 하나가 이미지(사진)
- 이미지 데이터는 픽셀(pixel) 이라는 세분화된 작은 이미지를 직사각형 형태로 모은 형태 
- 전체 이미지는 세로픽셀수 $\times$ 가로픽셀수 로 표현됨 $\rightarrow$ **행렬**
- 픽셀의 색을 숫자로 표현하는 방식을 색공간(color space)라고 명칭
- 대표적 색공간은 흑백스케일(grey scale), RGB (Red-Green-Blue), HSV(Hue-Saturation-Value) 방식
- RGB 색공간을 사용한 경우 각 색공간별로 동일한 크기의 행렬이 3개 층으로 저장된 상태 $\rightarrow$ **배열**
- RGB는 0 ~ 255 까지 값을 갖고 빨강색 (255, 0, 0), 녹색 (0, 255, 0), 파란색은 (0, 0, 255)임

<br/>

```{r fig.align='center', echo=FALSE, fig.show='hold', out.width='90%', fig.cap="https://www.geeksforgeeks.org/matlab-rgb-image-representation/ 에서 발췌"}
knitr::include_graphics('figures/Pixel.jpg', dpi = NA)
```

```{block2, type="rmdnote"}
**목표**

    
  - R에서 웹 url로 이미지를 불러오기
  - 불러온 이미지를 R에서 plotting 해보기
  - 이미지 데이터를 직접 수정 해보기 


```


1. 이미지 입출력 패키지 installation 

```{r ex-step1, eval=FALSE}
install.packages("jpeg") # jpeg 파일 입출력 관련 package
install.packages("cowplot") # ggplot add-on package
```

2. 관련 패키지 불러오기

```{r ex-step2, comment=NA, echo=TRUE, message=FALSE}
require(tidyverse)
require(jpeg)
require(cowplot)
```

3. 이미지 불러오기

```{r ex-step3, comment=NA}
myurl <- "https://img.livescore.co.kr/data/editor/1906/ba517de8162d92f4ea0e9de0ec98ba02.jpg"
z <- tempfile()
download.file(myurl,z,mode="wb")
pic <- readJPEG(z)

```

4. 이미지 그래프 출력창에서 확인

```{r ex-step4, comment=NA, fig.align='center', echo=FALSE, fig.show='hold', out.width='90%'}
ggdraw() +
  draw_image(pic)

```

5. 이미지 임의 부분 편집하기

```{r}
pic[300:460, 440:520, 1] <- 0.5
pic[300:460, 440:520, 2] <- 0.5
pic[300:460, 440:520, 3] <- 0.5

ggdraw() +
  draw_image(pic)
```

6. RGB값을 무작위로 샘플링 후 매개변수로 노이즈 가중치 조절해 보기

```{r}
pic <- readJPEG(z)
yr <- pic[300:460, 440:520, 1]
yg <- pic[300:460, 440:520, 2]
yb <- pic[300:460, 440:520, 3]
n <- nrow(yr); p <- ncol(yr)

t <- 0.2
wr <- t * yr + (1 - t)*matrix(runif(length(yr)), nrow = n, ncol = p)
wg <- t * yg + (1 - t)*matrix(runif(length(yg)), nrow = n, ncol = p)
wb <- t * yb + (1 - t)*matrix(runif(length(yb)), nrow = n, ncol = p)


pic[300:460, 440:520, 1] <- wr
pic[300:460, 440:520, 2] <- wg
pic[300:460, 440:520, 3] <- wb

ggdraw() +
  draw_image(pic)

```


## 요인(factor)과 테이블(table) {#factor-table}

- 요인(factor) 데이터 타입은 통계학에서 범주형 변수(categorical variable)을 표현하기 위한 R의 데이터 타입으로 범주형 자료는 크게 명목형(nominal)과 순서형(ordinal) 으로 구분
- 테이블(table) 객체는 factor 객체에 대한 빈도를 나타내기 위해 사용

**범주형 자료**

- 데이터가 사전에 정해진 특정 유형으로만 분류되는 경우: 성별, 인종, 혈액형 등
- 범주형 자료는 명목형과 순서형으로 구분 가능
- 순서형 자료 예: 성적, 교육수준, 선호도, 중증도 등 


### 요인(factor)

- 범주형 자료를 표현하기 위한 R의 객체 클래스
- Factor는 정수형 벡터를 기반으로 levels (수준) 이라는 속성이 추가된 객체임
- 숫자 또는 문자로 표현 되었다 하더라도 범주형으로 이해
- Factor는 level에 해당하는 값만 가질 수 있는 벡터로 간주
- Factor 생성 함수

```{r, eval=FALSE}
# factor 정의 함수
factor(data, # factor로 표현하고자 하는 값. 주로 문자형
       levels, # 요인의 수준, 미리 정한 값
       labels, # 수준에 대한 레이블링
       ordered # 순서형 자료 표시 여부
               # TRUE/FALSE, default = FALSE
       )
```

- 수치형을 factor로 만들어도 처음 입력 값은 문자형으로 변하고 level 값으로 치환
- 대신 (1, 2, 3)이 중심값이 됨 $\rightarrow$ 정수형 벡터임

```{r factor-ex1, comment=NA}
score <- rep(c(4:6), each = 4)
fscore <- factor(score)

typeof(fscore) # factor의 기본 데이터 타입
attributes(fscore) # factor의 속성

# factor의 구조
str(fscore)

# levels(): factor의 수준(levels) 반환 함수
levels(fscore)

# nlevels(): level의 개수 반환
nlevels(fscore)
```

- Factor를 벡터 결합 함수 `c()`로 결합

```{r factor-ex2, comment=NA}
c(fscore, factor(4)) # 강제로 정수형 벡터로 변환
```

- Factor의 범주 수준(level) 및 범주명(label) 지정

```{r factor-ex3, comment=NA}
x <- rep(c(1:2), each = 4)

# factor의 범주 수준 지정
sex <- factor(x, levels = 1:2)
sex

# factor의 범주 수준 및 범주 명칭 지정
sex <- factor(x, levels = 1:2, labels = c("male", "female"))
sex # level의 값이 명칭으로 변경
str(sex)

# 값은 존재하지 않으나 수준을 미리 정해 놓은 경우
severity <- factor(1:2, levels = c(1, 2, 3), labels = c("Mild", "Moderate", "Severe"))
severity[2] <- "Severe"

# 존재하지 않는 수준 할당 
severity[1] <- "Good"
severity
```

- 순서형 factor 생성

```{r factor-ex4}
severity <- factor(rep(1:3, times = 3), levels = 1:3, 
                   labels = c("Mild", "Moderate", "Severe"), 
                   ordered = T)
severity
is.ordered(severity) # 순서형 범주 체크

```

#### 요인형 객체에 적용되는 일반적인 함수 {#factor-generic-fun .unnumbered}

**`tapply()` 함수**

- 특정 요인 수준의 고유한 조합으로 각 그룹에 속한 값에 특정 함수를 적용한 결과를 반환
- 일반적인 함수 사용 형태는 아래와 같음

```{r, eval=FALSE}
# tapply() 함수 사용 인수
tapply(
  x, # 벡터, 
  INDEX, # 벡터를 그룹화할 색인(factor)
  FUN, # 각 그룹마다 적용할 함수
)
```

- 예시: 2020년 4월 15일 총선의 연령별 지지율

```{r factor-tapply-ex1}
# 문자열을 INDEX의 인수로 받은 경우

x <- c(48, 43, 27, 52, 38, 
       67, 23, 58, 72, 85) # 유권자 연령
f <- rep(c("더불어민주당", "미래통합당"), each = 5)
t <- tapply(x, f, mean) # f의 요인 수준 별 x (연령) 평균 계산
t

# x, f 순서를 랜덤하게 섞은 다음 결과
set.seed(12345) # 난수 생성 결과 고정
idx <- order(runif(10))
x <- x[idx]
f <- f[idx]

tapply(x, f, mean)

```

- Factor가 2개 이상인 경우 두 factor 객체의 수준의 조합(AND 조건)에 따른 그룹을 만든 후 그룹별 함수 적용

```{r}
s <- rep(c("M","F"), each = 6)
income <- c(35, 42, 68, 29, 85, 55, 
            30, 40, 63, 27, 83, 52) * 100 # 단위: 만원
age <- c(32, 36, 44, 25, 55, 41, 
         28, 33, 46, 23, 54, 44)

set.seed(12345) # 난수 생성 결과 고정
idx <- order(runif(12))
s <- s[idx]; income <- income[idx]; age <- age[idx]

# age <= 40 -> 1, 40 < age <= 50 -> 2, 
# age >= 50 -> 3 할당: ifelse() 함수 사용
age <- ifelse(age <= 40, 1, 
       ifelse(age <= 50, 2, 3))

tapply(income, list(sex = s, age = age), mean)

```



```{block2, type="rmdnote"}
R에서 가장 많이 활용되는 함수 계열 중 하나로 `*apply()`를 들 수 있다. 벡터, 행렬 등과 같은 R 객체에  `for loop` 대신 반복적으로 동일한 함수를 적용할 때 활용된다. `*apply()` 계열 함수에 대해서는 데이터 프레임 에서 더 상세하게 배울 것임

```


**`split()` 함수**

- `tapply()`는 주어진 요인의 수준에 따라 특정 함수를 적용하지만, `split()`은 데이터를 요인의 수준(그룹) 별로 데이터를 나누어 리스트 형태로 반환


```{r, eval=FALSE}
# split() 함수 사용 인수
split(
  x, # 분리할 데이터(벡터)
  f, # 데이터를 분리할 기준이 되는 factor 지정
)
```

- 예시 

```{r sapply-ex}
# 성별의 수준 남녀 별 소득 수준 분리
split(income, s)

# 두 개 요인 조합으로 income 벡터 분리 
split(income, list(s, age))

# 요인의 각 수준에 대한 인덱스를 반환하고자 하는 경우
abalone <- read.csv("http://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data", 
    header = FALSE) # 전복 데이터셋
# V1: 전복의 종류
# F=암컷; M=수컷, I=새끼
g <- abalone[, 1] # 전복종류만 추출

set.seed(20200410)
idx <- sample(1:length(g), size = 10)
g <- g[idx]
split(1:length(g), g)

```

### 테이블(table) {#table}

- 범주형 변수의 빈도 또는 분할표(교차표)를 표현하기 위한 객체(클래스)
- 범주 별 통계량(평균, 표준편차, 중위수, ...) 요약


**`tapply()`** 함수를 이용한 테이블 만들기

- 길이가 12인 임의의 벡터 `u`를 수준의 개수가 각각 3, 2인 factor의 조합으로 부분벡터로 분리 후 `length()` 적용 $\rightarrow$ `tapply()` 함수 사용

```{r}
u <- runif(12)
f1 <- factor(c(4, 4, 3, 5, 5, 4, 
               3, 3, 4, 5, 5, 3))
f2 <- factor(c("a", "a", "a", "a", "b", "a", 
               "b", "b", "a", "a", "b", "b"))
tapply(u, list(f1, f2), length)

```

- `u`의 값과 상관 없이 두 factor 형 변수 `f1`과 `f2`의 조합에 따른 개수 반환 $\rightarrow$ $2 \times 2$ 분할표(contingency table)
- 위 예시에서 `f1`이 "4" 이고 `f2`가 "b" 인 경우는 없기 때문에 0 값이 있어야 하나, `tapply()` 함수 적용 시 결측값 `NA`를 반환
- `table()`: 하나 이상의 factor의 수준 또는 수준의 조합으로 분할표 생성
- Factor가 3개 이상인 경우 배열로 다차원 분할표 표현
 
```{r table-ex}
# table() 적용 예시
t1 <- table(f1, f2)
t1
typeof(t1); attributes(t1); str(t1)

# factor가 한개인 경우
table(f1)

# factor가 3개인 경우
year = c("1","1","2","3","3","4")
gender = c("M","M","F","M","F","F")
grade = c("A","C","B","B","A","C")

table(gender, grade, year)

```



<!-- ## 데이터 프레임(data frame) {#data-frame} -->

<!-- ### 데이터 프레임 생성 -->

<!-- ### 데이터 프레임 접근 -->

<!-- ### 데이터 프레밍 색인 -->

<!-- ### 데이터 프레임 결합 -->

<!-- ### 데이터 프레임 관련 함수 -->

<!-- ### 외부 데이터 불러오기 및 저장하기 -->



## Homework #2-1

1. `seq()` 함수를 사용하여 $\log(\exp(10))$ 부터 0 까지 길이가 100인 벡터를 생성 후 객체 `lambda`를 생성하시오. 

2. 두 벡터 `p = c(1, 4, 2, 3, 4, 7, 9, 12)`, `q = c(4, 5, 3, 2)` 의 사칙연산 결과를 출력하고, 왜 이런 형태로 계산이 이루어졌는지 기술하시오. 

3. 집합 $A = \{1, 3, 5, 7, 8, 9, 12, 15 \}$이고 집합 $B = \{3, 6, 9, 12, 15, 18\}$ 일 때, $A\cup B$, $A \cap B$, $A - B$ 의 결과를 출력하시오. 

4. `year` 라는 객체에 `{2000, 2001, ..., 2020}`, `month` 객체에 `{Jan, Feb, ..., Dec}`, `day` 객체에 `{1, ..., 31}`을 저장하고 `Date` 라는 `list`를 생성 후 생성 결과를 출력 하시오. 

5. `x` 벡터에 `{23, 22, 24.5, NA, NA, 28, 27.8, 31, NA, NA}`를 입력하고 결측의 개수를 구하시오. 

6. `tidyverse` 패키지를 불러온 후 `mpg` 데이터 셋에서 `hwy` 변수을 `x`라는 객체에 저장한 후, `x` 객체에서 24보다 작은 값들의 개수를 구하시오. 

7. 1부터 150 까지 1 단위 수열을 생성 후 객체 `x`에 저장하고 `x`에서 홀수 값만 추출 하시오. 

8. 두 벡터 ` {1, 2, 3, 0, -1, -2, -1, 0, 7}`와 `{6, -3, 0, 0, 4, -5, 0, 0, 2}` 를 각각 `x`와 `y` 객체에 저장하고, 해당 객체를 이용해 다음 행렬을 생성하시오

$$\mathrm{\mathbf{X}} = 
\begin{bmatrix}
1   &  2 & 3 \\
0   & -1 & -2 \\
-1  &  0 &  7
\end{bmatrix}, ~~~~
\mathrm{\mathbf{Y}} = 
\begin{bmatrix}
6  & 0 & 0 \\
-3 & 4 & 0 \\
0  &-5 & 2
\end{bmatrix}
$$

9. 위 두 행렬의 연산 결과를 출력 하시오

   - $\mathrm{\mathbf{X}}\mathrm{\mathbf{X}}^T$
   - $\mathrm{\mathbf{X}}\mathrm{\mathbf{Y}}$
   - $\mathrm{\mathbf{Y}}\mathrm{\mathbf{X}}$
   - $\det(\mathrm{\mathbf{X}})$
   - $\mathrm{\mathbf{Y}}^{-1}$


10. `runif()` 함수를 이용해 난수 200개를 생성하여 `x`라는 객체에 저장 하시오. 

   - 생성한 `x` 를 이용해 `x`가 0.5 보다 작으면 0, 0.5 보다 크거나 작으면 1 값을 재할당 하시오.
   - 수준이 0, 1이고 수준이름이 각각 "Male", "Female"인 요인형 객체 sex를 생성하시오. 


```{block2, type="rmdimportant"}
**과제 제출 방식**
  
   - R Markdown 문서(`Rmd`) 파일과 해당 문서를 컴파일 후 생성된 `html` 파일 모두 제출할 것
   - 모든 문제에 대해 작성한 R 코드 및 결과가 `html` 문서에 포함되어야 함. 
   - 해당 과제에 대한 R Markdown 문서 템플릿은 https://github.com/zorba78/cnu-r-programming-lecture-note/blob/master/assignment/homework2_template.Rmd 에서 다운로드 또는 스크래이핑 가능
   - 최종 파일명은 `학번-성명.Rmd`, `학번-성명.html` 로 저장
  
  
```








