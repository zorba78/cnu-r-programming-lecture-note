[["index.html", "통계 프로그래밍 언어 2022년도 1학기 충남대학교 정보통계학과 강의노트 Course Overview: 통계프로그래밍언어", " 통계 프로그래밍 언어 2022년도 1학기 충남대학교 정보통계학과 강의노트 한국한의학연구원, 구본초 2022-03-08 Course Overview: 통계프로그래밍언어 본 문서는 2022년도 1학기 충남대학교 정보통계학과에서 개설한 “통계 프로그래밍 언어” 강의를 위해 개발한 강의 노트임 주 단위로 업데이트 될 예정 https://zorba78.github.io/cnu-r-programming-lecture-note/ 에서 확인 pdf 파일 다운로드가 가능하지만 권장하지는 않음. Google Chrome 또는 Firefox 브라우저 사용 권장 온라인 상태 유지 필수 본 문서는 Yihui Xie가 개발한 bookdown 패키지 (Xie 2016)를 활용하여 생성한 문서임. 충남대학교 정보통계학과 이상인 교수님의 2019년도 2학기 “통계패키지활용” 강의 자료 내용과 구성을 참고하여 작성함. 강의소개 R은 뉴질랜드 오클랜드 대학의 Robert Gentleman 과 Ross Ihaka 가 AT&amp;T 벨 연구소에서 개발한 S 언어를 기반으로 개발한 GNU 환경의 통계 계산 및 프로그래밍 언어이다. 현재 R 소프트웨어는 통계학 뿐 아니라 데이터 과학을 포함한 의학, 생물학 등 다양한 분야에서 활용되고 있으며 특히 통계 소프트웨어 개발과 데이터 분석에 많이 활용되고 있다. 본 강의는 데이터 분석을 위한 R의 기초 문법과 통계학 입문에서 학습한 몇 가지 중요한 통계적 이론에 대한 시뮬레이션 방법을 다룬다. 아울러 R package를 활용한 데이터 핸들링 및 시각화 그리고 Rmarkdown을 활용한 재현가능(reproducible)한 문서 작성법에 대해 학습하고자 한다. 교과 목표 R 기초 문법 습득 R 프로그래밍 능력 향상 R 시뮬레이션을 통한 통계학 기초 이론 확인 R markdown을 이용한 재현가능(reproducible)한 보고서 작성 방법 이해 선수과목 통계학 개론, 통계수학 1/통계수학 2 (필수는 아님) 수업 방법 강의: 40 % 실험/실습: 60% 평가방법 중간고사: 30 % 기말고사: 40 % 출석: 10 % 과제: 10 % 퀴즈: 10 % 교재 및 참고문헌 별도의 교재 없이 본 강의 노트로 수업을 진행할 예정이며, 수업의 이해도 향상을 위해 아래 소개할 도서 및 웹 문서 등을 참고할 것을 권장함. 참고문헌 빅데이터 분석 도구 R 프로그래밍 (매트로프 2012) 실리콘밸리 데이터과학자가 알려주는 따라하며 배우는 데이터 과학 (권재명 2017) R을 이용한 데이터 처리&amp;분석 (서민구 2014) R for data science (Wickham and Grolemund 2016) Statistical Computing with R (Rizzo 2019) R programming for data science (Peng 2016) References "],["intro-chap.html", "1 Introduction", " 1 Introduction 1. R프로그램 데이터 분석을 위한 자료 전처리, 통계 및 시각화를 지원하는 컴퓨터 언어 및 환경 1980년 AT&amp;T 벨 연구소의 John Chambers가 개발한 S 언어를 기반으로 1995년 뉴질랜드 Auckland 대학의 통계학과 교수 Robert Gentleman과 Ross Ihaka 가 개발 GNU 기반의 오픈 소스 통계학, 전산학, 생물학, 의학 등 거의 모든 학문 분야에서 분석 도구로 활용되고 있고, 최근 data science 분야에서 널리 활용 2. R 언어의 특징 무료 소프트웨어 CRAN (Comprehensive R Archive Network)에서 배포 특정 vendor가 아닌 전 세계 연구자들이 개발한 알고리즘 및 최신 함수 활용 가능(packaging system) 범용적으로 사용되는 거의 대부분의 운영체제(Windows, Mac, Linux)에서 작동 가능 방대한 개발 및 사용 생태계 형성 강력한 그래픽 기능 유용한 웹 사이트: R과 관련한 거의 모든 문제는 Googling (구글을 이용한 검색)을 통해 해결 가능(검색 주제 + “in R” or “in R software”)하고 아래 열거한 웹 페이지에서 문재 해결을 위한 답을 얻을 수 있음. R 프로그래밍에 대한 Q&amp;A: Stack Overflow R 관련 웹 문서 모음: Rpubs R package에 대한 raw source code 제공: Github R을 이용한 통계 분석: Statistical tools for high-throughput data analysis (STHDA) "],["installation.html", "1.1 R 설치하기", " 1.1 R 설치하기 R 다운로드 사이트: https://www.r-project.org 또는 https://cran.r-project.org 웹 브라우저(i.e. Explore, Chrome, Firefox 등)의 주소 입력창에 https://www.r-project.org 좌측 R Logo 하단 Download 아래 CRAN 클릭 클릭 후 연결한 페이지를 스크롤 후 Korea 아래 링크1 클릭 클릭 후 세 가지 운영체제(Linux, Mac OS X, Windowns)에 따른 R 버전 선택 가능2 Downloads R for Windows 링크 클릭하면 다음과 같은 화면으로 이동 다음 하위폴더에 대한 간략 설멍 base: R 실행 프로그램 contrib: R package의 바이너리 파일 Rtools: R package 개발 및 배포를 위한 프로그램 위 화면에서 base 링크 클릭 후 아래 화면에서 Downloads R 3.x.x for Windows 를 클릭 후 설치 파일을 임의의 디렉토리에 저장 및 실행 다운로드한 파일을 실행하면 아래와 같은 대화창이 나타남 한국어 선택 \\(\\rightarrow\\) 환영 화면에서 [다음(N)&gt;] 클릭 GNU 라이센스에 대한 설명 및 동의 여부([다음(N)&gt;]) 클릭 설치 디렉토리 설정 및 구성요소 설지 여부 원하는 디렉토리 설정(예: C:\\R\\R-3.x.x) 기본 프로그램(“Core Files”), 32 또는 64 bit 용 설치 파일, R console 한글 번역 모두 체크 뒤 [다음(N)&gt;] 클릭 R 스타트업 옵션 지정 기본값(“No” check-button)으로도 설치 진행 가능 본 문서에서는 스타트업 옵션 변경으로 진행 화면표시방식(디스플레이 모드) 설정 변경 MDI: 한 윈도우 내에서 script 편집창, 출력, 도움말 창 사용 SDI: 다중 창에서 각각 script 편집창, 출력, 도움말 등을 독립적으로 열기 도움말 형식에서 HTML 도움말 기반 선택 시작메뉴 폴더 선택 “바로가기”를 생성할 시작 메뉴 폴더 지정 후 [다음(N)&gt;] 클릭 후 설치 진행 하단 “시작메뉴 폴더 만들지 않음” 체크박스 표시 시 시작메뉴에 “바로가기” 아이콘이 생성되지 않음(실행에 전혀 지장 없음) 추가 옵션 지정: 바탕화면 아이콘 생성 등 추가적 작업 옵션 체크 후 [다음(N)&gt;] 클릭 \\(\\rightarrow\\) 설치 진행 설치된 R 버전 정보 레지스트리 저장 여부 .Rdata 확장자를 R 실행파일과 자동 연계 설치 완료 후 바탕화면의 R 아이콘을 더블클릭하면 Rgui가 실행 Figure 1.1: Windows에서 R 실행화면(콘솔 창, SDI 모드) "],["r-check.html", "1.2 R 시작 및 작동 체크", " 1.2 R 시작 및 작동 체크 실습: 설치된 R을 실행 후 보이는 R 콘솔(consle) 창에서 명령어를 실행하고 결과 확인 Figure 1.1 에서 &gt; 기호는 R의 명령 프롬프트(command prompt) 임 \\(\\rightarrow\\) 컴퓨터가 사용자 명령을 기다리고 있다는 기호 현재 R session3 정보(R 설치 버전, locale, 로딩 packages) 출력 # R의 설치 버전 및 현재 설정된 locale(언어, 시간대) 및 로딩된 R package 정보 출력 sessionInfo() R version 4.1.2 (2021-11-01) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.6 LTS Matrix products: default BLAS: /usr/lib/x86_64-linux-gnu/openblas/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/libopenblasp-r0.2.20.so locale: [1] LC_CTYPE=ko_KR.UTF-8 LC_NUMERIC=C [3] LC_TIME=en_US.UTF-8 LC_COLLATE=ko_KR.UTF-8 [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=ko_KR.UTF-8 [7] LC_PAPER=en_US.UTF-8 LC_NAME=C [9] LC_ADDRESS=C LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] kableExtra_1.3.4 gtsummary_1.5.2 gt_0.4.0 glue_1.6.2 [5] forcats_0.5.1 stringr_1.4.0 dplyr_1.0.8 purrr_0.3.4 [9] readr_2.1.2 tidyr_1.2.0 tibble_3.1.6 ggplot2_3.3.5 [13] tidyverse_1.3.1 rmarkdown_2.11 knitr_1.37 loaded via a namespace (and not attached): [1] Rcpp_1.0.8 svglite_2.1.0 lubridate_1.8.0 [4] assertthat_0.2.1 digest_0.6.29 utf8_1.2.2 [7] R6_2.5.1 cellranger_1.1.0 backports_1.4.1 [10] reprex_2.0.1 evaluate_0.15 highr_0.9 [13] httr_1.4.2 pillar_1.7.0 rlang_1.0.1 [16] readxl_1.3.1 rstudioapi_0.13 jquerylib_0.1.4 [19] webshot_0.5.2 munsell_0.5.0 broom_0.7.12 [22] compiler_4.1.2 modelr_0.1.8 xfun_0.29 [25] systemfonts_1.0.4 pkgconfig_2.0.3 htmltools_0.5.2 [28] tidyselect_1.1.2 bookdown_0.24 viridisLite_0.4.0 [31] fansi_1.0.2 crayon_1.5.0 tzdb_0.2.0 [34] dbplyr_2.1.1 withr_2.4.3 grid_4.1.2 [37] jsonlite_1.8.0 gtable_0.3.0 lifecycle_1.0.1 [40] DBI_1.1.2 magrittr_2.0.2 scales_1.1.1 [43] cli_3.2.0 stringi_1.7.6 broom.helpers_1.6.0 [46] fs_1.5.2 xml2_1.3.3 bslib_0.3.1 [49] ellipsis_0.3.2 generics_0.1.2 vctrs_0.3.8 [52] tools_4.1.2 hms_1.1.1 fastmap_1.1.0 [55] yaml_2.3.5 colorspace_2.0-3 rvest_1.0.2 [58] haven_2.4.3 sass_0.4.0 문자열 출력 #문자열 출력 print(&quot;Hello R&quot;) #문자열 [1] &quot;Hello R&quot; # 기호는 주석의 시작을 의미하고 실제로 실행되지 않음 같은 행에서 # 뒤 내용의 코드 역시 실행되지 않음 a 라는 변수에 숫자 9, b라는 변수에 숫자 7를 할당 후 출력 # 수치형 값(scalar)을 변수에 할당(assign) # 여러 명령어를 한줄에 입력할 때에는 세미콜론(;)으로 구분 a = 9; b = 7 a [1] 9 b [1] 7 변수 a와 b의 사칙연산 a+b; a-b; a*b; a/b [1] 16 [1] 2 [1] 63 [1] 1.285714 R 그래픽 맛보기: 정규분포로부터 난수 100개 생성 후 생성된 데이터에 대한 히스토그램 작성 # 난수 생성 시 값은 매번 달라지기 때문에 seed를 주어 일정값이 생성되도록 고정 # &quot;=&quot;과 &quot;&lt;-&quot;는 모두 동일한 기능을 가진 할당 연산자임 #평균이 0 이고 분산이 1인 정규분포에서 난수 100개 생성 set.seed(12345) # random seed 지정 x &lt;- rnorm(100) # 난수 생성 hist(x) # 히스토그램 Figure 1.2: 정규분포 100개의 히스토그램 R 명령어 또는 전체 프로그램 소스 실행 시 매우 빈번히 오류가 나타나는데, 이를 해결할 수 있는 가장 좋은 방법은 앞에서 언급한 Google을 이용한 검색 또는 R 설치 시 자체적으로 내장되어 있는 도움말을 참고하는 것이 가장 효율적임. Table 1.1: R help 관련 명령어 리스트 도움말 보기 명령어 설명 사용법 help 또는 ? 도움말 시스템 호출 help(함수명) help.search 또는 ?? 주어진 문자열을 포함한 문서 검색 help.search(pattern) example topic의 도움말 페이지에 있는 examples section 실행 example(함수명) vignette topic의 pdf 또는 html 레퍼런스 메뉴얼 불러오기 vignette(패키지명 또는 패턴) Vignette 의 활용: 데이터를 기반으로 사용하고자 하는 패키지의 실제 활용 예시를 작성한 문서이기 때문에 초보자들이 R 패키지 활용에 대한 접근성을 높혀줌. vignette() browseVignettes() "],["rconsle-script.html", "1.3 R script 편집기 사용", " 1.3 R script 편집기 사용 실습: R 설치 후 Rgui 에서 제공하는 편집기(R editor)에 명령어를 입력하고 실행 설치된 R을 실행 후 상단 pull-down 메뉴에서 [File] \\(\\rightarrow\\) [새 스크립트]를 선택하면 아래 그림과 같이 편집창(R 인스톨 시 SDI 옵션 기준)이 나타남 편집기 창에 다음 명령어 입력 # R에 내장된 cars 데이터셋 불러오기 cars dataset에 포함된 변수들의 기초통계량 # 출력 2차원 산점도 data(cars) help(cars) # cars 데이터셋에 대한 설명 help 창에 출력 head(cars) # cars 데이터셋 처음 6개 행 데이터 출력 summary(cars) # cars 데이터셋 요약 plot(cars) # 변수가 2개인 경우 산점도 출력 편집창에서 한 줄을 실행시키려면 명령어가 입력된 줄에서 [Ctrl] + [R] 입력 편집창에 입력한 모든 명령어를 실행시키려면 모든 줄을 선택(마우스 또는 [Shift] + \\(\\downarrow\\)) speed dist Min. : 4.0 Min. : 2.00 1st Qu.:12.0 1st Qu.: 26.00 Median :15.0 Median : 36.00 Mean :15.4 Mean : 42.98 3rd Qu.:19.0 3rd Qu.: 56.00 Max. :25.0 Max. :120.00 Figure 1.3: cars 데이터셋의 speed와 dist 간 2차원 산점도: speed는 자동차 속도(mph)이고 dist는 해당 속도에서 브레이크를 밟았을 때 멈출 때 까지 걸린 거리(ft)를 나타냄. R은 명령어를 입력하고 실행결과를 확인하는 대화형(interpreter) 방식 콘솔창에서 \\(\\uparrow\\)/\\(\\downarrow\\)를 누르면 이전/이후 실행 명령 기록 확인 가능 여러 줄 이상 R 명령어라든가 반복적, 장기간 작업을 수행해야 할 경우 R 명령어로 구성된 스크립트 작성 후 일괄 실행하는 것이 일반적 여러 다중 명령 코딩 시 콘솔창에 직접 입력하는 것은 비효율적이므로 스크립트 에디터를 사용 위 예시처럼 R 에디터 사용할 수 있으나 가독성 및 코딩 효율이 떨어짐 과거 많이 사용됐던 R 에디터: WinEdt, Tinn-R, Vim 현재 가장 범용적 R 에디터: Rstudio "],["r-studio.html", "1.4 RStudio", " 1.4 RStudio RStudio: R 통합 분석/개발 환경(integrated development environment, IDE)으로 현재 가장 대중적으로 사용되고 있는 R 사용 환경 명령 곤솔 외 파일 편집, 데이터 객체, 명령 기록(.history), 그래프 등에 쉽게 접근 가능 RStudio 독자적인 개발 환경 제공: Rmarkdown, Rnotebook, Shiny Web Application 등 다양한 R 환경을 제공 버전관리(git, subversion)를 통해 project 관리 가능 무료 및 유료 소프트웨어 제공 1.4.1 RStudio 설치하기 웹 브라우저를 통해 https://rstudio.com 접속 후 상단 DOWNLOAD 링크 클릭 Desktop 또는 Server 버전 중 택일 서버용 설치를 위해서는 Server 클릭 \\(\\rightarrow\\) 소규모 자료 분석용으로는 불필요 여기서는 Desktop 버전 선택 후 다음 링크로 이동 운영체제에 맞는 Rstudio installer 다운로드(여기서는 Windows 버전 다운로드) RStudio installer 다운로드 시 파일이 저장된 폴더에서 보통 RStudio-xx.xx.xxx.exe 형식의 파일명 확인 더블 클릭 후 실행 [다음&gt;] 몇 번 클릭 후 설치 종료 바탕화면 혹은 시작 프로그램에 새로 설치된 RStudio 아이콘 클릭 후 아래와 같은 프로그램 창이 나타나면 설치 성공 1.4.2 RStudio IDE 화면 구성 RStudio는 아래 그림과 같이 4개 창으로 구성4 Figure 1.4: RStudio 화면구성: 우하단 그림은 http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html 에서 발췌 1. 콘솔(console) R 명령어 실행공간(RGui, 정확하게는 R 설치 디렉토리에서 “~/R/R.x.x/bin/x64/Rterm.exe” 가 구동되고 있는 공간) R script 또는 콘솔 창에서 작성한 명령어(프로그램) 실행 및 그 결과 출력 경고, 에러/로그 등의 메세지 확인 Figure 1.5: RStudio 콘솔창에서 명령어 실행 후 출력결과 화면 2. 스크립트(script) (Figure 1.6) R 명령어 입력 공간으로 일괄처리(batch processing) 가능 새로운 스크립트 창 열기 아래 그림과 같이 pull-down 메뉴 좌측 상단 아이콘 클릭 후 [R script] 선택 [File] \\(\\rightarrow\\) [New File] \\(\\rightarrow\\) [R Script] 선택 단축 키: [Ctrl] + [Shift] + [N] 일괄 명령어 처리를 위한 RStudio 제공 단축 키 [Ctrl] + [Enter]: 선택한 블럭 내 명령어 실행 [Alt] + [Enter]: 선택 없이 커서가 위치한 라인의 명령어 실행 R 스크립트 이외 R Markdown, R Notebook, Shiny web application 등 새 문서의 목적에 따라 다양한 종류의 소스 파일 생성 가능 저장된 R 스크립트 파일은 파일명.R로 저장됨 파일 실행 방법 실행하고자 하는 파일을 읽은 후([File] \\(\\rightarrow\\) [Open File] + 파일명 선택 또는 파일명.R 더블 클릭) 입력된 모든 라인을 선택한 뒤 [Ctrl] + [Enter] 파일 읽은 후 [Ctrl] + [Shift] + [S] (현재 열려있는 *.R 파일에 대해) 또는 [Ctrl] + [Shift] + [Enter] Figure 1.6: RStudio 스크립트 새로 열기 RStudio는 코딩 및 소스 작성의 효율성을 위해 여러 가지 단축 키를 제공하고 있음. 단축키는 아래 그림과 같이 pull down 메뉴 [Tools] 또는 [Help]에서 [Keyboard shortcut help] 또는 [Alt] + [Shift] + [K] 단축키를 통해 확인할 수 있음. 또는 Rstudio cheatsheet에서 단축키에 대한 정보를 제공하는데 pull down 메뉴 [Help] \\(\\rightarrow\\) [Cheatsheets] \\(\\rightarrow\\) [RStudio IDE Cheat Sheet]을 선택하면 각 아이콘 및 메뉴 기능에 대한 개괄적 설명 확인 가능함. 3. 환경/명령기록(Environment/History) (Figure 1.7) Environment: 현재 R 작업환경에 저장되어 있는 객체의 특성 및 값 등을 요약 제시 좌측 아래 화살표 버튼 클릭: 해당 객체의 상세 정보 확인 우측 사각형 버튼 또는 객체(데이터셋명) 클릭: 객체가 데이터셋(데이터프레임)인 경우 스프레드 시트 형태로 데이터셋 확인 Figure 1.7: RStudio Environment 창 객체 상세 정보 및 스프레드 시트 출력 결과 History: R 콘솔에서 실행된 명령어(스크립트)들의 이력 확인 4. File/Plots/Packages/Help/Viewer File: Windows 파일 탐색기와 유사한 기능 제공 파일 및 폴더 생성, 삭제/파일 및 폴더명 수정, 그리고 작업경로 설정 Plots: 생성한 그래프 출력 작업 중 생성한 그래프 이력이 Plots 창에 저장: \\(\\leftarrow\\) 이전, \\(\\rightarrow\\) 최근 Zoom: 클릭 시 해당 그래프의 팝업창이 생성되고 팝업창의 크기 조정을 통해 그래프의 축소/확대 가능 Export: 선택한 그래프를 이미지 파일(.png, .jpeg, .pdf 등)로 저장할 수 있고, 클립보드로 복사 가능 Packages: 현재 컴퓨터에 설치된 R 패키지 목록 출력 신규 설치 및 업데이트 가능 Help: help(topic) 입력 시 도움말 창이 출력되는 공간 help(lm) 1.4.3 RStudio 환경 설정 Pull-down 메뉴에서 [Tools] \\(\\rightarrow\\) [Global Options...]를 선택 General: RStudio 운용 관련 전반적 설정 세팅 Figure 1.8: R General option 팝업 창 R version: 만약 컴퓨터에 두 개 이상 다른 R 버전이 설치되어 있는 경우 [Change] 클릭 후 설정 변경 가능 Default Working directory: 작업 디렉토리 지정([Browse] 클릭 후 임의 폴더 설정 가능) Restore most recently opened project at startup: RStudio 실행 시 가장 최근에 작업한 프로젝트로 이동 Restore previously open source documents at startup: RStudio 실행 시 현재 프로젝트에서 가장 최근에 작업한 소스코드 문서를 함께 열어줌. Restore .RData into workspace at startup: 작업 디렉토리에 존재하는 .RData 파일을 RStudio 실행 시 불러옴 Save workspace to .RData on exit: R workspace 자동 저장(.RData) 여부 Always save history (even when not saving .RData) : R 실행 명령 history 저장 여부(Always/Never/Ask) Remove duplicate entries in history: history 저장 시 중복 명령 제거 여부 작업폴더(Working Directory)는 현재 R session에서 사용하는 기본 폴더로서 R 소스파일 및 데이터의 저장 및 로딩시 기본이 되는 폴더임. 소스파일이나 데이터를 불러들일 때 작업 폴더에 있는 파일은 경로명을 지정하지 않고 파일명만 사용해도 됨 작업폴더가 아닌 곳에 있는 파일을 불러들일 때는 경로명까지 써 주어야함. R 데이터를 저장할때도 파일명만 쓰면 기본적으로 작업폴더에 저장되며, 다른 폴더에 저장하기 위해서는 경로명까지 써 주어야 함. 처음 컴퓨터에 RStudio를 설치하면 Working directory는 Windows 사용자 폴더(예: user)의 Document 폴더가 기본값으로 설정되어 있음. 기본 작업폴더를 변경하려면 Figure 1.8에서 설정 가능. 현재 R session의 작업 디렉토리 설정 방법 [Session] -&gt; [Set Working Directoy] -&gt; [Choose Directory]에서 설정 R 콘솔에서 다음과 같은 명령어로 작업폴더를 확인 및 변경 가능 getwd() # 작업폴더 확인 (현재 R 작업폴더) [1] &quot;/home/user/R-project/Lecture-note/cnu-r-programming-lecture-note&quot; # 참고: UNIX 환경에서 작성 # 상대경로 setwd(&quot;..&quot;) # 상위 폴더로 이동(getwd() 폴더 기준) getwd() [1] &quot;/home/user/R-project/Lecture-note&quot; # 상대경로 setwd(&quot;../..&quot;) # 차상위 폴더로 이동(getwd() 폴더 기준) getwd() [1] &quot;/home/user&quot; setwd(&quot;/home/user/R-project/Lecture-note/cnu-r-programming-lecture-note/&quot;) # 절대 폴더 명 입력 getwd() [1] &quot;/home/user/R-project/Lecture-note/cnu-r-programming-lecture-note&quot; # 폴더 내 파일 명 출력 dir() [1] &quot;_bookdown_files&quot; [2] &quot;_bookdown.yml&quot; [3] &quot;_output.yml&quot; [4] &quot;_render.R&quot; [5] &quot;01-introduction_files&quot; [6] &quot;01-introduction.Rmd&quot; [7] &quot;02-data-type_files&quot; [8] &quot;02-data-type.Rmd&quot; [9] &quot;03-string-regexp.Rmd&quot; [10] &quot;04-math-distribution-functions_files&quot; [11] &quot;04-math-distribution-functions.Rmd&quot; [12] &quot;05-rmarkdown-more_files&quot; [13] &quot;05-rmarkdown-more.Rmd&quot; [14] &quot;06-file-import-export.Rmd&quot; [15] &quot;07-control-flow.Rmd&quot; [16] &quot;08-algorithms_files&quot; [17] &quot;08-algorithms.Rmd&quot; [18] &quot;09-final-note.Rmd&quot; [19] &quot;10-simulation_cache&quot; [20] &quot;10-simulation_files&quot; [21] &quot;10-simulation.Rmd&quot; [22] &quot;11-data-manupulation_files&quot; [23] &quot;11-data-manupulation.Rmd&quot; [24] &quot;12-data-visualization_cache&quot; [25] &quot;12-data-visualization_files&quot; [26] &quot;12-data-visualization.Rmd&quot; [27] &quot;15-references.Rmd&quot; [28] &quot;2020&quot; [29] &quot;assignment&quot; [30] &quot;book.bib&quot; [31] &quot;cnu-r-programming-lecture-note.Rproj&quot; [32] &quot;cnu-r-programming.log&quot; [33] &quot;cnu-r-programming.rds&quot; [34] &quot;cnu-r-programming.tex&quot; [35] &quot;code&quot; [36] &quot;css&quot; [37] &quot;data&quot; [38] &quot;dataset&quot; [39] &quot;dataset.zip&quot; [40] &quot;demo&quot; [41] &quot;docs&quot; [42] &quot;examples&quot; [43] &quot;figures&quot; [44] &quot;images&quot; [45] &quot;index.md&quot; [46] &quot;index.Rmd&quot; [47] &quot;init-funs&quot; [48] &quot;krantz.cls&quot; [49] &quot;latex&quot; [50] &quot;output&quot; [51] &quot;packages.bib&quot; [52] &quot;README.md&quot; [53] &quot;render1ed06580bbed6.rds&quot; [54] &quot;test&quot; [55] &quot;video&quot; # 상대경로 dir(&quot;..&quot;) [1] &quot;cnu-r-programming-lecture-note&quot; &quot;quiz-repository&quot; [3] &quot;r-programming-2020-01&quot; &quot;stat-package-lecture&quot; [5] &quot;talk-gallery&quot; &quot;test&quot; [7] &quot;test-learnr&quot; &quot;ust-medical-statistics&quot; # 상대경로 setwd(&quot;../ust-medical-statistics//&quot;) # Lecture-note 하위폴더인 stat 으로 이동 getwd(); dir() [1] &quot;/home/user/R-project/Lecture-note/ust-medical-statistics&quot; [1] &quot;_workflowr.yml&quot; &quot;analysis&quot; [3] &quot;code&quot; &quot;data&quot; [5] &quot;docs&quot; &quot;final-exam&quot; [7] &quot;output&quot; &quot;README.md&quot; [9] &quot;render-slide.R&quot; &quot;slides&quot; [11] &quot;test.svg&quot; &quot;ust-medical-statistics.Rproj&quot; # 절대경로 setwd(&quot;/home/user/R-project/Lecture-note/cnu-r-programming-lecture-note/&quot;) getwd(); dir() [1] &quot;/home/user/R-project/Lecture-note/cnu-r-programming-lecture-note&quot; [1] &quot;_bookdown_files&quot; [2] &quot;_bookdown.yml&quot; [3] &quot;_output.yml&quot; [4] &quot;_render.R&quot; [5] &quot;01-introduction_files&quot; [6] &quot;01-introduction.Rmd&quot; [7] &quot;02-data-type_files&quot; [8] &quot;02-data-type.Rmd&quot; [9] &quot;03-string-regexp.Rmd&quot; [10] &quot;04-math-distribution-functions_files&quot; [11] &quot;04-math-distribution-functions.Rmd&quot; [12] &quot;05-rmarkdown-more_files&quot; [13] &quot;05-rmarkdown-more.Rmd&quot; [14] &quot;06-file-import-export.Rmd&quot; [15] &quot;07-control-flow.Rmd&quot; [16] &quot;08-algorithms_files&quot; [17] &quot;08-algorithms.Rmd&quot; [18] &quot;09-final-note.Rmd&quot; [19] &quot;10-simulation_cache&quot; [20] &quot;10-simulation_files&quot; [21] &quot;10-simulation.Rmd&quot; [22] &quot;11-data-manupulation_files&quot; [23] &quot;11-data-manupulation.Rmd&quot; [24] &quot;12-data-visualization_cache&quot; [25] &quot;12-data-visualization_files&quot; [26] &quot;12-data-visualization.Rmd&quot; [27] &quot;15-references.Rmd&quot; [28] &quot;2020&quot; [29] &quot;assignment&quot; [30] &quot;book.bib&quot; [31] &quot;cnu-r-programming-lecture-note.Rproj&quot; [32] &quot;cnu-r-programming.log&quot; [33] &quot;cnu-r-programming.rds&quot; [34] &quot;cnu-r-programming.tex&quot; [35] &quot;code&quot; [36] &quot;css&quot; [37] &quot;data&quot; [38] &quot;dataset&quot; [39] &quot;dataset.zip&quot; [40] &quot;demo&quot; [41] &quot;docs&quot; [42] &quot;examples&quot; [43] &quot;figures&quot; [44] &quot;images&quot; [45] &quot;index.md&quot; [46] &quot;index.Rmd&quot; [47] &quot;init-funs&quot; [48] &quot;krantz.cls&quot; [49] &quot;latex&quot; [50] &quot;output&quot; [51] &quot;packages.bib&quot; [52] &quot;README.md&quot; [53] &quot;render1ed06580bbed6.rds&quot; [54] &quot;test&quot; [55] &quot;video&quot; R에서 디렉토리 또는 폴더 구분자는 / 임. Windows에서 사용하는 구분자는 \\인데, R에서 \\는 특수문자로 간주하기 때문에 Windows 의 폴더명을 그대로 사용 시 에러 메세지를 출력함. 이를 해결하기 위해 Windows 경로명을 그대로 복사한 경우 경로 구분자 \\ 대신 \\\\로 변경 실습: R 에서 폴더 경로 자유롭게 이동해 보기 Code: Editing: 들여쓰기, 자동 줄바꿈 등 코드 편집에 대한 전반적 설정 Insert spaces for tab: [Tab] 키를 눌렀을 때 공백(space) 개수 결정(본 강의노트: Tab width = 4) Auto-detect code indentation: 코드 들여쓰기 자동 감지 Insert matching parens/quotes: 따옴표, 괄호 입력 시 커서를 따옴표/괄호 사이로 자동 이동 Auto-indent code after paste: 코드 복사 시 들여쓰기 일괄 적용 Vertically align arguments in auto-indent: 함수 작성 시 들여쓰기 레벨 유지 여부 Soft-wrap R source file: 스크립트 편집기 너비를 초과하는 경우 R 코드 행을 자동 줄바꿈 Continue comment when inserting new line: 주석 표시를 다음 행에도 자동 적용 여부 Surround selection on text insertino: 스크립트 상 text 선택 후 자동 따옴표 및 괄호 적용 여부 Focus console after executing from source: 스크립트 실행 후 커서 위치를 콘솔로 이동 여부 Code: Display: 스크립트(소스) 에디터 표시 화면 설정 Highlight selected word: 스크립트 내 text 선택 시 동일한 text에 대해 배경강조 효과 여부 Highlight selected line: 선택된 행에 대해 배경 강조효과 여부 Show line numbers: 행 번호 보여주기 여부 Show margin: 소스 에디터 오른 쪽에 지정한 margin column 보여주기 여부 Show whitespace characters: 에디터에 공백 표시 여부 Show indent guides: 현재 들여쓰기 열 표시 여부 Blinking cursor: 커서 깜박임 여부 Show syntax highlighting in console output: 콘솔 입력 라인에 R 구문 강조 표시 적용 여부 Allow scroll past end of document: 문서 마지막 행 이후 스크롤 허용 여부 Allow drag and drop of text: 선택한 복수의 행으로 구성된 text에 대해 마우스 drag 허용 Highlight R function calls: R 내장 및 패키지 제공함수에 대해 강조 여부 Code: Saving: 스크립트(소스) 에디터 저장 설정 Ensure that source file end with newline String trailing horizontal whitespace when saving Restore last cursor position when opening file Default text encoding: 소스 에디터의 기본 설정 인코딩 설정 변경 RStudio의 Windows 버전 기본 text encoding은 CP949 임 Linux나 Mac OS의 경우 한글은 UTF-8로 인코딩이 설정되어 있음. R 언어는 Linux 환경에서 개발되었기 때문에 UTF-8 인코딩과 호환성이 더 좋음 스크립트 파일의 한글이 깨질 때는 [File] -&gt; [Reopen with Encoding...]에서 encoding 방식 변경 Appearance: RStudio 전체 폰트, 폰트 크기, theme 설정 본인의 취향에 맞게 폰트 및 테마(theme) 설정 취향 \\(\\rightarrow\\) 가독성이 제일 좋고 편안한 theme Pane Layout: RStudio 구성 패널들의 위치 및 항목 등을 수정/추가/삭제(4개 페널은 항시 유지) 실습: 개인 취향에 맞게 RStudio 에디터 및 theme을 변경해 보자!! 1.4.4 RStudio 프로젝트 프로젝트 물리적 측면: 최종 산출물(문서)를 생성하기 위한 데이터, 사진, 그림 등을 모아 놓은 폴더 논리적 측면: R session 및 작업의 버전 관리 프로젝트의 필요성 자료의 정합성 보장 다양한 확장자를 갖는 파일들이 한 폴더 내에 뒤섞일 때 곤란해 질 수 있음 실제 분석 및 그래프 생성에 사용한 정확한 프로그램 또는 코드 연결이 어려움 좋은 프로젝트 구성을 위한 방법 원자료(raw data)의 보호: 가급적 자료를 읽기 전용(read only) 형태로 다루기 데이터 정제(data wrangling 또는 data munging)를 위한 스크립트와 정제 자료를 보관하는 읽기 전용 데이터 디렉토리 생성 작성한 스크립트로 생성한 모든 산출물(테이블, 그래프 등)을 “일회용품”처럼 처리 \\(\\rightarrow\\) 스크립트로 재현 가능 한 프로젝트 내 각기 다른 분석마다 다른 하위 디렉토리에 출력결과 저장하는 것이 유용 RStudio 새로운 프로젝트 생성 RStudio의 강력하고 유용한 기능 새로운 프로젝트 생성: RStudio 메뉴에서 [File] \\(\\rightarrow\\) [New Project] 선택하면 아래와 같은 팝업 메뉴 생성 위 그림에서 New Directory를 선택하면 아래와 같은 팝업 창이 나타나면 아래와 같은 프로젝트 유형이 나타남. 여기서는 New Project 선택 다음 팝업창에서 새로운 프로젝트의 폴더명을 지정 후 Create Project 클릭 아래 [Create projects as subdirectories of]에서 생성하고자 하는 프로젝트의 상위 디렉토리 설정 \\(\\rightarrow\\) 보통 RStudio의 기본 작업폴더로 설정 현재 R session 종료 후 새로운 프로젝트로 session 화면이 열리면 프로젝트 생성 완료 실습: 프로젝트 생성 위에서 설정한 작업폴더 내에 학번-r-programming 프로젝트 생성 생성한 프로젝트 폴더 내에 docs, figures, script 폴더 생성 RStudio Cloud 사용 R의 구동 환경은 Windows 보다는 Linux 운영 환경에 최적화됨 온라인에서 리눅스 환경의 R Studio 사용 가능 "],["r-package.html", "1.5 R 패키지", " 1.5 R 패키지 R 패키지(package): 특수 목적을 위한 로직으로 구성된 코드들의 집합으로 R에서 구동되는 분석툴을 통칭 CRAN을 통해 배포: 3자가 이용하기 쉬움 \\(\\rightarrow\\) R 시스템 환경에서 패키지는 가장 중요한 역할 CRAN available package by name 또는 available package by date에서 현재 등재된 패키지 리스트 확인 가능 R console에서 available.packages() 함수를 통해서도 확인 가능 현재 CRAN 기준(2020-03-17) 배포된 패키지의 개수는 16045 개임 목적: RStudio 환경에서 패키지를 설치하고 불러오기 1.5.1 R 패키지 경로 확인 및 변경 패키지 설치 시 일반적으로 R 환경에서 기본값으로 지정한 라이브러리 폴더에 저장 패키지 설치 전 R 패키지 설치 경로(path) 지정 .libPaths() 함수를 통해 현재 설정된 패키지 저장 경로 확인 .libPaths() [1] &quot;/home/user/R/x86_64-pc-linux-gnu-library/4.1&quot; [2] &quot;/usr/local/lib/R/site-library&quot; [3] &quot;/usr/lib/R/site-library&quot; [4] &quot;/usr/lib/R/library&quot; 일반적으로 첫 번째 경로를 디폴트 라이브러리 폴더로 사용 사용자 지정 라이브러리 경로를 설정 하려면 아래와 같은 절차로 진행 실습: c:/r-library 폴더를 패키지 경로로 지정 C:\\에서 [새로 만들기(W)] -&gt; [폴더(F)] 선택 후 생성 폴더 이름을 r-library로 변경 윈도우즈 [제어판] -&gt; [시스템 및 보안] -&gt; [시스템] -&gt; [고급 시스템 설정] 클릭 [환경변수(N)...] 선택 후 시스템 변수에서 [새로 만들기(W)...] 클릭 아래 그림과 같이 변수 이름(N)에 R_LIBS, 변수 값(V)에 해당 디렉토리 경로 C:\\r-library 입력 후 확인 버튼 클릭 현재 RStudio 종료 후 재실행한 다음 콘솔창에 .libPaths() 입력 후 라이브러리 경로 확인 1.5.2 R 패키지 설치하기 RStudio 메뉴 [Tools] \\(\\rightarrow\\) [Install packages] 클릭 후 생성된 팝업 창에서 설치하고자 하는 패키지 입력 후 설치 RStudio Packages 창에서 [Install] 버튼 누르면 위와 동일한 팝업창이 나타남(위와 동일) R 콘솔 또는 스크립트 창에서 install.packages(package_name) 함수를 사용해서 패키지 설치 실습: install.packages() 함수를 이용해 tidyverse 패키지 설치 install.packages(&quot;tidyverse&quot;) 위 명령어를 실행하면 tidyverse 패키지 뿐 아니라 연관된 패키지들이 동시에 설치됨 1.5.3 R 패키지 불러오기 library() vs. require() library(): 불러오고자 하는 패키지가 시스템에 존재하지 않는 경우 에러 메세지 출력(에러 이후 명령어들이 실행되지 않음) require(): 패키지가 시스템에 존재하지 않는 경우 경고 메세지 출력(경고 이후 명령어 정상적으로 실행) 다중 패키지 동시에 불러오기 RStudio Packages 창에서 설치하고자 하는 패키지 선택 버튼 클릭하면 R workspace로 해당 패키지 로드 가능 스크립트 이용 실습: tidyverse 패키지 불러오기 require(tidyverse) 실무에서 R의 활용능력은 패키지 활용 여부에 달려 있음. 즉, 목적에 맞는 업무를 수행하기 위해 가장 적합한 패키지를 찾고 활용하느냐에 따라 R 활용능력의 차이를 보임. 앞서 언급한 바와 같이 CRAN에 등록된 패키지는 16000 개가 넘지만, 이 중 많이 활용되고 있는 패키지의 수는 약 200 ~ 300 개 내외이고, 실제 데이터 분석 시 10 ~ 20개 정도의 패키지가 사용됨. 앞 예제에서 설치하고 불러온 tidyverse 패키지는 Hadley Wickham (Wickham et al. 2019)이 개발한 데이터 전처리 및 시각화 패키지 번들임. 해당 패키지에 대한 자세한 내용은 2학기 “통계패키지활용” 수업에 다룰 예정임 References "],["r-basic.html", "1.6 R 기초 문법", " 1.6 R 기초 문법 본 절에서 다루는 R 문법은 R 입문 시 객체(object)의 명명 규칙과 R 콘솔 창에서 가장 빈번하게 사용되는 기초적인 명령어만 다룰 예정임. 자세한 내용은 2-3주 차에 다룰 예정. R은 객체지향언어(object-oriented language) 객체(object): 숫자, 데이터셋, 단어, 테이블, 분석결과를 저장하고 있는 R 내부의 모든 변수를 통칭함 “객체지향”의 의미는 R의 모든 명령어는 객체를 대상으로 이루어진다는 것을 의미 알아두면 유용한(콘솔창에서 매우 많이 사용되는) 명령어 및 단축키 ls(): 현재 R 작업공간에 저장된 모든 객체 리스트 출력 rm(object_name): object_name에 해당하는 객체 삭제 rm(list = ls()): R 작업공간에 저장된 모든 객체들을 일괄 삭제 단축키 [Ctrl] + [L]: R 콘솔 창 일괄 청소 단축키 [Ctrl] + [Shift] + [F10]: R session 초기화 예시 print(&quot;Hello R World!!&quot;) [1] &quot;Hello R World!!&quot; x &lt;- 7 y &lt;- 1:30 #1에서 30까지 정수 입력 ls() #현재 작업공간 내 객체명 출력 [1] &quot;도움말 보기 명령어&quot; &quot;사용법&quot; &quot;설명&quot; [4] &quot;a&quot; &quot;b&quot; &quot;cars&quot; [7] &quot;def.chunk.hook&quot; &quot;fig_cap&quot; &quot;hook_output&quot; [10] &quot;tab&quot; &quot;x&quot; &quot;y&quot; rm(x) # 객체 x 삭제 ls() [1] &quot;도움말 보기 명령어&quot; &quot;사용법&quot; &quot;설명&quot; [4] &quot;a&quot; &quot;b&quot; &quot;cars&quot; [7] &quot;def.chunk.hook&quot; &quot;fig_cap&quot; &quot;hook_output&quot; [10] &quot;tab&quot; &quot;y&quot; rm(a,b) # 객체 a,b 동시 삭제 ls() [1] &quot;도움말 보기 명령어&quot; &quot;사용법&quot; &quot;설명&quot; [4] &quot;cars&quot; &quot;def.chunk.hook&quot; &quot;fig_cap&quot; [7] &quot;hook_output&quot; &quot;tab&quot; &quot;y&quot; # rm(list = ls()) # 모든 객체 삭제 R 객체 입력 방법 및 변수 설정 규칙 객체를 할당하는 두 가지 방법:=, &lt;- 두 할당 지시자의 차이점 =: 명령의 최상 수준에서만 사용 가능 &lt;-: 어디서든 사용 가능 함수 호출과 동시에 변수에 값을 할당할 목적으로는 &lt;-만 사용 가능 # mean(): 입력 벡터의 평균 계산 mean(y &lt;- 1:5) [1] 3 y [1] 1 2 3 4 5 mean(x = 1:5) [1] 3 x Error in eval(expr, envir, enclos): 객체 &#39;x&#39;를 찾을 수 없습니다 객체 또는 변수의 명명 규칙 알파벳, 한글, 숫자, _, .의 조합으로 구성 가능(-은 사용 불가) 변수명의 알파벳, 한글, .로 시작 가능 .로 시작한 경우 뒤에 숫자 올 수 없음(숫자로 인지) 대소문자 구분 # 1:10은 1부터 10까지 정수 생성 # &#39;c()&#39;는 벡터 생성 함수 x &lt;- c(1:10) # 1:10으로 구성된 행렬 생성 X &lt;- matrix(c(1:10), nrow = 2, ncol = 5, byrow = T) x [1] 1 2 3 4 5 6 7 8 9 10 X [,1] [,2] [,3] [,4] [,5] [1,] 1 2 3 4 5 [2,] 6 7 8 9 10 # 논리형 객체 .x &lt;- TRUE .x [1] TRUE # 알파벳 + 숫자 # seq(): 수열을 만드는 함수 # 1 에서부터(from) 10 까지(to) 공차가 2(by)인 수열 a1 &lt;- seq(from = 1, to = 10, by = 2) # 한글 변수명 가수 &lt;- c(&quot;Damian Rice&quot;, &quot;Beatles&quot;, &quot;최백호&quot;, &quot;Queen&quot;, &quot;Carlos Gardel&quot;, &quot;BTS&quot;, &quot;조용필&quot;) 가수 [1] &quot;Damian Rice&quot; &quot;Beatles&quot; &quot;최백호&quot; &quot;Queen&quot; [5] &quot;Carlos Gardel&quot; &quot;BTS&quot; &quot;조용필&quot; 잘못된 객체 또는 변수 명명 예시 3x &lt;- 7 Error: &lt;text&gt;:1:2: 예상하지 못한 기호(symbol)입니다. 1: 3x ^ _x &lt;- c(&quot;M&quot;, &quot;M&quot;, &quot;F&quot;) Error: &lt;text&gt;:1:1: 예상하지 못한 입력입니다. 1: _ ^ .3 &lt;- 10 Error in 0.3 &lt;- 10: 대입에 유효하지 않은 (do_set) 좌변입니다 "],["r-markdown-get-start.html", "1.7 R Markdown (맛보기)", " 1.7 R Markdown (맛보기) R 기초 문법 절과 마찬가지로 R Markdown을 이용해 최소한의 문서(html 문서)를 작성하고 생성하는 방법에 대해 기술함. R Markdown에 대한 보다 상세한 내용은 9주차에 다룰 예정임. R Markdown은 R 코드와 분석 결과(표, 그림 등)을 포함한 문서 또는 컨텐츠를 제작하는 도구로 일반적으로 아래 열거한 형태로 활용함 문서 또는 논문(pdf, html, docx) 프리젠테이션(pdf, html, pptx) 웹 또는 블로그 재현가능(reproducible)한 분석 및 연구5 가능 신뢰성 있는 문서 작성 Copy &amp; paste를 하지 않고 효율적 작업 가능 R Markdown 문서를 통해 최종 결과물(pdf, html, docx)이 도출되는 process 현재 공식적인 프로세스는 knitr + rmarkdown + pandoc + RStudio + github Figure 1.9: R Markdown의 최종 결과물 산출과정(http://applied-r.com/project-reporting-template/) R Markdown 문서 시작하기 R Markdown 문서 생성: [File] -&gt; [New File] -&gt; [R Markdown..]을 선택 RStudio를 처음 설치하고 위와 같이 진행할 경우 아래와 같은 패키지 설치 여부를 묻는 팝업 창이 나타남. 패키지 설치 여부에 [Yes]를 클릭하면 R Markdown 문서 생성을 위해 필요한 패키지들이 자동으로 설치 설치 완료 후 R Markdown으로 생성할 최종 문서 유형 선택 질의 창이 나타남. 아래 창에서 제목(Title)과 저자(Author) 이름 입력 후 [OK] 버튼 클릭(Document, html 문서 선택) 아래 그림과 같이 새로운 문서 창이 생성되고 test.Rmd 파일로 저장6 문서 상단에 Knit 아이콘을 클릭 후 Knit to HTML 클릭 또는 문서 아무 곳에 커서를 위치하고 단축키 [Ctrl] + [Shift] + [K] 입력 knitr + R Markdown + pandoc \\(\\rightarrow\\) html 파일 생성 결과 Figure 1.10: test.html 문서 화면(저장 폴더 내 test.html을 크롬 브라우저로 실행) 1.7.0.1 R Markdown 문서 구성 R Markdown 문서는 아래 그림과 같이 YAML, Markdown 텍스트, Code Chunk 세 부분으로 구성됨. 1. YAML (YAML Ain’t Markup Language) R Markdown 문서의 metadata로 문서의 맨 처음에 항상 포함되어야 함. R Markdown 문서의 최종 출력 형태, 제목, 저자, 날짜 등의 정보 등을 포함 YAML 언어에 대한 사용 예시는 Xie (2016) 의 Appendix B.2 참고 최소 형태의 YAML 예시 --- title: &quot;Hello R Markdown&quot; author: &quot;Zorba&quot; date: &quot;2020-03-17&quot; output: html_document --- 2. Markdown 텍스트 Markdown 문법은 15주 차 강의에서 배울 예정임 R Markdown 레퍼런스 가이드 참조 그림 삽입: ![](path/filename) 그립 삽입 구문 ![](figures/son.jpg) 3. Code Chunk 실제 R code가 실행되는 부분임 Code chunk 실행 시 다양한 옵션들이 있으나 이 부분 역시 15주 차 강의에서 간략히 다룰 예정임 Code chunk는 ```{r}로 시작되며 r은 code 언어 이름을 나타냄. Code chunk는 ``` 로 종료 R Markdown 문서 작성 시 단축키 [Ctrl] + [Alt] + [I]를 입력하면 Chunk 입력창이 자동 생성됨 Chunk option에 대한 상세 내용은 https://yihui.org/knitr/options/ 또는 R Markdown 레퍼런스 가이드 참조 Code chunk 예시 Xie의 R Markdown: The Definitive Guide에서 발췌 ```{r} fit = lm(dist ~ speed, data = cars) b = coef(fit) plot(cars) abline(fit) ``` fit = lm(dist ~ speed, data = cars) b = coef(fit) plot(cars) abline(fit) Code chunk에서 외부 그림 파일 불러오기(Xie, Allaire, and Grolemund (2018) 에서 예시 발췌) knitr::include_graphics(rep(&#39;figures/knit-logo.png&#39;, 3)) Homework 1: R Markdown 문서에 아래 내용을 포함한 문서를 html 파일 형식으로 출력 후 제출 간략한 자기소개 및 “통계 프로그래밍 언어” 수업에 대한 본인만의 목표 기술 본인이 setting 한 RStudio 구성 캡쳐 화면을 그림 파일로 저장하고 R Markdown 문서에 삽입(화면 캡쳐 시 생성 프로젝트 내 폴더 내용 반드시 포함) 현재 R 작업폴더(처음 R 시작 시 디폴트로 설정된 폴더) 및 작업폴더 내에 있는 파일명 출력 현재 R 작업폴더에서 차상위 폴더의 파일명 출력 패키지 ggplot2 패키지 설치 후 cars 데이터셋의 2차원 산점도(hint: help(geom_point) 또는 googling 활용)를 문서에 포함 References "],["data-type.html", "2 R 객체(R object)", " 2 R 객체(R object) 학습목표(2 주차): R에서 사용 가능한 데이터 타입에 대해 알아보고, 고유 데이터 타입으로 구성한 객체(스칼라, 백터, 리스트)와 이와 연관된 함수들을 익힌다. 학습 필요성 R언어는 타 프로그래밍 언어와 유사한 데이터 타입(정수형, 실수형, 문자형 등)을 제공 R 언어가 다른 언어와 차이점 \\(\\rightarrow\\) 데이터 분석에 특화된 벡터(vector), 행렬(matrix), 데이터프레임(data frame), 리스트(list)와 같은 객체 7 제공 R 패키지에서 제공되는 함수 사용 방법은 R의 객체에 따라 달라질 수 있음 R 언어를 원활히 다룰 수 있으려면 R에서 데이터 객체의 형태, 자료 할당 및 그 연산 방법에 대한 이해가 필수적으로 선행되어야 함 R의 데이터 타입 수치형(numeric): 숫자(정수, 소수) 문자열(string): \"충남대학교\", \"R강의\" 논리형(logical): TRUE/FALSE 결측값(NA): 자료에서 발생한 결측 표현 공백(NULL): 지정하지 않은 값 요인(factor): 범주형 자료 표현(수치 + 문자 결합 형태로 이해하면 편함) 기타: 숫자아님(NaN), 무한대(Inf) 등 R 객체의 종류 스칼라(상수형, scalar 또는 atomic) 벡터(vector): R의 기본연산 단위 리스트(list) 행렬(matrix) 배열(array) 데이터프레임(data frame) Figure 2.1: R 데이터 타입 구조 다이어그램: R, Python 분석과 프로그래밍 (by R Friend)에서 발췌 후 수정 "],["프로그래밍.html", "2.1 프로그래밍", " 2.1 프로그래밍 2.1.1 Prerequisites 예약어(researved words): R에서 의미(sementic)를 미리 정해 놓은 단어 Table 2.1: R 예약어 종류 및 설명 R 예약어 설명 if, else, while, function, in, next, break 조건, 함수, 반복문에 사용 TRUE/FALSE 논리 상수(logical constants) NULL 정의되지 않은 값 혹은 값이 없음 표현 Inf 무한(infinity) NaN 숫자가 아님(not a number) NA 결측값(not available) NA_integer_, NA_real_, NA_complex_, NA_character_ 결측값을 처리하는 상수 … 함수가 다른 함수에 인자를 전달하도록 지원 변수(variable): 사용자가 프로그램 처리를 위해 지정한 단어 적당한 값을 저장하고 나중에 필요시 해당 값을 호출해 사용하기 위한 목적으로 사용되는 표식(label) 예약어를 변수명으로 사용할 수 없음 통계프로그래밍언어 강의노트: R 기초문법 참고 고수준 언어(high-level language): 사람이 읽고 쓰기 쉬운 형태의 명령어를 컴퓨터가 읽고 처리할 수 있도록 고안된 프로그래밍 언어 컴퓨터가 이해할 수 있는 언어 \\(\\rightarrow\\) 중앙처리장치(central processing unit, CPU)가 이해하는 언어 \\(\\rightarrow\\) 기계어(machine language) 기계어는 0과 1로 구성된 이진수(binary number)임(예: 0100101001001001001110110101101010110) 고수준 언어의 종류: C, C++, JAVA, 베이직, Perl, Python, R, … 번역기(translator): 사람이 이해할 수 있는 표현(언어)를 기계(컴퓨터)가 이해할 수 있는 언어(기계어)로 변환 인터프리터(interpreter) 컴파일러(compiler) 인터프리터: 코드(스크립트) 한 줄을 즉석에서 읽고, 파싱(parsing, 프로그램을 검사하고 프로그램의 문법적 구조를 분석해 컴퓨터가 이해할 수 있도록 번역)하고 해석해 명령을 실행 R, Python, MATLAB 등은 인터프리터를 번역기로 사용 Interactive 모드 \\(\\rightarrow\\) R 프롬프트(&gt;) 뒤에 한 줄의 명령어를 작성하면 즉시 처리 후 다음 입력을 받을 준비(prompt)를 함. 안녕하세요!! 통계패키지활용 수업에서 R을 배우고 있습니다. 처음이라 실수가 많습니다. 앞으로 잘 부탁해요!! Error: &lt;text&gt;:1:6: 예기치 않은 &#39;!&#39;입니다 1: 안녕하세요! ^ print(&quot;안녕하세요!!&quot;) print(&quot;통계패키지활용 수업을 위해 R을 배우고 있습니다.&quot;) print(&quot;처음이라 실수가 많습니다.&quot;) print(&quot;앞으로 잘 부탁해요!!&quot;) [1] &quot;안녕하세요!!&quot; [1] &quot;통계패키지활용 수업을 위해 R을 배우고 있습니다.&quot; [1] &quot;처음이라 실수가 많습니다.&quot; [1] &quot;앞으로 잘 부탁해요!!&quot; 컴파일러: 완전한 프로그램을 하나의 파일에 담고 파일 안에 저장되어 있는 소스 코드를 기계어로 번역 후 다음 실행할 수 있도록 변환한 기계어를 파일에 담음. 보통은 .exe, .dll 파일 형태로 저장됨 2.1.2 프로그램 프로그램(program): 특정 작업(목적)을 수행할 수 있도록 작성한 일련의 R 문장(명령어)의 집합 일련의 문장(명령어)들은 텍스트 편집기를 통해 작성하며, 스크립트(script)로 명칭 되는 파일로 저장 \\(\\rightarrow\\) R 스크립트 .R 확장자를 가짐 # Hello.R print(&quot;안녕 R!!&quot;) #한국어 print(&quot;Hi R!!&quot;) # 영어 print(&quot;こんにちはR!!&quot;) # 일본어 print(&quot;Γεια R!!&quot;) #그리스어 source(&quot;examples/hello.R&quot;, encoding = &quot;UTF-8&quot;) [1] &quot;안녕 R!!&quot; [1] &quot;Hi R!!&quot; [1] &quot;こんにちはR!!&quot; [1] &quot;Γεια R!!&quot; 예시: 텍스트 파일에서 가장 자주 나오는 단어 찾기 프로그램 https://statkclee.github.io/r4inf/r-intro.html#r-intro-what-is-a-program 참고 require(tidyverse) require(stringr) require(ggpubr) require(ggthemes) text_dat &lt;- readLines(&quot;data/text-example-01.txt&quot;) # 공백 또는 구둣점 문자를 기준으로 텍스트 나누기 # 공백 또는 구둣점 문자 기준으로 텍스트 토큰화 split_wd &lt;- str_split(text_dat, pattern = &quot;\\\\b|[[:punct:]]&quot;) split_wd &lt;- do.call(c, split_wd) id &lt;- grepl(&quot;[a-zA-Z]+&quot;, split_wd) #알파벳을 포함한 단어 인덱스 split_wd &lt;- split_wd[id] unique_wd &lt;- unique(split_wd) # 중복을 제외한 총 사용 단어 res_v &lt;- vector(&quot;integer&quot;, length(unique_wd)) # 저장 벡터 생성 for (i in seq_along(unique_wd)) { for (j in seq_along(split_wd)) { if (unique_wd[i] == split_wd[j]) { res_v[i] &lt;- res_v[i] + 1 } } } bind_cols(&quot;word&quot; = unique_wd, &quot;freq&quot; = res_v) %&gt;% arrange(desc(freq)) 프로그램 작성을 위한 개념적 요소 입력(input): 외부로부터 가져온 데이터, 값 등 출력(output): 입력에 대한 반응(결과 출력, 파일 저장, 음악 재생, …) 순차실행(sequential execution): 스크립트 또는 코드 작성 순서에 따라 한줄씩 실행 조건실행(conditional execution): 특정 조건에 따라 문장(명령)을 실행하거나 건너뜀 번복실행(iterative execution): 특정 명령을 반복적으로 실행 재사용(resuse): 스크립트의 집합(다수 줄로 구성된 코드 또는 스크립트)에 이름을 부여하고 저장 \\(\\rightarrow\\) 사용자 지정 함수(function) 프로그램 오류의 종류 구문오류(syntax error): R 언어가 이해할 수 없는 문장 또는 문법으로 실행했을 때 나타나는 오류 \\(\\rightarrow\\) 가장 고치기 쉽고 즉각적으로 알려줌 논리 또는 run-time 오류(logic or run-time error): 구문은 완벽하지만 실행 순서 또는 논리적으로 연관방식에 문제가 있어서 명령어를 수행할 수 없는 경우 의미론적 오류(sementic error): 프로그램은 구문적으로 오류가 없고 실행되지만 올바른 결과를 출력하지 않는 경우 \\(\\rightarrow\\) 제일 고치기 어려움 가장 간단한 프로그래밍은 순차적으로 명령을 실행하되 입력 시 흐름을 잠시 중단하고 대기하는 방법 \\(\\rightarrow\\) 프롬프트 상 명령어 한 줄씩 입력 # 아주 간단한 프로그래밍 예제 # readline() 함수 이용해 R한테 인사 받기 name &lt;- readline(&quot;What&#39;s your name?: &quot;) cat(&quot;Hello, &quot;, name, &quot;!\\n&quot;, sep = &quot;&quot;) # readline() 함수를 이용해 알바비 계산 x &lt;- as.numeric(readline(prompt = &quot;하루 아르바이트 시간을 입력하시오: &quot;)) y &lt;- as.numeric(readline(prompt = &quot;시급을 입력하시오 (단위=원): &quot;)) z &lt;- as.numeric(readline(prompt = &quot;한달 동안 총 몇 일 동안 일을 하셨나요? &quot;)) cat(&quot;월 급여는 &quot;, x * y * z, &quot; 원 입니다.\\n&quot;, sep = &quot;&quot;) "],["scalar.html", "2.2 스칼라(scalar)", " 2.2 스칼라(scalar) 단일 차원의 값(하나의 값): \\(1 \\times 1\\) 백터로 표현 \\(\\rightarrow\\) R 데이터 객체의 기본은 벡터!! 데이터 객체의 유형은 크게 숫자형, 문자열, 논리형이 있음 스칼라를 입력시 R의 벡터 지정 함수인 c()(벡터 부분에서 상세 내용 학습)를 꼭 사용해서 입력할 필요가 없다. 단, 연속되지 않은 두 개 이상 스칼라면 벡터이므로 꼭 c()를 써야 한다. 2.2.1 선언 일반적으로 컴파일이 필요한 언어(예: C 언어)의 경우 변수 또는 객체를 사용 전에 선언이 필요 int x; x = 1; 위 코드에서 int x; 없이 x = 1을 입력 후 컴파일 하면 에러가 나타나지만 R 언어에서는 변수를 선언할 필요가 전혀 없음 z 가 어떤 데이터 타입인지 언급할 필요가 전혀 없음 \\(\\rightarrow\\) Python, Perl, Matlab 등과 같은 스크립트 언어의 특징. 아래 코드 참조 z &lt;- 3 z [1] 3 2.2.2 숫자형 정수형(integer)과 실수형(double)로 구분됨 정수형 구분시 숫자 뒤 L을 표시 # 정수형 구분자 사용 예시 # typeof(): R 객체의 데이터 타입 반환하는 함수 typeof(10L) [1] &quot;integer&quot; typeof(10) [1] &quot;double&quot; 수치연산(+, -, *, ^, **, /, %%, %/%) 가능: R은 함수형 언어이기 때문에 앞에 기술한 연산자도 하나의 함수로 인식함. 수치 연산자(operator) 및 기본 수학 함수 Table 2.2: R언어의 기본 수치 연산자 수치형 연산자 설명 +, -, *, / 사칙연산 n %% m n을 m 으로 나눈 나머지 n %/% m n을 m 으로 나눈 몫 n ^ m 또는 n ** m n 의 m 승 숫자형 스칼라 연산 적용 예시 # 숫자형 스칼라 a &lt;- 3 b &lt;- 10 a; b [1] 3 [1] 10 # 덧셈 c &lt;- a + b c [1] 13 # 덧셈을 함수로 입력 # &quot;+&quot;(a, b)로 입력한 결과 c &lt;- &quot;+&quot;(a, b) # 뺄셈 d &lt;- b - a d [1] 7 # 곱셈 m &lt;- a * b m [1] 30 # 나누기 dd &lt;- b/a dd [1] 3.333333 # 멱승 b^a [1] 1000 # 나누기의 나머지(remainder) 반환 r &lt;- b %% a r [1] 1 # 나누기의 몫(quotient) 반환 q &lt;- b %/% a q [1] 3 # 연산 우선 순위 nn &lt;- (3 + 5)*3 - 4**2/4 nn [1] 20 2.2.3 문자형 수치형이 아닌 문자 형식의 단일 원소 C와 같은 언어에서 볼수 있는 한개 문자에 대한 데이터 타입 존재하지 않음 수치연산 불가능 따옴표(\" 또는 ')로 문자를 묶어서 문자열 표시 문자열을 다루는 자세한 설명은 5주차에서 자세히 설명할 예정임 h1 &lt;- c(&quot;Hello CNU!!&quot;) h2 &lt;- c(&quot;R is not too difficult.&quot;) typeof(h1); typeof(h2) [1] &quot;character&quot; [1] &quot;character&quot; h1 [1] &quot;Hello CNU!!&quot; h2 [1] &quot;R is not too difficult.&quot; # 문자열의 문자 수 반환 nchar(h1); nchar(h2) [1] 11 [1] 23 # 문자열 연산 error 예시 h1 - h2 Error in h1 - h2: 이항연산자에 수치가 아닌 인수입니다 2.2.4 논리형 스칼라 참(TRUE, T) 또는 거짓(FALSE, F)를 나타내는 값 TRUE/FALSE: 예약어(reserved word) T/F: TRUE와 FALSE로 초기화된 전역 변수 T에 FALSE 또는 어떤 값도 할당 가능 \\(\\rightarrow\\) 가급적 TRUE/FALSE를 명시하는 것이 편함 논리형 연산자(logical operator) Table 2.3: R언어의 논리형 연산자 논리형 연산자 설명 &amp; AND (vectorized) &amp;&amp; AND (atomic) 비교 연산자를 적용할 경우 논리값을 반환 Table 2.4: R언어의 비교 연산자 비교 연산자 설명 &gt; 크다(greater-than) &lt; 작다(less-than) == 같다(equal) &gt;= 크거나 같다(greater than equal) &lt;= 작거나 같다(less than equal) != 같지 않다(not equal) Note: 기술한 비교 연산자는 수치형 및 논리형 데이터 타입 모두에 적용 가능 하지만, 문자형은 비교 연산은 ==, != 만 가능함 참고 논리형 스칼라도 숫자형 연산 가능 \\(\\rightarrow\\) 컴퓨터는 TRUE/FALSE를 1과 0 숫자로 인식 수치 연산자는 스칼라 뿐 아니라 아래에서 다룰 벡터, 행렬, 리스트, 데이터프레임 객체의 연산에 사용 가능 &amp;/|와 &amp;&amp;/||는 동일하게 AND/OR를 의미하지만 연산 결과가 다름. &amp;의 연산 대상이 벡터인 경우 백터 구성 값 각각에 대해 &amp; 연산을 실행 하지만 &amp;&amp;는 하나의 값(스칼라)에만 논리 연산이 적용(아래 예시 참고) 논리형 스칼라의 논리 및 비교 연산 예시 typeof(TRUE) # TRUE의 데이터 타입 [1] &quot;logical&quot; TRUE &amp; TRUE # TRUE 반환 [1] TRUE TRUE &amp; FALSE # FALSE 반환 [1] FALSE # 아래 연산은 모두 TRUE 반환 TRUE | TRUE [1] TRUE TRUE | FALSE [1] TRUE # TRUE와 FALSE의 반대 !TRUE [1] FALSE !FALSE [1] TRUE # 전역변수 T에 FALSE 값 할당 T &lt;- FALSE T [1] FALSE T &lt;- TRUE # 원상복귀 # TRUE/FALSE에 값을 할당할 수 없음 TRUE &lt;- 1 Error in TRUE &lt;- 1: 대입에 유효하지 않은 (do_set) 좌변입니다 TRUE &lt;- FALSE Error in TRUE &lt;- FALSE: 대입에 유효하지 않은 (do_set) 좌변입니다 # &amp;(|)와 &amp;&amp;(||)의 차이 l.01 &lt;- c(TRUE, TRUE, FALSE, TRUE) # 논리형 값으로 구성된 벡터 l.02 &lt;- c(FALSE, TRUE, TRUE, TRUE) l.01 &amp; l.02 # l.01과 l.02 각 원소 별 &amp; 연산 [1] FALSE TRUE FALSE TRUE l.01 &amp;&amp; l.02 # l.01과 l.02의 첫 번째 원소에 대해 &amp; 연산 [1] FALSE # 비교 연산자 x &lt;- 9 y &lt;- 4 # x &gt; y 의 반환값 데이터 타입 typeof(x &gt; y) [1] &quot;logical&quot; # 논리형 값 반환 x &gt; y [1] TRUE x &lt; y [1] FALSE x == y [1] FALSE x != y [1] TRUE 2.2.5 결측값(missing value) 결측치 지정 상수: NA \\(\\rightarrow\\) R과 다른 언어의 가장 큰 차이점 중 하나 예를 들어 4명의 통계학과 학생 중 3명의 통계학 개론 중간고사 점수가 각각 80, 90, 75점이고 4번 째 학생의 점수가 없는 경우 NA로 결측값 표현 is.na() 함수를 이용해 해당 값이 결측을 포함하고 있는지 확인 one &lt;- 80; two &lt;- 90; three &lt;- 75; four &lt;- NA four [1] NA # &#39;is.na()&#39; 결측 NA가 포함되어 있으면 TRUE is.na(four) [1] TRUE is.na(object_name): 객체를 구성하고 있는 원소 중 NA를 포함하고 있는지 확인 \\(\\rightarrow\\) NA를 포함하면 TRUE, 아니면 FALSE 반환 참고: 자료에 NA가 포함된 경우 연산 결과는 모두 NA가 반환 NA + 1 [1] NA NA &amp; TRUE [1] NA NA &lt;= 3 [1] NA 2.2.6 NULL 값 NULL: 초기화 되지 않은 변수 또는 객체를 지칭함 is.null() 함수를 통해 객체가 NULL인지 판단 x &lt;- NULL # NULL 지정 is.null(x) # NULL 객체인지 판단 [1] TRUE x &lt;- 1 is.null(x) [1] FALSE NA와 NULL의 차이점: 자료의 공백을 의미한다는 점에서 유사한 측면이 있으나 아래 내용처럼 큰 차이가 있음 NULL: 값을 지정하지 않은 객체를 표현하는데 사용. 즉 아직 변수 또는 객체의 상태가 아직 미정인 상태를 나타냄 NA: 데이터 값이 결측임을 지정해주는 논리형 상수 # NA와 NULL은 다름 x &lt;- NA is.null(NA) [1] FALSE is.na(NULL) logical(0) 2.2.7 무한대/무한소/숫자아님 Inf: 무한대(\\(+\\infty\\), \\(1/0\\)) -Inf: 무한소(\\(-\\infty\\), \\(-1/0\\)) NaN: 숫자아님(Not a Number, \\(0/0\\)) is.finite(), is.infinite(), is.nan() 함수를 통해 객체가 Inf 또는 NaN을 포함하는지 확인 x &lt;- Inf is.finite(x) [1] FALSE is.infinite(x) [1] TRUE x &lt;- 0/0 is.nan(x) [1] TRUE is.infinite(x) [1] FALSE 지금까지 요인형(factor)을 제외하고 R 언어에서 객체가 가질 수 있는 데이터 유형에 대해 알아봄. 요인형은 4주 차에 예정된 “R 자료형: 팩터, 테이블, 데이터 프레임”에서 상세하게 배울 예정임. "],["vector.html", "2.3 벡터(vector)", " 2.3 벡터(vector) 2.3.1 벡터의 특징 타 프로그래밍 언어의 배열(array)의 개념으로 동일한 유형의 데이터 원소가 하나 이상(\\(n \\times 1\\), \\(n \\geq 1\\)) 으로 구성된 자료 형태 R 언어의 가장 기본적인 데이터 형태로 R에서 행해지는 모든 연산의 기본(vectorization) \\(\\rightarrow\\) 벡터 연산 시 반복구문(예: for loop)이 필요 없음. 2.2 절에서 기술한 스칼라(scalar)는 사실 \\(1 \\times 1\\) 벡터임 수학적으로 벡터는 아래와 같이 나타낼 수 있음 \\[\\mathrm{\\mathbf x} = [x_1, x_2, x_3, \\ldots, x_n]^T \\] 벡터는 앞의 예시에서 본 바와 같이 c() 함수를 사용해 생성 # 숫자형 벡터 x &lt;- c(2, 0, 2, 0, 0, 3, 2, 4) x [1] 2 0 2 0 0 3 2 4 # 문자형 벡터 y &lt;- c(&quot;Boncho Ku&quot;, &quot;R programming&quot;, &quot;Male&quot;, &quot;sophomore&quot;, &quot;2020-03-24&quot;) y [1] &quot;Boncho Ku&quot; &quot;R programming&quot; &quot;Male&quot; &quot;sophomore&quot; [5] &quot;2020-03-24&quot; 두 개 이상의 벡터는 c() 함수를 통해 결합 가능 함수 내 , 구분자를 통해 결합 # 두 벡터의 결합 (1) x &lt;- 1:5 y &lt;- 10:6 z &lt;- c(x, y) x [1] 1 2 3 4 5 y [1] 10 9 8 7 6 z [1] 1 2 3 4 5 10 9 8 7 6 x &lt;- 5:10 x1 &lt;- x[1:3] # x 벡터에서 1에서 4번째 원소 추출 x2 &lt;- c(x1, 15, x[4]) x2 [1] 5 6 7 15 8 서로 다른 자료형으로 벡터를 구성한 경우 표현력이 높은 자료형으로 변환한 값 반환 예: 문자열 + 숫자로 구성된 벡터 \\(\\rightarrow\\) 문자형 벡터 변환규칙: NULL &lt; raw &lt; logical &lt; integer &lt; double &lt; complex &lt; character &lt; list &lt; expression # 숫자형 벡터와 문자열 벡터 혼용 k &lt;- c(1, 2, &quot;3&quot;, &quot;4&quot;) k [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; is.numeric(k) # 벡터가 숫자형인지 판단하는 함수 [1] FALSE is.character(k) # 벡터가 문자열인지 판단하는 함수 [1] TRUE # 숫자형 벡터와 문자열 벡터 결합 x &lt;- 1:3 y &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) z &lt;- c(x, y) z [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; is.numeric(z) [1] FALSE is.character(z) [1] TRUE # 숫자형 벡터와 논리형 벡터 결합 x &lt;- 9:4 y &lt;- c(TRUE, TRUE, FALSE) z &lt;- c(x, y) z # TRUE/FALSE 가 1과 0으로 변환 [1] 9 8 7 6 5 4 1 1 0 is.numeric(z) [1] TRUE is.logical(z) [1] FALSE 두 벡터는 중첩이 불가능 \\(\\rightarrow\\) 동일한 벡터 2개를 결합 시 단일 차원 벡터 생성 x &lt;- y &lt;- 1:3 # x와 y 동시에 [1, 2, 3] 할당 x [1] 1 2 3 y [1] 1 2 3 z &lt;- c(x, y) z [1] 1 2 3 1 2 3 벡터 각 원소에 이름 부여 가능 names() 함수를 이용해 원소 이름 지정 사용 프로토타입: names(x) &lt;- 문자열 벡터, 단 x와 이름에 입력할 문자열 벡터의 길이는 같아야 함. c() 함수에서 직접 이름 지정 \\(\\rightarrow\\) c(atom_name1 = value, atom_name2 = value, ...) x &lt;- c(&quot;Boncho Ku&quot;, &quot;R programming&quot;, &quot;Male&quot;, &quot;sophomore&quot;, &quot;2020-03-24&quot;) # 벡터 원소 이름 지정 names(x) &lt;- c(&quot;name&quot;, &quot;course&quot;, &quot;gender&quot;, &quot;grade&quot;, &quot;date&quot;) x name course gender grade date &quot;Boncho Ku&quot; &quot;R programming&quot; &quot;Male&quot; &quot;sophomore&quot; &quot;2020-03-24&quot; y &lt;- c(a = 10, b = 6, c = 9) names(y) [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 벡터의 길이(차원) 확인 length() 또는 NROW() 사용 x &lt;- 1:50 # 객체의 길이 반환 # length(): 벡터, 행렬인 경우 원소의 개수, 데이터프레임인 경우 열의 개수 반환 length(x) [1] 50 # NROW(): 벡터인 경우 원소의 개수, 행렬, 데이터 프레임인 경우 행의 개수 반환 NROW(x) [1] 50 2.3.2 벡터의 연산 원소 단위 사칙연산 및 비교연산 수행 \\(\\rightarrow\\) 벡터화 연산(vectorized operation) 예를 들어 \\(\\mathrm{\\mathbf x} = [1, 2, 3]^T\\) 이고, \\(\\mathrm{\\mathbf y} = [2, 3, 4]^T\\) 라고 할 때 \\(\\mathrm{\\mathbf x} + \\mathrm{\\mathbf y}\\)의 연산은 아래와 같음 \\[\\begin{bmatrix} 1 \\\\ 2\\\\ 3 \\end{bmatrix} + \\begin{bmatrix} 2 \\\\ 3\\\\ 4 \\end{bmatrix} = \\begin{bmatrix} 3 \\\\ 5 \\\\ 7 \\end{bmatrix} \\] * 연산 시 행렬 대수학에서 벡터의 곱(product)과 다름을 주의 \\[\\begin{bmatrix} 1 \\\\ 2\\\\ 3 \\end{bmatrix} * \\begin{bmatrix} 2 \\\\ 3\\\\ 4 \\end{bmatrix} = \\begin{bmatrix} 2 \\\\ 6 \\\\ 12 \\end{bmatrix} \\] x &lt;- 1:3; y &lt;- 2:4 length(x); length(y) [1] 3 [1] 3 x; y [1] 1 2 3 [1] 2 3 4 # 사칙연산(+, -, *, /) # 백터 vs. 백터 x + y [1] 3 5 7 x - y [1] -1 -1 -1 x * y [1] 2 6 12 x / y [1] 0.5000000 0.6666667 0.7500000 # 그외 연산 # 나머지(remainder) y %% x [1] 0 1 1 # 몫(quotient) y %/% x [1] 2 1 1 # 멱승(exponent) y ^ x [1] 2 9 64 차원이 서로 맞지 않는 경우 작은 차원(짧은 쪽)의 백터를 재사용함 \\[\\begin{bmatrix} 1 \\\\ 2\\\\ 3 \\end{bmatrix} + [5] = \\begin{bmatrix} 1 \\\\ 2\\\\ 3 \\end{bmatrix} + \\begin{bmatrix} 5 \\\\ 5\\\\ 5 \\end{bmatrix} = \\begin{bmatrix} 6 \\\\ 7 \\\\ 8 \\end{bmatrix} \\] # 벡터(n by 1) vs. 스칼라(1 by 1) x * 5 # 5을 x의 길이 만큼 재사용(반복) 후 곱 연산 수행 [1] 5 10 15 x &lt;- c(2, 1, 3, 5, 4); y &lt;- c(2, 3, 4) x [1] 2 1 3 5 4 y [1] 2 3 4 length(x); length(y) [1] 5 [1] 3 # x의 길이가 5이고 y의 길이가 3이기 때문에 5를 맞추기 위헤 # y의 원소 중 1-2 번째 원소를 재사용 x + y Warning in x + y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 [1] 4 4 7 7 7 x / y Warning in x/y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 [1] 1.0000000 0.3333333 0.7500000 2.5000000 1.3333333 연산 순서는 일반적인 사칙연산의 순서를 준용 단 1단위 수열을 생성하는 : 연산자가 사칙연산을 우선함 # 연산 우선 순위 1:5 * 3 [1] 3 6 9 12 15 1:(5 * 3) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 논리형 값으로 구성된 벡터의 기본 연산 시 수치형으로 변환된 연산 결과를 반환 # 논리형 벡터 b1 &lt;- c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE) b2 &lt;- c(FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE) is.numeric(b1); is.numeric(b2) [1] FALSE [1] FALSE is.logical(b1); is.logical(b2) [1] TRUE [1] TRUE # 논리형 벡터 연산 b3 &lt;- b1 + b2 is.numeric(b3) [1] TRUE b3 [1] 1 2 1 2 2 2 0 1 b1 - b2 [1] 1 0 -1 0 0 0 0 -1 b1 * b2 [1] 0 1 0 1 1 1 0 0 b1/b2 [1] Inf 1 0 1 1 1 NaN 0 두 벡터 간 비교 연산은 사칙연산과 마찬가지로 각 원소단위 연산을 수행하고 논리형 벡터 반환 재사용 규칙은 그대로 적용됨 # 두 벡터의 비교 연산 x &lt;- c(2, 4, 3, 10, 5, 9) y &lt;- c(3, 4, 6, 2, 10, 7) x == y [1] FALSE TRUE FALSE FALSE FALSE FALSE x != y [1] TRUE FALSE TRUE TRUE TRUE TRUE x &gt; y [1] FALSE FALSE FALSE TRUE FALSE TRUE x &lt; y [1] TRUE FALSE TRUE FALSE TRUE FALSE x &gt;= y [1] FALSE TRUE FALSE TRUE FALSE TRUE x &lt;= y [1] TRUE TRUE TRUE FALSE TRUE FALSE # 비교 연산 시 두 벡터의 길이가 다른 경우 x &lt;- 1:5; y &lt;- 2:4 x == y Warning in x == y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 [1] FALSE FALSE FALSE FALSE FALSE x != y Warning in x != y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 [1] TRUE TRUE TRUE TRUE TRUE x &gt; y Warning in x &gt; y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 [1] FALSE FALSE FALSE TRUE TRUE x &lt; y Warning in x &lt; y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 [1] TRUE TRUE TRUE FALSE FALSE x &gt;= y Warning in x &gt;= y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 [1] FALSE FALSE FALSE TRUE TRUE x &lt;= y Warning in x &lt;= y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 [1] TRUE TRUE TRUE FALSE FALSE 문자열 벡터의 연산은 == 또는 != 만 가능(사칙연산 불가능) # 문자열 벡터 연산 (==, !=) c1 &lt;- letters[1:5] # a-z로 구성된 벡터에서 1-2, 6-8 번째 원소 추출 c2 &lt;- letters[c(1:2, 6:8)] c1 [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; c2 [1] &quot;a&quot; &quot;b&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; c1 == c2 [1] TRUE TRUE FALSE FALSE FALSE c1 != c2 [1] FALSE FALSE TRUE TRUE TRUE NA를 포함한 두 벡터 연산 시 동일 위치에 NA가 존재하면 어떤 연산이든 NA 값을 반환 # 결측을 포함한 벡터 x &lt;- c(1:10, c(NA, NA)) y &lt;- c(NA, NA, 1:10) x [1] 1 2 3 4 5 6 7 8 9 10 NA NA y [1] NA NA 1 2 3 4 5 6 7 8 9 10 is.na(x); is.na(y) [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE [1] TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE # 결측을 포함한 벡터의 연산 x + y [1] NA NA 4 6 8 10 12 14 16 18 NA NA x / y [1] NA NA 3.000000 2.000000 1.666667 1.500000 1.400000 1.333333 [9] 1.285714 1.250000 NA NA x &lt; y [1] NA NA FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE NA NA x &gt; y [1] NA NA TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE NA NA NULL이 벡터에 포함되더라도 벡터의 길이에는 변동이 없음 # NULL을 포함한 벡터 x &lt;- c(1, 2, 3, NULL, NULL, NULL) # 길이가 6? length(x) [1] 3 x [1] 1 2 3 2.3.3 벡터의 색인(indexing) 벡터의 특정 위치에 있는 원소를 추출 색인(indexing)을 통해 벡터의 원소에 접근 가능 타 언어는 대체로 첫 번째 색인이 0에서 시작하지만, R은 1부터 시작 x[i]: 벡터 x의 i번 째 요소 x[start:end]: x의 start부터 end까지 값 반환 x &lt;- c(1.2, 3.1, 4.2, 2.8, 3.3) x[3] # x 원소 중 3 번째 원소 추출 [1] 4.2 # x 원소 중 2-3번째 원소 추출 x[2:3] [1] 3.1 4.2 x[-i]: 벡터 x에서 i번 째 요소를 제외한 나머지 값 반환 # x의 3 번째 원소 제거 x[-3] [1] 1.2 3.1 2.8 3.3 # 맨 마지막 원소(5 번째) 제거 # 아래 script는 동일한 결과 출력 x[1:(length(x) - 1)] [1] 1.2 3.1 4.2 2.8 x[-length(x)] [1] 1.2 3.1 4.2 2.8 x[idx_vec]: idx_vec가 인덱싱 벡터라고 할 때 idx_vec에 지정된 요소를 얻어옴. 일반적으로 idx_vec는 백터의 행 순서 번호 또는 각 벡터 원소의 이름에 대응하는 문자열 벡터를 인덱싱 벡터로 사용할 수 있음. # 벡터를 이용한 인덱싱 # x 원소 중 1, 5번째 원소 추출 x[c(1, 5)] # c(1,5)는 벡터 [1] 1.2 3.3 v &lt;- c(1, 4) x[v] [1] 1.2 2.8 # 인덱스 번호 중복 가능 x[c(1, 2, 2, 4)] [1] 1.2 3.1 3.1 2.8 # 원소 이름으로 인덱싱 # 원소 이름 지정 names(x) &lt;- paste0(&quot;x&quot;, 1:length(x)) # 문자열 &quot;x&quot;와 숫자 1:5(벡터 길이)를 결합한 문자열 반환 x[&quot;x3&quot;] x3 4.2 x[c(&quot;x2&quot;, &quot;x4&quot;)] x2 x4 3.1 2.8 필터링(filtering): 특정한 조건을 만족하는 원소 추출 비교 연산자를 이용한 조건 생성 \\(\\rightarrow\\) 논리값을 이용한 원소 추출 z &lt;- c(5, 2, -3, 8) # z의 원소 중 z의 제곱이 8보다 큰 원소 추출 w &lt;- z[z^2 &gt; 8] w [1] 5 -3 8 작동 원리 z^2 &gt; 8은 벡터 z의 모든 원소 제곱값이 8 보다 큰 케이스를 논리형 값으로 반환 z^2 [1] 25 4 9 64 idx &lt;- z^2 &gt; 8 idx [1] TRUE FALSE TRUE TRUE z[idx] [1] 5 -3 8 특정 조건을 만족하는 벡터의 위치에 임의의 값을 치환할 수 있음 # 위 벡터 z 의 원소 중 z^2 &gt; 8 인 원소의 값을 0으로 치환 z[idx] &lt;- 0 2.3.4 벡터 관련 함수 c() 함수 외에 R은 벡터 생성을 위해 몇 가지 유용한 함수를 제공함 seq 계열 함수 보다 자세한 사용 설명은 help(seq) 참고 seq(): 등차 수열 생성하는 함수로 from에서 end 까지 숫자 내에서 공차(간격)가 by 인 수열 생성 # seq(): 수열 생성 함수 seq( from, # 시작값 to, # 끝값 by # 공차(증가치) ) # 기타 인수 # length.out = n # - 생성하고자 하는 벡터의 길이가 n인 수열 생성 # along.with = 1:n # - index가 1에서 n 까지 길이를 갖는 수열 생성 사용 예시 x &lt;- seq(from = 2, to = 30, by = 2) x [1] 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 # 간격이 꼭 정수가 아니어도 사용 가능 x &lt;- seq(from = 0, to = 3, by = 0.2) # by 대신 length.out 으로 생성된 수열의 길이 조정 x &lt;- seq(from = -3, to = 3, length.out = 10) x [1] -3.0000000 -2.3333333 -1.6666667 -1.0000000 -0.3333333 0.3333333 [7] 1.0000000 1.6666667 2.3333333 3.0000000 # from, to 인수 없이 length.out=10 인 경우 seq(length.out = 10) [1] 1 2 3 4 5 6 7 8 9 10 # by 대신 along.width seq(along.with=1:10) [1] 1 2 3 4 5 6 7 8 9 10 seq(1, 5, along.with=1:10) [1] 1.000000 1.444444 1.888889 2.333333 2.777778 3.222222 3.666667 4.111111 [9] 4.555556 5.000000 # 벡터 x에 seq() 함수 적용 시 1:length(x) 값 반환 seq(x) [1] 1 2 3 4 5 6 7 8 9 10 seq_along(): 주어진 객체의 길이 만큼 1부터 1 간격의 수열 생성 seq() 함수와 매우 유사하나, 무조건 1부터 시작해서 인수로 seq()의 along.with 값을 이용한 함수 seq() 함수보다 조금 빠름 사용 예시 # 1부터 x 벡터의 길이 까지 1 단위 수열 값 반환 seq_along(x) [1] 1 2 3 4 5 6 7 8 9 10 seq_len(): 인수로 받은 값 만큼 1부터 해당 값 까지 1 간격의 수열 생성 seq() 함수의 인수 중 length.out 값을 이용한 함수 사용 예시 # 1부터 n 까지 1 단위 수열 값 반환 seq_len(10) [1] 1 2 3 4 5 6 7 8 9 10 rep 계열 함수 help(rep)을 통해 상세 내용 참고 rep(): 주어진 벡터의 원소를 반복 # rep(): 벡터 또는 벡터의 개별 원소를 반복한 값 반환 rep( x, # 반복할 값이 저장된 벡터 times, # 전체 벡터의 반복 횟수 each # 개별 원소의 반복 횟수 ) 사용 예시 x &lt;- rep(4, 5) # 4를 5번 반복 x [1] 4 4 4 4 4 # x &lt;- c(1:3) 전체를 3번 반복한 벡터 반환 x &lt;- c(1:3) xr1 &lt;- rep(x, times = 3) xr1 [1] 1 2 3 1 2 3 1 2 3 # 벡터 x 의 각 원소를 4번씩 반복한 벡터 반환 xr2 &lt;- rep(x, each = 4) xr2 [1] 1 1 1 1 2 2 2 2 3 3 3 3 # 벡터 x 의 각 원소를 3번 반복하고 해당 벡터를 2회 반복 xr3 &lt;- rep(x, each = 3, times = 2) xr3 [1] 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 # 문자형 벡터의 반복 # 아래 sex 벡터의 각 원소를 2 번 반복하고 해당 벡터를 4회 반복 sex &lt;- c(&quot;Male&quot;, &quot;Female&quot;) sexr &lt;- rep(sex, each = 2, times = 4) sexr [1] &quot;Male&quot; &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; [9] &quot;Male&quot; &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; rep.int() &amp; rep_len(): rep() 함수의 simple 버전으로 속도(performance)가 요구되는 프로그래밍 시 사용 사용 예시 # 1:5 벡터를 3 번 반복 rep.int(1:5, 3) [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 # 불완전한 사이클로 벡터 반복 rep_len(1:5, length.out = 7) [1] 1 2 3 4 5 1 2 Filtering 관련 함수 help(subset) 참고 subset(): 기존 필터링 방식과 비교할 때 NA를 처리하는 방식에서 차이를 보임 벡터 뿐 아니라 앞으로 배울 행렬 및 데이터프레임 객체에도 적용 가능 x &lt;- c(6, 1:3, NA, NA, 12) x [1] 6 1 2 3 NA NA 12 # 일반적 필터링 적용 x[x &gt; 5] [1] 6 NA NA 12 # subset() 함수 적용 subset(x, x &gt; 5) [1] 6 12 which(): 한 벡터에서 특정 조건에 맞는 위치(인덱스)를 반환 # which(): 논리형 벡터를 인수로 받고 해당 논리형 벡터가 참인 index 반환 which( logical_vec # 논리형 벡터 ) 사용 예시 x &lt;- c(3, 8, 3, 1, 7) # x의 원소값이 3인 index 반환 which(x == 3) [1] 1 3 # x의 원소가 4보다 큰 원소의 index 반환 which(x &gt; 4) [1] 2 5 # 9월(Sep)과 12월(Dec)와 같은 원소 index # month.abb: R 내장 벡터로 월 약어(Jan ~ Dec)를 저장한 문자열 벡터 which(month.abb == c(&quot;Sep&quot;, &quot;Dec&quot;)) [1] 9 12 # 조건을 만족하는 원소가 존재하지 않는다면? x &lt;- which(x &gt; 9) x integer(0) length(x) # 길이가 0인 벡터 반환 is.null(x) == TRUE ?? [1] 0 is.null(x) [1] FALSE # 특정 조건 만족 여부를 확인 # any(condition) -&gt; 하나라도 condition을 만족하는 원소가 존재하는지 판단 # TRUE 또는 FALSE 값 반환 any(x &gt; 9) [1] FALSE 집합 관련 함수 벡터는 숫자, 문자열의 묶음, 즉 원소들의 집합(set)으로 볼 수 있기 때문에 집합 연산이 가능 두 집합을 \\(X\\)와 \\(Y\\)로 정의 했을 때 아래와 같은 집합 연산 가능 setequal(X, Y): X와 Y가 동일한지 판단 (\\(X = Y\\)) \\(\\rightarrow\\) 논리값 TRUE 또는 FALSE 반환 x &lt;- y &lt;- c(1, 9, 7, 3, 6) setequal(x, y) [1] TRUE union(X, Y): X와 Y의 합집합 (\\(X \\cup Y\\)) y &lt;- c(1, 9, 8, 2, 0, 3) union(x, y) [1] 1 9 7 3 6 8 2 0 intersect(X, Y): X와 Y의 교집합 (\\(X \\cap Y\\)) intersect(x, y) [1] 1 9 3 setdiff(X, Y): X와 Y의 차집합 (\\(X - Y\\)) setdiff(x, y) [1] 7 6 setdiff(y, x) [1] 8 2 0 X %in% Y: X(기준)가 집합 Y의 원소인지 논리값 반환 x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;strawberry&quot;, &quot;mango&quot;, &quot;peach&quot;, &quot;orange&quot;) y &lt;- c(&quot;strawberry&quot;, &quot;orange&quot;, &quot;mango&quot;) x %in% y [1] FALSE FALSE TRUE TRUE FALSE TRUE y %in% x [1] TRUE TRUE TRUE 두 벡터의 동일성 테스트 두 벡터가 동일한지 테스트 하기 위해 x == y 연산의 반환 값은 위의 예제에서 확인한 것 처럼 각 원소에 대한 논리값을 반환(아래 예제 확인) x &lt;- 1:3 y &lt;- c(1, 3, 4) x == y [1] TRUE FALSE FALSE 단지 두 벡터가 동일한지 아닌지를 확인하기 위해서는 하나의 논리값만 필요한 경우 all() 사용 all(x == y) [1] FALSE 보다 나은 방법으로 identical() 함수 적용 # 두 객체의 동일성 여부 테스트 identical(x, y) [1] FALSE identical() 함수는 벡터가 갖는 데이터 타입의 동일성 까지 체크함 x &lt;- 1:5; y &lt;- c(1, 2, 3, 4, 5) x [1] 1 2 3 4 5 y [1] 1 2 3 4 5 # all() 함수로 동일성 확인 all(x == y) [1] TRUE # identical 함수로 동일성 확인 identical(x, y) [1] FALSE # x, y 데이터 타입 확인 typeof(x) [1] &quot;integer&quot; typeof(y) [1] &quot;double&quot; "],["list.html", "2.4 리스트(list)", " 2.4 리스트(list) 리스트(list): (key, value) 형태로 데이터를 저장한 배열(벡터) 서로 다른 데이터 타입을 가진 객체를 원소로 가질 수 있는 벡터 예: 한 리스트 안에는 상이한 데이터 타입(숫자형, 문자형, 논리형 등)을 갖는 원소(객체)들을 포함할 수 있음 리스트 예시: 통계프로그래밍언어 중간고사 성적 테이블 중간고사 성적 테이블은 이름, 학번, 출석률, 점수, 등급으로 이루어졌다고 가정하면 “김상자”의 성적 리스트는 다음과 같이 나타낼 수 있음 LIST(이름 = \"김상자\", 학번 = \"202015115\", 점수 = 95, 등급 = \"A-\") 위 record에서 보듯이 문자형과 숫자형이 LIST 안에 같이 표현되고 있음 위 record를 벡터 생성함수 c()로 생성한 경우 # 벡터로 위 record를 입력한 경우 vec &lt;- c(`이름` = &quot;김상자&quot;, `학번` = &quot;202015115&quot;, `점수` = 95, `등급` = &quot;A-&quot;) vec 이름 학번 점수 등급 &quot;김상자&quot; &quot;202015115&quot; &quot;95&quot; &quot;A-&quot; typeof(vec) [1] &quot;character&quot; 객체 명칭 규칙을 벗어나는 이름을 객제명으로 사용하고 싶다면 다음과 같이 홀따옴표 `object_name` 표시를 통해 사용 가능함 &gt; #공백이 있는 이름을 객체 명칭으로 사용 &gt; `golf score` &lt;- c(75, 82, 92) &gt; `golf score` [1] 75 82 92 &gt; `3x` &lt;- c(3, 6, 9, 12) &gt; `3x` [1] 3 6 9 12 2.4.1 리스트 생성 list() 함수를 사용해 list 객체 생성 # list 함수 사용 prototype list(name_1 = object_1, ..., name_m = object_m) # name_1, ..., name_m: 리스트 원소 이름 # object_1, ..., object_m: 리스트 원소에 대응한 객체 중간고사 성적 테이블 예시 # lst 객체 생성 lst &lt;- list(`이름` = &quot;김상자&quot;, `학번` = &quot;202015115&quot;, `점수` = 95, `등급` = &quot;A-&quot;) lst $이름 [1] &quot;김상자&quot; $학번 [1] &quot;202015115&quot; $점수 [1] 95 $등급 [1] &quot;A-&quot; # lst 내 객체의 데이터 타입 확인 # lapply(): lst 객체에 동일한 함수 적용 (추후 학습) lapply(lst, typeof) $이름 [1] &quot;character&quot; $학번 [1] &quot;character&quot; $점수 [1] &quot;double&quot; $등급 [1] &quot;character&quot; 리스트 원소에 이름이 부여된 경우 names()를 통해 확인 가능 names(lst) [1] &quot;이름&quot; &quot;학번&quot; &quot;점수&quot; &quot;등급&quot; 이름(name_1, .., name_n) 없이도 리스트 생성 가능하나, 가급적 이름을 부여 하는 것이 더 명확 list(&quot;김상자&quot;, &quot;202015115&quot;, 95, &quot;A-&quot;) [[1]] [1] &quot;김상자&quot; [[2]] [1] &quot;202015115&quot; [[3]] [1] 95 [[4]] [1] &quot;A-&quot; 리스트는 벡터이므로 vector() 함수를 통해 생성 가능 # 길이가 1이고 객체가 NULL인 리스트 생성 z &lt;- vector(mode = &quot;list&quot;, length=1) z [[1]] NULL 리스트의 값이 어떤 객체든 관계 없음 x &lt;- list(name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), salary = c(500, 450, 600), union = T) x $name [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; $salary [1] 500 450 600 $union [1] TRUE 2.4.2 리스트 색인 리스트에 포함된 객체에 접근는 기본적으로 벡터의 색인 방법과 동일하게 색인 번호 또는 키(이름)을 통해 접근 가능 리스트에 포함된 모든 객체의 원소값을 쉽게 확인하는 함수는 unlist()임 lval &lt;- unlist(x) typeof(lval) [1] &quot;character&quot; Table 2.5: 리스트 데이터 접근 방법 색인방법 동작 x$name 리스트 x 에서 객체명(name)에 해당하는 객체에 접근 x[[i]] 또는 x[[name]] 리스트 x 에서 i 번째 또는 name에 해당하는 객체 반환 x[i] 또는 x[name] 리스트 x 에서 i 번째 또는 name에 해당하는 부분 리스트 반환 x$name을 통해 리스트 내 객체 접근 lst$`학번` [1] &quot;202015115&quot; x[[i]] 또는 x[[name]] 을 통해 리스트 내 객체 접근 lst[[2]] [1] &quot;202015115&quot; z &lt;- lst[[&quot;학번&quot;]] z [1] &quot;202015115&quot; typeof(z) [1] &quot;character&quot; x[i] 또는 x[name] 을 통해 리스트 내 부분 리스트 추출 lst[2] $학번 [1] &quot;202015115&quot; j &lt;- lst[&quot;학번&quot;] j $학번 [1] &quot;202015115&quot; typeof(j) [1] &quot;list&quot; 리스트 또한 벡터로 볼 수 있기 때문에 여러 개의 부분 리스트 추출 가능 # 리스트 lst 에서 1 ~ 3 번째 까지 부분 리스트 추출 lst[1:3] $이름 [1] &quot;김상자&quot; $학번 [1] &quot;202015115&quot; $점수 [1] 95 리스트를 구성하는 객체 내 색인 x $name [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; $salary [1] 500 450 600 $union [1] TRUE # salary에서 2-3번째 원소 추출 x$salary[2:3] [1] 450 600 x[[2]][2:3] [1] 450 600 x[[&quot;salary&quot;]][2:3] [1] 450 600 # 부분 리스트도 길이가 1인 리스트이므로, # 부분 리스트 내 객제 접근 시 리스트 접근이 선행 # x의 2번째 부분 리스트에서 첫 번째 객체의 2-3번째 원소 추출 x[2][[1]][2:3] [1] 450 600 리스트의 길이 반환: 벡터와 마찬가지로 length() 함수 적용 가능 length(lst); length(x) [1] 4 [1] 3 2.4.3 리스트에 원소 추가/제거 주어진 리스트 x에 새로운 원소를 x$new_obj &lt;- value 명령어 형태로 추가 이미 존재하고 있는 리스트 원소 제거는 x$exist_obj &lt;- NULL 형태로 제거 # 리스트 lst 에 5회 차 퀴즈 점수 추가 lst$quiz &lt;- c(10, 8, 9, 9, 8) # 리스트 lst이 원소 quiz 제거 lst$quiz &lt;- NULL lst $이름 [1] &quot;김상자&quot; $학번 [1] &quot;202015115&quot; $점수 [1] 95 $등급 [1] &quot;A-&quot; # 벡터 색인을 이용해 원소 추가 가능 lst[[5]] &lt;- c(10, 8, 9, 9, 8) lst $이름 [1] &quot;김상자&quot; $학번 [1] &quot;202015115&quot; $점수 [1] 95 $등급 [1] &quot;A-&quot; [[5]] [1] 10 8 9 9 8 # 부분 리스트 괄호에서도 색인 통해 추가/삭제 가능 lst[5] &lt;- NULL lst $이름 [1] &quot;김상자&quot; $학번 [1] &quot;202015115&quot; $점수 [1] 95 $등급 [1] &quot;A-&quot; # 여러 개의 리스트 동시 추가/삭제 가능 lst[5:9] &lt;- c(10, 8, 9, 9, 8) lst $이름 [1] &quot;김상자&quot; $학번 [1] &quot;202015115&quot; $점수 [1] 95 $등급 [1] &quot;A-&quot; [[5]] [1] 10 [[6]] [1] 8 [[7]] [1] 9 [[8]] [1] 9 [[9]] [1] 8 lst[5:9] &lt;- NULL lst $이름 [1] &quot;김상자&quot; $학번 [1] &quot;202015115&quot; $점수 [1] 95 $등급 [1] &quot;A-&quot; 2.4.4 리스트의 결합 두 개 이상의 리스트를 결합 시 c() 사용 # 리스트 lst와 x 결합 c(lst, x) $이름 [1] &quot;김상자&quot; $학번 [1] &quot;202015115&quot; $점수 [1] 95 $등급 [1] &quot;A-&quot; $name [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; $salary [1] 500 450 600 $union [1] TRUE 리스트 내에 리스트를 가질 수 있다. 이를 재귀 리스트(recursive list)라고 한다. 예를 들어 위 예제에서 각 학생의 성적 데이터가 리스트로 구성되어 있다면, 전체 성적 데이터베이스는 리스트로 구성된 리스트임. 아래 예제 처럼 간단한 재귀 리스트 구현이 가능 kim &lt;- list(id = &quot;20153345&quot;, sex = &quot;Male&quot;, score = 85, grade = &quot;B+&quot;) lee &lt;- list(id = &quot;20153348&quot;, sex = &quot;Female&quot;, score = 75, grade = &quot;B0&quot;) gr &lt;- list(kim=kim, lee=lee) gr $kim $kim$id [1] &quot;20153345&quot; $kim$sex [1] &quot;Male&quot; $kim$score [1] 85 $kim$grade [1] &quot;B+&quot; $lee $lee$id [1] &quot;20153348&quot; $lee$sex [1] &quot;Female&quot; $lee$score [1] 75 $lee$grade [1] &quot;B0&quot; "],["matrix.html", "2.5 행렬(matrix)", " 2.5 행렬(matrix) 학습목표(3 주차): 행렬, 배열, 요인형과 테이블에 대해 살펴보고, 이들 객체에 대한 연산과 연관된 함수에 대해 익힌다. 행렬의 정의 동일한 데이터 타입의 원소로 구성된 2차원 데이터 구조 \\(n \\times 1\\) 차원 벡터 \\(p\\)개로 묶여진 데이터 덩어리 \\(\\rightarrow\\) \\(n \\times p\\) 행렬로 명칭함 행렬의 형태 \\[\\begin{bmatrix} x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1p} \\\\ x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2p} \\\\ \\vdots &amp; \\vdots &amp; \\cdots &amp; \\vdots \\\\ x_{n1} &amp; x_{n2} &amp; \\cdots &amp; x_{np} \\end{bmatrix} \\] R에서 행렬은 동일한 유형의 데이터 타입으로 구성 가능 \\(\\rightarrow\\) 첫 번째 행은 숫자형, 두 번째 행은 문자열로 입력해도 행렬을 만들 수 있지만, 표현력이 더 높은 문자형 행렬 반환 행렬의 내부 저장공간은 “열 우선 배열” 행렬 생성을 위한 R 함수는 matrix() 함수이고 사용 형태는 아래와 같음 # matrix(): 행렬 생성 함수 # 상세 내용은 help(matrix)를 통해 확인 matrix(data, # 행렬을 생성할 데이터 벡터 nrow, # 행의 개수 (정수) ncol, # 열의 개수 (정수) byrow, # TRUE: 행 우선, FALSE: 열 우선 # default = FALSE dimnames # 행렬읠 각 차원에 부여할 이름 (리스트) ) 행렬 생성 예시 # byrow = FALSE x &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3) x [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 # byrow = TRUE x &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3, byrow = T) x [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 [3,] 7 8 9 행의 개수(nrow)나 열의 개수(ncol)로 나머지를 추정 가능하다면 둘 중 어떤 인수도 생략 가능 x &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol = 3) x [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 x &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3) x [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 nrow \\(\\times\\) ncol 이 입력한 데이터(벡터)의 길이보다 작거나 큰 경우 # length(x) &lt; nrow * ncol 인 경우 # nrow * ncol에 해당하는 길이 만큼 # x의 원소를 사용해 행렬 생성 x &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9) y &lt;- matrix(x, nrow = 3, ncol = 4) Warning in matrix(x, nrow = 3, ncol = 4): 데이터의 길이[9]가 열의 개수[4]의 배수 가 되지 않습니다 y [,1] [,2] [,3] [,4] [1,] 1 4 7 1 [2,] 2 5 8 2 [3,] 3 6 9 3 # length(x) &gt; nrow * ncol 인 경우 # x의 첫 번쨰 원소부터 초과하는 만큼 # x 원소의 값을 재사용 z &lt;- matrix(x, nrow = 2, ncol = 3) Warning in matrix(x, nrow = 2, ncol = 3): 데이터의 길이[9]가 행의 개수[2]의 배수 가 되지 않습니다 z [,1] [,2] [,3] [1,] 1 3 5 [2,] 2 4 6 행렬 구성 시 길이에 대한 약수가 아닌 값을 nrow 또는 ncol의 인수로 받은 경우 # x (length=9)로 행렬 생성 시 nrow=4 를 # 인수로 입력한 경우 h &lt;- matrix(x, nrow = 4) Warning in matrix(x, nrow = 4): 데이터의 길이[9]가 행의 개수[4]의 배수가 되지 않 습니다 h [,1] [,2] [,3] [1,] 1 5 9 [2,] 2 6 1 [3,] 3 7 2 [4,] 4 8 3 # x (length=9)로 행렬 생성 시 ncol=2 만 # 인수로 입력한 경우 h &lt;- matrix(x, nrow = 2) Warning in matrix(x, nrow = 2): 데이터의 길이[9]가 행의 개수[2]의 배수가 되지 않 습니다 h [,1] [,2] [,3] [,4] [,5] [1,] 1 3 5 7 9 [2,] 2 4 6 8 1 2.5.1 행렬의 연산 선형대수(linear algebra)에서 배우는 행렬-스칼라, 행렬-행렬 간 연산 가능 행렬-스칼라 연산 합 연산: 스칼라가 자동적으로 행렬의 차원에 맞춰서 재사용 \\[\\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix} + 4 = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix} + \\begin{bmatrix} 4 &amp; 4 &amp; 4 \\\\ 4 &amp; 4 &amp; 4 \\\\ 4 &amp; 4 &amp; 4 \\end{bmatrix} = \\begin{bmatrix} 5 &amp; 6 &amp; 7 \\\\ 8 &amp; 9 &amp; 10 \\\\ 11 &amp; 12 &amp; 13 \\end{bmatrix} \\] x &lt;-matrix(1:9, 3, 3, byrow = T) x + 4 [,1] [,2] [,3] [1,] 5 6 7 [2,] 8 9 10 [3,] 11 12 13 곱 연산 \\[\\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix} \\times 4 = \\begin{bmatrix} 4 &amp; 8 &amp; 12 \\\\ 16 &amp; 20 &amp; 24 \\\\ 28 &amp; 32 &amp; 36 \\end{bmatrix} \\] x*4 [,1] [,2] [,3] [1,] 4 8 12 [2,] 16 20 24 [3,] 28 32 36 행렬-행렬 연산 행렬 간 연산에서 스칼라 연산(일반 연산)과 다른 점은 차원이 개입 행렬 간 합(차) 두 행렬의 동일 차원 간 합 연산 수행(+ 또는 - 연산자 사용) \\[\\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix} + \\begin{bmatrix} 1 &amp; -1 &amp; ~~~2 \\\\ 3 &amp; ~~~2 &amp; ~~~4 \\\\ -6 &amp; ~~~3 &amp; -7 \\end{bmatrix} = \\begin{bmatrix} 2 &amp; 1 &amp; 5 \\\\ 7 &amp; 7 &amp; 10 \\\\ 1 &amp; 11 &amp; 2 \\end{bmatrix} \\] x &lt;- matrix(1:9, 3, 3, byrow = T) y &lt;- matrix(c(1, 3, -6, -1, 2, 3, 2, 4, -7), ncol = 3) x + y [,1] [,2] [,3] [1,] 2 1 5 [2,] 7 7 10 [3,] 1 11 2 행렬 곱/나누기(elementwise product/division) 연산자 * 또는 / 사용 \\[\\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix} * \\begin{bmatrix} ~~~1 &amp; -1 &amp; ~~~2 \\\\ ~~~3 &amp; ~~~2 &amp; ~~~4 \\\\ -6 &amp; ~~~3 &amp; -7 \\end{bmatrix} = \\begin{bmatrix} ~~~~~ 1 &amp; -2 &amp; ~~~~6 \\\\ ~~~ 12 &amp; ~10 &amp; ~~~24 \\\\ -42 &amp; ~24 &amp; -63 \\end{bmatrix} \\] x * y [,1] [,2] [,3] [1,] 1 -2 6 [2,] 12 10 24 [3,] -42 24 -63 행렬-행렬 합(차) 또는 곱(나누기) 연산 시 행렬의 열단위 원소가 재사용되지 않음 동일 차원 간 연산만 가능!! z &lt;- y[, 1:2] # y 행렬에서 1-2 번째 열 추출 z # 3 by 2 행렬 [,1] [,2] [1,] 1 -1 [2,] 3 2 [3,] -6 3 x + z Error in x + z: 배열의 크기가 올바르지 않습니다 x * z Error in x * z: 배열의 크기가 올바르지 않습니다 x / z Error in x/z: 배열의 크기가 올바르지 않습니다 행렬 간 곱(matrix product) 두 행렬 \\(\\mathrm{\\mathbf X}_{n\\times m}\\), \\(\\mathrm{\\mathbf Y}_{m\\times k}\\) 이 주어졌을 때 두 행렬의 곱(matrix product) \\(\\mathrm{\\mathbf Z} = \\mathrm{\\mathbf {X\\cdot Y}}\\)는 \\(n \\times k\\) 행렬이고 \\(\\mathrm{\\mathbf Z}\\) 원소 \\(z_{ij}\\) (\\(i={1,\\ldots,n}\\), \\(j={1,\\ldots,k}\\)) 아래와 같이 정의됨 \\[ z_{ij} = \\sum_{r=1}^{m}x_{ir}y_{rj},~~~~\\forall~\\{i, j\\} \\] - R에서 위와 같은 연산은 %*%를 사용 예시: 행렬 \\(\\mathrm{\\mathbf X}_{2\\times 4}\\), \\(\\mathrm{\\mathbf Y}_{4\\times 3}\\) 이 아래와 같이 주어졌을 때 두 행렬의 곱 \\(\\mathrm{\\mathbf Z}_{2\\times 3} = \\mathrm{\\mathbf{X}}_{2\\times 4}\\mathrm{\\mathbf{Y}}_{4 \\times 3}\\)는 아래와 같음 \\[ \\mathrm{\\mathbf X}= \\begin{bmatrix} 1 &amp;~~~ 1 &amp; -1 &amp; 1 \\\\ 1 &amp; -1 &amp;~~~ 1 &amp; 1 \\end{bmatrix}, ~~~~~ \\mathrm{\\mathbf{Y}}= \\begin{bmatrix} 1 &amp; -2 &amp; -1 \\\\ 1 &amp;~~~1 &amp;~~~2 \\\\ 1 &amp;~~~3 &amp;~~~1 \\\\ 1 &amp;~~~2 &amp;~~~2 \\end{bmatrix} \\] \\[ \\mathrm{\\mathbf{Z}} = \\mathrm{\\mathbf{X}}\\mathrm{\\mathbf{Y}} = \\begin{bmatrix} 1 &amp;~~~ 1 &amp; -1 &amp; 1 \\\\ 1 &amp; -1 &amp;~~~ 1 &amp; 1 \\\\ \\end{bmatrix} \\cdot \\begin{bmatrix} 1 &amp; -2 &amp; -1 \\\\ 1 &amp;~~~1 &amp;~~~2 \\\\ 1 &amp;~~~3 &amp;~~~1 \\\\ 1 &amp;~~~2 &amp;~~~2 \\end{bmatrix} = \\begin{bmatrix} 2 &amp; -2 &amp; 2 \\\\ 2 &amp;~~~2 &amp; 0 \\end{bmatrix} \\] X &lt;- matrix(c(1,1,1,-1,-1,1,1,1), nrow = 2, ncol = 4) Y &lt;- matrix(c(1,1,1,1, -2, 1, 3, 2, -1, 2, 1, 2), nrow = 4, ncol = 3) Z &lt;- X %*% Y Z [,1] [,2] [,3] [1,] 2 -2 2 [2,] 2 2 0 행렬-벡터 연산 행렬 \\(\\mathrm{\\mathbf{X}}\\)의 행 길이와 벡터 \\(\\mathrm{\\mathbf y}\\)의 길이가 같은 경우 \\(\\rightarrow\\) \\(\\mathrm{\\mathbf y}\\)를 열 단위로 재사용 \\[\\mathrm{\\mathbf{X}} = \\begin{bmatrix} 1 &amp; 2 &amp; 4\\\\ 1 &amp; 3 &amp; 2\\\\ 1 &amp; 2 &amp; 1 \\end{bmatrix}, ~~~~~ \\mathrm{\\mathbf y} = [20, 18, 23]^T \\] \\[\\mathrm{\\mathbf{X}} + \\mathrm{\\mathbf{y}} = \\begin{bmatrix} 1 &amp; 2 &amp; 4\\\\ 1 &amp; 3 &amp; 2\\\\ 1 &amp; 2 &amp; 1 \\end{bmatrix} + \\begin{bmatrix} 20 &amp; 20 &amp; 20\\\\ 18 &amp; 18 &amp; 18\\\\ 23 &amp; 23 &amp; 23 \\end{bmatrix} = \\begin{bmatrix} 21 &amp; 22 &amp; 24\\\\ 19 &amp; 21 &amp; 20\\\\ 24 &amp; 25 &amp; 24 \\end{bmatrix} \\] #행렬-벡터 합 연산 # X = 3 by 3 행렬; y = 3 by 1 벡터 x &lt;- c(1, 1, 1, 2, 3, 2, 4, 2, 1) X &lt;- matrix(x, nrow = 3) y &lt;- c(20, 18, 23)# 재사용 X + y [,1] [,2] [,3] [1,] 21 22 24 [2,] 19 21 20 [3,] 24 25 24 행렬 \\(\\mathrm{\\mathbf{X}}\\)의 길이와 벡터 \\(\\mathrm{\\mathbf y}\\)의 길이가 같은 경우 \\(\\rightarrow\\) 벡터 \\(\\mathrm{\\mathbf y}\\)를 자동으로 원소를 행렬(열단위)로 변환 \\[\\mathrm{\\mathbf{X}} = \\begin{bmatrix} 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6\\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix}, ~~~~~ \\mathrm{\\mathbf y} = [1, 2, \\ldots, 9]^T \\] \\[\\mathrm{\\mathbf{X}} + \\mathrm{\\mathbf{y}} = \\begin{bmatrix} 1 &amp; 4 &amp; 7\\\\ 2 &amp; 5 &amp; 8\\\\ 3 &amp; 6 &amp; 9 \\end{bmatrix} + \\begin{bmatrix} 1 &amp; 4 &amp; 7\\\\ 2 &amp; 5 &amp; 8\\\\ 3 &amp; 6 &amp; 9 \\end{bmatrix} = \\begin{bmatrix} 2 &amp; 8 &amp; 14\\\\ 4 &amp; 10 &amp; 16\\\\ 6 &amp; 12 &amp; 18 \\end{bmatrix} \\] #행렬-벡터 합 연산 # 행렬 X의 길이와 벡터 y의 길이가 같은 경우 x &lt;- c(1:9); X &lt;- matrix(x, nrow = 3) length(X); y &lt;- x [1] 9 X + y [,1] [,2] [,3] [1,] 2 8 14 [2,] 4 10 16 [3,] 6 12 18 # 길이가 다른 경우 # 1) 행렬 길이보다 큰 경우 y &lt;- c(1:10) X + y Warning in X + y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 Error in eval(expr, envir, enclos): dims [product 9]가 객체 [10]의 길이와 일치하지 않습니다 # 1) 행렬 길이의 약수가 아닌 경우 # y 재사용 y &lt;- c(1:4) X + y Warning in X + y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 [,1] [,2] [,3] [1,] 2 8 10 [2,] 4 6 12 [3,] 6 8 10 행렬-벡터 %*% 적용 시 벡터는 \\(n \\times 1\\) 행렬로 간주하고 행렬 곱 연산 수행(단 \\(\\mathrm{\\mathbf X}\\)와 벡터 \\(\\mathrm{\\mathbf y}\\)의 길이는 같아야 함). \\[\\mathrm{\\mathbf{X}}_{4\\times 3} = \\begin{bmatrix} 1 &amp; 2 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 3 &amp; 3 \\\\ 1 &amp; 4 &amp; 4 \\end{bmatrix}, ~~~~~ \\mathrm{\\mathbf y}_{3\\times 1} = [7, 6, 8]^T \\] \\[\\mathrm{\\mathbf{X}}\\mathrm{\\mathbf{y}} = \\begin{bmatrix} 1 &amp; 2 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 3 &amp; 3 \\\\ 1 &amp; 4 &amp; 4 \\end{bmatrix} \\cdot \\begin{bmatrix} 7 \\\\ 6 \\\\ 8 \\end{bmatrix} = \\begin{bmatrix} 27 \\\\ 21 \\\\ 49 \\\\ 63 \\end{bmatrix} \\] x &lt;- c(1, 1, 1, 1, 2, 1, 3, 4, 1, 1, 3, 4) y &lt;- c(7, 6, 8) X &lt;- matrix(x, nrow = 4, ncol = 3) X %*% y [,1] [1,] 27 [2,] 21 [3,] 49 [4,] 63 행렬의 전치(transpose) 전치 행렬(transpose matrix)는 임의의 행렬의 행과 열을 서로 맞바꾼 행렬임 행렬 \\(\\mathrm{\\mathbf X}\\)의 전치 행렬은 \\(\\mathrm{\\mathbf X}^T\\) 또는 \\(\\mathrm{\\mathbf X}&#39;\\) 으로 나타냄 행렬 \\(\\mathrm{\\mathbf X}\\)가 다음과 같이 주어졌을 때 전치 행렬 결과 \\[\\mathrm{\\mathbf{X}} = \\begin{bmatrix} 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6 \\end{bmatrix} ~~~~~ \\mathrm{\\mathbf{X}}^T = \\begin{bmatrix} 1 &amp; 4 \\\\ 2 &amp; 5 \\\\ 3 &amp; 6 \\end{bmatrix} \\] R에서 행렬을 전치시키는 함수는 t() 임 # t(object_name): 전치행렬 반환 x &lt;- 1:6 X &lt;- matrix(x, nrow = 2, ncol = 3, byrow = T) t(X) [,1] [,2] [1,] 1 4 [2,] 2 5 [3,] 3 6 # 전치행렬과 행렬 간 곱 x &lt;- c(1, 1, 1, 1, 1, 22.3, 23.2, 21.5, 25.3, 28.0) X &lt;- matrix(x, nrow = 5) t(X) %*% X [,1] [,2] [1,] 5.0 120.30 [2,] 120.3 2921.87 벡터-벡터 곱 연산(%*% 사용) \\[ \\mathrm{\\mathbf x} = [1, 2, 3, 4]^T \\] \\[\\mathrm{\\mathbf x}\\mathrm{\\mathbf x}^T = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix} \\cdot \\begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 \\\\ 2 &amp; 4 &amp; 6 &amp; 8 \\\\ 3 &amp; 6 &amp; 9 &amp; 12 \\\\ 4 &amp; 8 &amp; 12 &amp; 16 \\end{bmatrix} \\] \\[\\mathrm{\\mathbf x}^T\\mathrm{\\mathbf x} = \\begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 \\end{bmatrix} \\cdot \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix} = 1 + 4 + 9 + 16 = 30 \\] x &lt;- 1:4 x %*% t(x) # 행렬 반환 [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 2 4 6 8 [3,] 3 6 9 12 [4,] 4 8 12 16 t(x) %*% x # 스칼라 반환 x %*% x와 동일 결과 출력 [,1] [1,] 30 참고: 전치행렬의 성질(통계수학 II 강의내용 참고) \\((\\mathrm{\\mathbf{X}}^T)^T = \\mathrm{\\mathbf{X}}\\) \\((\\mathrm{\\mathbf{X} + \\mathbf{Y}})^T = \\mathrm{\\mathbf{X}}^T + \\mathrm{\\mathbf{Y}}^T\\) \\((\\mathrm{\\mathbf{X}\\mathbf{Y}})^T = \\mathrm{\\mathbf{Y}}^T\\mathrm{\\mathbf{X}}^T\\) \\((c\\mathrm{\\mathbf{X}})^T = c\\mathrm{\\mathbf{X}}^T\\), \\(c\\)는 임의의 상수 역행렬(inverse matrix) 행렬의 나눗셈 형태 행렬 \\(\\mathrm{\\mathbf{X}}\\) 가 \\(n \\times n\\) 정방행렬(square matrix)일 때, 아래를 만족하는 행렬 \\(\\mathrm{\\mathbf{Y}}_{n \\times n}\\)가 존재하면 \\(\\mathrm{\\mathbf{Y}}\\)를 \\(\\mathrm{\\mathbf{X}}\\)의 역행렬(inverse matrix)라고 하고 \\(\\mathrm{\\mathbf{X}}^{-1}\\)로 나타냄. \\[ \\mathrm{\\mathbf{X}\\mathbf{X}^{-1}} = \\mathrm{\\mathbf{X}^{-1}\\mathbf{X}} = \\mathrm{\\mathbf{I}}_{n\\times n} \\] 여기서 \\(\\mathrm{\\mathbf{I}}_{n\\times n}\\)은 대각 원소가 1이고 나머지 원소는 0인 항등 행렬임 \\(2 \\times 2\\) 행렬의 역행렬은 아래와 같이 구함(\\(3\\times 3\\) 이상 역행렬 구하는 방법은 통계수학 II 강의 참고) \\[\\mathrm{\\mathbf{X}} = \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix}, ~~~~ \\mathrm{\\mathbf{X}}^{-1} = \\frac{1}{ad - bc} \\begin{bmatrix} ~~~d &amp; -b \\\\ -c &amp;~~~a \\end{bmatrix} \\] R에서 정방 행렬의 역행렬은 solve() 함수를 사용해 구함 # 2 by 2 행렬의 역행렬 x &lt;- c(1, 2, 3, 4) X &lt;- matrix(x, 2) solve(X) [,1] [,2] [1,] -2 1.5 [2,] 1 -0.5 # 항등 행렬이 나오는지 확인 X %*% solve(X) [,1] [,2] [1,] 1 0 [2,] 0 1 참고: 역행렬의 성질(통계수학 II 강의내용 참고) \\((\\mathrm{\\mathbf{X}}^{-1})^{-1} = \\mathrm{\\mathbf{X}}\\) \\((\\mathrm{\\mathbf{X}}^T)^{-1} = (\\mathrm{\\mathbf{X}}^{-1})^T\\) \\((\\mathrm{\\mathbf{XY}})^{-1} = \\mathrm{\\mathbf{Y}}^{-1}\\mathrm{\\mathbf{X}}^{-1}\\) 행렬식(determinant) 행렬의 성질을 대표할 수 있는 하나의 값으로 \\(n \\times n\\) 정방행렬(square matrix)에서 정의 역행렬을 구할 때 임의의 행렬이 0, 즉 위 \\(2\\times 2\\) 행렬에서 \\(ad - bc\\)의 값이 0이라면 역행렬이 존재할 수 없는데 여기서 \\(ad - bc\\)가 \\(2\\times 2\\) 행렬의 정방행렬임 임의의 정방행렬 \\(\\mathrm{\\mathbf X}\\)의 행렬식은 \\(|\\mathrm{\\mathbf X}|\\) 또는 \\(\\det(\\mathrm{\\mathbf{X}})\\)로 표시함 \\(2\\times 2\\) 행렬의 행렬식은 넓이, \\(3\\times 3\\) 이상인 정방 행렬에서는 부피의 개념으로 이해할 수 있음 정방행렬 \\(\\mathrm{\\mathbf X}_{n\\times n}=\\{x_{ij}\\}\\)가 주어졌을 때, \\(i\\) 번째 행과 \\(j\\) 번째 열을 제외한 나머지 \\((n-1)\\times (n-1)\\) 정방행렬의 행렬식을 \\(|\\mathrm{\\mathbf{X}}_{ij}|\\) 라고 하면 이를 \\(x_{ij}\\)의 소행렬식(minor)이라 부르고 \\(x_{ij}\\)의 여인수(co-factor) \\(\\mathrm{\\mathbf{C}}_{ij}\\) 는 아래와 같이 정의됨 \\[ c_{ij} = (-1)^{i+j}|\\mathrm{\\mathbf{X}}_{ij}| \\] 이때 \\(\\mathrm{\\mathbf X}_{n\\times n}\\) 행렬식은 임의의 \\(i\\) 또는 \\(j\\)에 대해 아래의 식을 통해 구할 수 있음 \\[ \\det(\\mathrm{\\mathbf{X}}) = \\sum_{i=1}^{n}x_{ij}c_{ij} = \\sum_{j=1}^n x_{ij}c_{ij} \\] 행렬식 계산 예시 \\[\\mathrm{\\mathbf{X}} = \\begin{bmatrix} 1 &amp;~~~5 &amp;~~~0\\\\ 2 &amp;~~~4 &amp; -1\\\\ 0 &amp; -2 &amp;~~~0 \\end{bmatrix} \\] \\[\\begin{aligned} \\det(\\mathrm{\\mathbf{X}}) &amp;= x_{11}\\det(\\mathrm{\\mathbf{X}}_{11}) - x_{12}\\det(\\mathrm{\\mathbf{X}}_{12}) + x_{13}\\det(\\mathrm{\\mathbf{X}}_{13}) \\\\ &amp; \\\\ &amp; = 1 \\begin{vmatrix} ~~~4 &amp; -1 \\\\ - 2&amp;~~~0 \\end{vmatrix} -5 \\begin{vmatrix} 2 &amp; -1 \\\\ 0 &amp;~~~0 \\end{vmatrix} + 0 \\begin{vmatrix} 2 &amp;~~~4 \\\\ 0 &amp; -2 \\end{vmatrix} = -2 \\end{aligned} \\] R에서 임의 행렬의 행렬식은 det() 함수를 이용해 구함 X &lt;- matrix(c(1, 2, 0, 5, 4, -2, 0, -1, 0), ncol = 3) det(X) [1] -2 참고: 행렬식의 성질(통계수학 II 강의내용 참고) 행렬 \\(\\mathrm{\\mathbf{X}}\\), \\(\\mathrm{\\mathbf{Y}}\\)가 정방행렬이면 \\(\\det(\\mathrm{\\mathbf{XY}}) = \\det(\\mathrm{\\mathbf{X}})\\det(\\mathrm{\\mathbf{Y}})\\) \\(\\det(\\mathrm{\\mathbf{X}}) = \\det(\\mathrm{\\mathbf{X}}^T)\\) \\(\\det(c\\mathrm{\\mathbf{X}}) = c^n \\det(\\mathrm{\\mathbf{X}})\\) 여기서 \\(c\\)는 임의의 상수 \\(\\det(\\mathrm{\\mathbf{X}}^{-1}) = \\det(\\mathrm{\\mathbf{X}})^{-1}\\) 그외 정칙(non-singluar), 비정칙(non-singular), 양정치(positive definite) 행렬 모두 행렬식으로 정의할 수 있고 자세한 내용은 통계수학 II를 통해 학습. 추가적으로 여인수 \\(c_{ij}\\) 를 이용한 역행렬 공식은 아래와 같음 \\[\\mathrm{\\mathbf{X}}^{-1} = \\frac{1}{\\det(\\mathrm{\\mathbf{X}})} \\begin{bmatrix} c_{11} &amp; c_{12} &amp; \\cdots &amp; c_{1n} \\\\ c_{21} &amp; c_{22} &amp; \\cdots &amp; c_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\cdots &amp; \\vdots \\\\ c_{n1} &amp; c_{n2} &amp; \\cdots &amp; c_{nn} \\end{bmatrix} \\] 예습: \\(3\\times 3\\) 정방행렬 \\(\\mathrm{\\mathbf{X}}\\)가 아래와 같이 주어졌을 때, \\(\\mathrm{\\mathbf{X}}\\)의 행렬식과 역행렬 \\(\\mathrm{\\mathbf{X}}^{-1}\\)을 직접 계산해 보고, R에서 각각을 구하는 함수를 사용하여 계산 결과가 맞는지 확인 \\[\\mathrm{\\mathbf{X}} = \\begin{bmatrix} 6 &amp; 1 &amp; 4 \\\\ 2 &amp; 5 &amp; 3 \\\\ 1 &amp; 1 &amp; 2 \\end{bmatrix} \\] 2.5.2 행렬의 색인 R의 행렬 객체 내 데이터 접근은 벡터와 유사하게 행과 열에 대응하는 색인 또는 이름으로 접근 가능 행렬의 행과 열은 꺽쇠 `[]’ 안에서 ,(콤마)로 구분 X[idx_row, idx_col]: 행렬 X의 idx_row 행, idx_col행에 저장된 값 반환(색인번호는 1부터 시작) idx_row, idx_col을 지정하지 않으면 전체 행 또는 열을 선택 x &lt;- 1:12 X &lt;- matrix(x, ncol = 4) X [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 # 1행만 선택 X[1, ] [1] 1 4 7 10 # 3열만 선택 X[, 3] [1] 7 8 9 # 1:3행만 선택 X[1:3, ] [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 # 1-2행, 3-4열 선택 X[1:2, 3:4] [,1] [,2] [1,] 7 10 [2,] 8 11 행렬의 각 행과 열에 이름 부여 가능 \\(\\rightarrow\\) matrix() 함수 인수 중 dimnames 에 속성 부여와 동일 dimnames() 함수를 통해 각 행과 열의 이름 확인 및 부여 가능 dimnames(object)[[i]], i = 1, 2 를 통해 행(i = 1)과 열(i = 2) 이름 변경 및 부여 가능 위와 유사한 기능을 하는 함수 rownames(): 헹 이름 반환 및 부여 colnames(): 열 이름 반환 및 부여 # matrix 함수 내에서 행렬 이름 동시 부여 X &lt;- matrix(1:9, ncol = 3, dimnames = list(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;), # 행 이름 c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)))# 열 이름 X A B C 1 1 4 7 2 2 5 8 3 3 6 9 # dimnames()를 이용한 이름 확인 dimnames(X) # 행렬에 대한 리스트 반환 [[1]] [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; [[2]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; # dimnames() 함수로 행 이름 변경 dimnames(X)[[1]] &lt;- c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;) # dimnames() 함수로 열 이름 변경 dimnames(X)[[2]] &lt;- c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;) dimnames(X) [[1]] [1] &quot;r1&quot; &quot;r2&quot; &quot;r3&quot; [[2]] [1] &quot;c1&quot; &quot;c2&quot; &quot;c3&quot; X c1 c2 c3 r1 1 4 7 r2 2 5 8 r3 3 6 9 # rownames()를 통해 행 이름 확인 rownames(X) [1] &quot;r1&quot; &quot;r2&quot; &quot;r3&quot; # colnames()를 통해 열 이름 확인 colnames(X) [1] &quot;c1&quot; &quot;c2&quot; &quot;c3&quot; # rownames()를 이용해 행 이름 변경 rownames(X) &lt;- c(&quot;apple&quot;, &quot;strawberry&quot;, &quot;orange&quot;) rownames(X) [1] &quot;apple&quot; &quot;strawberry&quot; &quot;orange&quot; # colnames()를 이용해 행 이름 변경 colnames(X) &lt;- c(&quot;costco&quot;, &quot;emart&quot;, &quot;homeplus&quot;) colnames(X) [1] &quot;costco&quot; &quot;emart&quot; &quot;homeplus&quot; X costco emart homeplus apple 1 4 7 strawberry 2 5 8 orange 3 6 9 행과 열에 대한 이름이 존재한다면 벡터와 마찬가지로 이름으로 색인 가능 X[c(&quot;apple&quot;, &quot;orange&quot;), c(&quot;emart&quot;)] apple orange 4 6 # 2번째 열에 해당(emart)를 제외한 나머지 열 반환 X[, colnames(X)[-2]] costco homeplus apple 1 7 strawberry 2 8 orange 3 9 색인한 행렬 원소에 다른 값 할당 y &lt;- c(1:12); Y &lt;- matrix(y, ncol = 3) Y [,1] [,2] [,3] [1,] 1 5 9 [2,] 2 6 10 [3,] 3 7 11 [4,] 4 8 12 # 2, 4 행과 2-3열에 다른 값 할당 Y[c(2, 4), 2:3] &lt;- matrix(c(1, 2, 1, 4), ncol = 2) # 행렬 값 할당 다른 예시 X &lt;- matrix(nrow = 4, ncol = 3) # NA 값으로 구성된 4 by 3 행렬 X [,1] [,2] [,3] [1,] NA NA NA [2,] NA NA NA [3,] NA NA NA [4,] NA NA NA y &lt;- c(1, 0, 0, 1); Y &lt;- matrix(y, ncol = 2) X[3:4, 2:3] &lt;- Y X [,1] [,2] [,3] [1,] NA NA NA [2,] NA NA NA [3,] NA 1 0 [4,] NA 0 1 행렬 필터링 \\(\\rightarrow\\) 색인 대신 조건 사용(벡터와 동일) X = matrix(c(1,2,4,3,2,3,5,6), nrow = 4, ncol = 2) # X의 1열이 3보다 작거나 같은 행 필터링 X[X[,1] &lt;= 3, ] [,1] [,2] [1,] 1 2 [2,] 2 3 [3,] 3 6 # 논리값을 활용한 필터링 idx &lt;- X[, 1] &lt;= 3; idx [1] TRUE TRUE FALSE TRUE X[idx, ] [,1] [,2] [1,] 1 2 [2,] 2 3 [3,] 3 6 2.5.3 행과 열 추가 및 제거 행렬 재할당(re-assignment)를 통해 열이나 행을 직접 추가하거나 삭제 가능 cbind() (열 붙이기, column bind), rbind() (행 붙이기, row bind) 함수 사용 j &lt;- rep(1, 4) Z &lt;- matrix(c(1:4, 1, 1, 0, 0, 1, 0, 1, 0), nrow = 4, ncol = 3) Z [,1] [,2] [,3] [1,] 1 1 1 [2,] 2 1 0 [3,] 3 0 1 [4,] 4 0 0 cbind(j, Z) # 열 기준으로 붙이기 j [1,] 1 1 1 1 [2,] 1 2 1 0 [3,] 1 3 0 1 [4,] 1 4 0 0 # 길이가 다른 경우 재사용 cbind(1, Z) [,1] [,2] [,3] [,4] [1,] 1 1 1 1 [2,] 1 2 1 0 [3,] 1 3 0 1 [4,] 1 4 0 0 # Z 행렬 앞에 j 열 붙혀서 새로운 Z 생성 Z &lt;- cbind(j, Z) # 행 기준으로 붙이기 Z &lt;- rbind(Z, 2) 행 또는 열의 제거는 벡터에서와 마찬가지로 색인 앞에 - 사용 # 첫 번째 행 제거 Z[-1, ] j [1,] 1 2 1 0 [2,] 1 3 0 1 [3,] 1 4 0 0 [4,] 2 2 2 2 # 1, 5행 , 3열 제거 Z[-c(1, 5), -3] j [1,] 1 2 0 [2,] 1 3 1 [3,] 1 4 0 cbind() 또는 rbind() 함수는 다음 주에 배울 데이터 프레임에도 적용 가능하다. 2.5.4 행렬 관련 함수 diag(): 대각행렬 생성 또는 대각원소(diagonal elements) 추출 대각행렬: 주 대각선을 제외한 모든 원소가 0인 \\(n\\times n\\) 정방행렬로 다음과 같이 정의 \\[ \\mathrm{\\mathbf{D}} = \\{d_{ij}\\},~~~~i, j \\in \\{1, 2, \\ldots, n\\},~~~~\\forall~ i \\neq j \\rightarrow d_{ij} = 0 \\] D &lt;- diag(c(1:5), 5) D [,1] [,2] [,3] [,4] [,5] [1,] 1 0 0 0 0 [2,] 0 2 0 0 0 [3,] 0 0 3 0 0 [4,] 0 0 0 4 0 [5,] 0 0 0 0 5 # 3차원 항등 행렬(모든 대각원소가 1인 행렬) I3 &lt;- diag(1, 3) #대각원소 추출 diag(D) [1] 1 2 3 4 5 # 대각원소 재할당 diag(D) &lt;- rep(1, 5) 객체는 속성(attribute)을 갖고 그 속성에 따라 데이터의 구조가 정해짐. 즉 속성은 데이터에 대한 메타 데이터임. 객체의 속성은 대표적으로 이름(names), 차원(dimension), 클래스(class)로 정의되고 객제에 대한 자세한 정보를 파악하기 위해 제공되는 몇 가지 함수들에 대해 알아봄. R은 앞서 언급한 바와 같이 객체지향언어(object oriented program, OOP)이고 세 가지 유형의 객체지향 시스템(S3, S4, S5)이 존재함. R의 핵심적인 함수 및 패키지는 S3 객체 시스템을 사용하고 있기 때문에 알아둘 필요가 있으나 본 강의의 범위를 벗어나기 때문에 이번 학기에는 다루지 않을 것임. dim(object_name): 행렬 또는 데이터 프레임의 행과 열의 개수(차원)를 반환 # dim(): 객체의 차원(dimension)을 반환 Z j [1,] 1 1 1 1 [2,] 1 2 1 0 [3,] 1 3 0 1 [4,] 1 4 0 0 [5,] 2 2 2 2 dim(Z) [1] 5 4 nrow() 또는 NROW(): 행렬의 행 길이 반환 ncol() 또는 NCOL(): 행렬의 행 길이 반환 nrow(Z); ncol(Z) [1] 5 [1] 4 nrow()/ncol()과 NROW()/NCOL()의 차이점 nrow()/ncol()은 행렬 또는 데이터 프레임에 적용되며 벡터가 인수로 사용될 때 NULL 값을 반환하는데 비해 NROW()/NCOL()은 벡터의 길이도 반환 가능 attributes(): 객체가 갖는 속성을 반환함 x &lt;- 1:9; X &lt;- matrix(x, ncol = 3) # 객체의 속성 확인 attributes(x) NULL attributes(X) $dim [1] 3 3 class(): 객체의 클래스 명칭 반환 및 클래스 부여 # 객체의 class 확인 class(x); class(X) [1] &quot;integer&quot; [1] &quot;matrix&quot; &quot;array&quot; # 객체의 class 부여 class(x) &lt;- &quot;this is a vector&quot; str(): 객체가 갖고 있는 데이터의 구조 확인 # 객체의 구조 파악 str(x); str(X) &#39;this is a vector&#39; int [1:9] 1 2 3 4 5 6 7 8 9 int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 # x와 X에 이름(name) 속성을 추가한 경우 names(x) &lt;- paste0(&quot;x&quot;, 1:9) dimnames(X) &lt;- list(paste0(&quot;r&quot;, 1:3), paste0(&quot;c&quot;, 1:3)) attributes(x); attributes(X) $class [1] &quot;this is a vector&quot; $names [1] &quot;x1&quot; &quot;x2&quot; &quot;x3&quot; &quot;x4&quot; &quot;x5&quot; &quot;x6&quot; &quot;x7&quot; &quot;x8&quot; &quot;x9&quot; $dim [1] 3 3 $dimnames $dimnames[[1]] [1] &quot;r1&quot; &quot;r2&quot; &quot;r3&quot; $dimnames[[2]] [1] &quot;c1&quot; &quot;c2&quot; &quot;c3&quot; class(x); class(X) [1] &quot;this is a vector&quot; [1] &quot;matrix&quot; &quot;array&quot; str(x); str(X) &#39;this is a vector&#39; Named int [1:9] 1 2 3 4 5 6 7 8 9 - attr(*, &quot;names&quot;)= chr [1:9] &quot;x1&quot; &quot;x2&quot; &quot;x3&quot; &quot;x4&quot; ... int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 - attr(*, &quot;dimnames&quot;)=List of 2 ..$ : chr [1:3] &quot;r1&quot; &quot;r2&quot; &quot;r3&quot; ..$ : chr [1:3] &quot;c1&quot; &quot;c2&quot; &quot;c3&quot; attr(object, \"attribute_name\"): 객체가 갖고 있는 속성을 지정해서 확인 # 객체 속성 요소 확인 attr(x, &quot;names&quot;) [1] &quot;x1&quot; &quot;x2&quot; &quot;x3&quot; &quot;x4&quot; &quot;x5&quot; &quot;x6&quot; &quot;x7&quot; &quot;x8&quot; &quot;x9&quot; attr(X, &quot;dimnames&quot;) [[1]] [1] &quot;r1&quot; &quot;r2&quot; &quot;r3&quot; [[2]] [1] &quot;c1&quot; &quot;c2&quot; &quot;c3&quot; 2.5.5 벡터와 행렬의 차이점 행렬은 개념적으로 \\(n \\times 1\\) 벡터가 2 개 이상 묶어져서 행과 열의 속성을 갖지만 기본적으로는 벡터 z &lt;- 1:8 U &lt;- matrix(z, 4, 2) length(z) # 입력 벡터 원소의 길이가 8 [1] 8 R에서 U가 행렬임을 나타내기 위해 추가적인 속성(attribute)를 부여 class(z) # 벡터 [1] &quot;integer&quot; attributes(z) NULL class(U) # 행렬 [1] &quot;matrix&quot; &quot;array&quot; attributes(U) $dim [1] 4 2 2.5.6 의도치 않은 차원축소 피하기 다음 행렬에서 한 행을 추출 Z &lt;- matrix(c(1:8), 4, 2) z &lt;- Z[2, ] attributes(Z) # 행과 열의 차원 수를 표시 $dim [1] 4 2 # 객체 z의 속성및 형태는? attributes(z) # 차원이 존재하지 않음 NULL 차원축소를 방지하는 방법 \\(\\rightarrow\\) r을 벡터가 아닌 \\(1 \\times 2\\) 행렬로 인식 z &lt;- Z[2, , drop = FALSE] attributes(z) $dim [1] 1 2 as.matrix()를 이용한 직접 변환 z &lt;- as.matrix(Z[2, ]) class(z) [1] &quot;matrix&quot; &quot;array&quot; z # 행렬이 변환됨을 유의 [,1] [1,] 2 [2,] 6 "],["array.html", "2.6 배열(array)", " 2.6 배열(array) 통계학의 관점에서 R의 행렬의 행은 조사 대상이 되는 사람, 동물 등 관측 대상에 해당하고, 열은 대상의 특성을 표현하는 변수(예: 몸무게, 키, 혈압 등)에 해당 \\(\\rightarrow\\) 2차원 구조 위와 같은 데이터를 년 단위로 수집한다면? \\(\\rightarrow\\) 한 대상자에 해당하는 변수들은 시간에 따라 변함 \\(\\rightarrow\\) 시간 차원이 하나 더 존재! R에서 이러한 형태의 데이터 구조를 배열(array)이라고 지칭함 2.6.1 배열의 생성 및 색인 동일한 유형의 데이터가 2차원 이상으로 구성된 데이터 구조 동일한 차원(\\(n\\times p\\))의 배열(행렬)이 \\(k\\) 개 방에 저장된 데이터 구조 배열 생성 함수 # array() 함수 인수 구조 array(data, # 저장할 데이터 벡터 또는 행렬 dim, # 배열의 차원 지정 dimnames # 배열 차원 명칭 ) 통계학과 3명의 학생에 대한 중간고사 기준 한 번의 퀴즈와 중간고사 점수, 그리고 기말고사 기준 한 번의 퀴즈와 기말고사 점수 데이터 가정 x &lt;- c(75, 84, 93, 65, 78, 92) y &lt;- c(82, 78, 85, 88, 75, 88) first_term &lt;- matrix(x, nrow = 3, ncol = 2) second_term &lt;- matrix(y, nrow = 3, ncol = 2) first_term [,1] [,2] [1,] 75 65 [2,] 84 78 [3,] 93 92 second_term [,1] [,2] [1,] 82 88 [2,] 78 75 [3,] 85 88 # 위 두 데이터를 2층 짜리 배열로 구성 Z &lt;- array(data = c(first_term, second_term), dim = c(3, 2, 2)) Z , , 1 [,1] [,2] [1,] 75 65 [2,] 84 78 [3,] 93 92 , , 2 [,1] [,2] [1,] 82 88 [2,] 78 75 [3,] 85 88 # Z의 속성 attributes(Z) $dim [1] 3 2 2 # Z의 클래스 class(Z) [1] &quot;array&quot; # Z의 구조 str(Z) num [1:3, 1:2, 1:2] 75 84 93 65 78 92 82 78 85 88 ... 배열 내 데이터 접근은 색인을 통해 가능(벡터 행렬과 동일) # 첫 번째 층만 추출 Z[, , 1] [,1] [,2] [1,] 75 65 [2,] 84 78 [3,] 93 92 # 두 번째 층에서 2-3행 만 추출 Z[2:3, , 2] [,1] [,2] [1,] 78 75 [2,] 85 88 2.6.2 배열의 확장 예제 데이터 사이언스 스쿨 참고 배열 구조를 갖는 가장 대표적인 데이터 중 하나가 이미지(사진) 이미지 데이터는 픽셀(pixel) 이라는 세분화된 작은 이미지를 직사각형 형태로 모은 형태 전체 이미지는 세로픽셀수 \\(\\times\\) 가로픽셀수 로 표현됨 \\(\\rightarrow\\) 행렬 픽셀의 색을 숫자로 표현하는 방식을 색공간(color space)라고 명칭 대표적 색공간은 흑백스케일(grey scale), RGB (Red-Green-Blue), HSV(Hue-Saturation-Value) 방식 RGB 색공간을 사용한 경우 각 색공간별로 동일한 크기의 행렬이 3개 층으로 저장된 상태 \\(\\rightarrow\\) 배열 RGB는 0 ~ 255 까지 값을 갖고 빨강색 (255, 0, 0), 녹색 (0, 255, 0), 파란색은 (0, 0, 255)임 Figure 2.2: https://www.geeksforgeeks.org/matlab-rgb-image-representation/ 에서 발췌 목표 R에서 웹 url로 이미지를 불러오기 불러온 이미지를 R에서 plotting 해보기 이미지 데이터를 직접 수정 해보기 이미지 입출력 패키지 installation install.packages(&quot;jpeg&quot;) # jpeg 파일 입출력 관련 package install.packages(&quot;cowplot&quot;) # ggplot add-on package 관련 패키지 불러오기 require(tidyverse) require(jpeg) require(cowplot) 이미지 불러오기 # URL을 주소로 직접 그림 읽어오기 # myurl &lt;- &quot;https://img.livescore.co.kr/data/editor/1906/ba517de8162d92f4ea0e9de0ec98ba02.jpg&quot; # z &lt;- tempfile() # download.file(img,z,mode=&quot;wb&quot;) # pic &lt;- readJPEG(z) img &lt;- &quot;figures/stranger-thing.jpg&quot; pic &lt;- readJPEG(img) 이미지 그래프 출력창에서 확인 이미지 임의 부분 편집하기 pic[300:460, 440:520, 1] &lt;- 0.5 pic[300:460, 440:520, 2] &lt;- 0.5 pic[300:460, 440:520, 3] &lt;- 0.5 ggdraw() + draw_image(pic) RGB값을 무작위로 샘플링 후 매개변수로 노이즈 가중치 조절해 보기 # pic &lt;- readJPEG(z) pic &lt;- readJPEG(img) yr &lt;- pic[300:460, 440:520, 1] yg &lt;- pic[300:460, 440:520, 2] yb &lt;- pic[300:460, 440:520, 3] n &lt;- nrow(yr); p &lt;- ncol(yr) t &lt;- 0.2 wr &lt;- t * yr + (1 - t)*matrix(runif(length(yr)), nrow = n, ncol = p) wg &lt;- t * yg + (1 - t)*matrix(runif(length(yg)), nrow = n, ncol = p) wb &lt;- t * yb + (1 - t)*matrix(runif(length(yb)), nrow = n, ncol = p) pic[300:460, 440:520, 1] &lt;- wr pic[300:460, 440:520, 2] &lt;- wg pic[300:460, 440:520, 3] &lt;- wb ggdraw() + draw_image(pic) "],["factor-table.html", "2.7 요인(factor)과 테이블(table)", " 2.7 요인(factor)과 테이블(table) 요인(factor) 데이터 타입은 통계학에서 범주형 변수(categorical variable)을 표현하기 위한 R의 데이터 타입으로 범주형 자료는 크게 명목형(nominal)과 순서형(ordinal) 으로 구분 테이블(table) 객체는 factor 객체에 대한 빈도를 나타내기 위해 사용 범주형 자료 데이터가 사전에 정해진 특정 유형으로만 분류되는 경우: 성별, 인종, 혈액형 등 범주형 자료는 명목형과 순서형으로 구분 가능 순서형 자료 예: 성적, 교육수준, 선호도, 중증도 등 2.7.1 요인(factor) 범주형 자료를 표현하기 위한 R의 객체 클래스 Factor는 정수형 벡터를 기반으로 levels (수준) 이라는 속성이 추가된 객체임 숫자 또는 문자로 표현 되었다 하더라도 범주형으로 이해 Factor는 level에 해당하는 값만 가질 수 있는 벡터로 간주 Factor 생성 함수 # factor 정의 함수 factor(data, # factor로 표현하고자 하는 값. 주로 문자형 levels, # 요인의 수준, 미리 정한 값 labels, # 수준에 대한 레이블링 ordered # 순서형 자료 표시 여부 # TRUE/FALSE, default = FALSE ) 수치형을 factor로 만들어도 처음 입력 값은 문자형으로 변하고 level 값으로 치환 대신 (1, 2, 3)이 중심값이 됨 \\(\\rightarrow\\) 정수형 벡터임 score &lt;- rep(c(4:6), each = 4) fscore &lt;- factor(score) typeof(fscore) # factor의 기본 데이터 타입 [1] &quot;integer&quot; attributes(fscore) # factor의 속성 $levels [1] &quot;4&quot; &quot;5&quot; &quot;6&quot; $class [1] &quot;factor&quot; # factor의 구조 str(fscore) Factor w/ 3 levels &quot;4&quot;,&quot;5&quot;,&quot;6&quot;: 1 1 1 1 2 2 2 2 3 3 ... # levels(): factor의 수준(levels) 반환 함수 levels(fscore) [1] &quot;4&quot; &quot;5&quot; &quot;6&quot; # nlevels(): level의 개수 반환 nlevels(fscore) [1] 3 Factor를 벡터 결합 함수 c()로 결합 c(fscore, factor(4)) # 강제로 정수형 벡터로 변환 [1] 4 4 4 4 5 5 5 5 6 6 6 6 4 Levels: 4 5 6 Factor의 범주 수준(level) 및 범주명(label) 지정 x &lt;- rep(c(1:2), each = 4) # factor의 범주 수준 지정 sex &lt;- factor(x, levels = 1:2) sex [1] 1 1 1 1 2 2 2 2 Levels: 1 2 # factor의 범주 수준 및 범주 명칭 지정 sex &lt;- factor(x, levels = 1:2, labels = c(&quot;male&quot;, &quot;female&quot;)) sex # level의 값이 명칭으로 변경 [1] male male male male female female female female Levels: male female str(sex) Factor w/ 2 levels &quot;male&quot;,&quot;female&quot;: 1 1 1 1 2 2 2 2 # 값은 존재하지 않으나 수준을 미리 정해 놓은 경우 severity &lt;- factor(1:2, levels = c(1, 2, 3), labels = c(&quot;Mild&quot;, &quot;Moderate&quot;, &quot;Severe&quot;)) severity[2] &lt;- &quot;Severe&quot; # 존재하지 않는 수준 할당 severity[1] &lt;- &quot;Good&quot; Warning in `[&lt;-.factor`(`*tmp*`, 1, value = &quot;Good&quot;): 요인의 수준(factor level)이 올바르지 않아 NA가 생성되었습니다. severity [1] &lt;NA&gt; Severe Levels: Mild Moderate Severe 순서형 factor 생성 severity &lt;- factor(rep(1:3, times = 3), levels = 1:3, labels = c(&quot;Mild&quot;, &quot;Moderate&quot;, &quot;Severe&quot;), ordered = T) severity [1] Mild Moderate Severe Mild Moderate Severe Mild Moderate [9] Severe Levels: Mild &lt; Moderate &lt; Severe is.ordered(severity) # 순서형 범주 체크 [1] TRUE 요인형 객체에 적용되는 일반적인 함수 tapply() 함수 특정 요인 수준의 고유한 조합으로 각 그룹에 속한 값에 특정 함수를 적용한 결과를 반환 일반적인 함수 사용 형태는 아래와 같음 # tapply() 함수 사용 인수 tapply( x, # 벡터, INDEX, # 벡터를 그룹화할 색인(factor) FUN, # 각 그룹마다 적용할 함수 ) 예시: 2020년 4월 15일 총선의 연령별 지지율 # 문자열을 INDEX의 인수로 받은 경우 x &lt;- c(48, 43, 27, 52, 38, 67, 23, 58, 72, 85) # 유권자 연령 f &lt;- rep(c(&quot;더불어민주당&quot;, &quot;미래통합당&quot;), each = 5) t &lt;- tapply(x, f, mean) # f의 요인 수준 별 x (연령) 평균 계산 t 더불어민주당 미래통합당 41.6 61.0 # x, f 순서를 랜덤하게 섞은 다음 결과 set.seed(12345) # 난수 생성 결과 고정 idx &lt;- order(runif(10)) x &lt;- x[idx] f &lt;- f[idx] tapply(x, f, mean) 더불어민주당 미래통합당 41.6 61.0 Factor가 2개 이상인 경우 두 factor 객체의 수준의 조합(AND 조건)에 따른 그룹을 만든 후 그룹별 함수 적용 s &lt;- rep(c(&quot;M&quot;,&quot;F&quot;), each = 6) income &lt;- c(35, 42, 68, 29, 85, 55, 30, 40, 63, 27, 83, 52) * 100 # 단위: 만원 age &lt;- c(32, 36, 44, 25, 55, 41, 28, 33, 46, 23, 54, 44) set.seed(12345) # 난수 생성 결과 고정 idx &lt;- order(runif(12)) s &lt;- s[idx]; income &lt;- income[idx]; age &lt;- age[idx] # age &lt;= 40 -&gt; 1, 40 &lt; age &lt;= 50 -&gt; 2, # age &gt;= 50 -&gt; 3 할당: ifelse() 함수 사용 age &lt;- ifelse(age &lt;= 40, 1, ifelse(age &lt;= 50, 2, 3)) tapply(income, list(sex = s, age = age), mean) age sex 1 2 3 F 3233.333 5750 8300 M 3533.333 6150 8500 R에서 가장 많이 활용되는 함수 계열 중 하나로 *apply()를 들 수 있다. 벡터, 행렬 등과 같은 R 객체에 for loop 대신 반복적으로 동일한 함수를 적용할 때 활용된다. *apply() 계열 함수에 대해서는 데이터 프레임 에서 더 상세하게 배울 것임 split() 함수 tapply()는 주어진 요인의 수준에 따라 특정 함수를 적용하지만, split()은 데이터를 요인의 수준(그룹) 별로 데이터를 나누어 리스트 형태로 반환 # split() 함수 사용 인수 split( x, # 분리할 데이터(벡터) f, # 데이터를 분리할 기준이 되는 factor 지정 ) split() 함수 사용 예시 # 성별의 수준 남녀 별 소득 수준 분리 split(income, s) $F [1] 8300 5200 3000 4000 6300 2700 $M [1] 5500 8500 3500 6800 4200 2900 # 두 개 요인 조합으로 income 벡터 분리 split(income, list(s, age)) $F.1 [1] 3000 4000 2700 $M.1 [1] 3500 4200 2900 $F.2 [1] 5200 6300 $M.2 [1] 5500 6800 $F.3 [1] 8300 $M.3 [1] 8500 # 요인의 각 수준에 대한 인덱스를 반환하고자 하는 경우 abalone &lt;- read.csv(&quot;http://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data&quot;, header = FALSE) # 전복 데이터셋 # V1: 전복의 종류 # F=암컷; M=수컷, I=새끼 g &lt;- abalone[, 1] # 전복종류만 추출 set.seed(20200410) idx &lt;- sample(1:length(g), size = 10) g &lt;- g[idx] split(1:length(g), g) $F [1] 1 6 8 $I [1] 2 3 5 7 $M [1] 4 9 10 2.7.2 테이블(table) 범주형 변수의 빈도 또는 분할표(교차표)를 표현하기 위한 객체(클래스) 범주 별 통계량(평균, 표준편차, 중위수, …) 요약 tapply() 함수를 이용한 테이블 만들기 길이가 12인 임의의 벡터 u를 수준의 개수가 각각 3, 2인 factor의 조합으로 부분벡터로 분리 후 length() 적용 \\(\\rightarrow\\) tapply() 함수 사용 u &lt;- runif(12) f1 &lt;- factor(c(4, 4, 3, 5, 5, 4, 3, 3, 4, 5, 5, 3)) f2 &lt;- factor(c(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;)) tapply(u, list(f1, f2), length) a b 3 1 3 4 4 NA 5 2 2 u의 값과 상관 없이 두 factor 형 변수 f1과 f2의 조합에 따른 개수 반환 \\(\\rightarrow\\) 분할표(contingency table) 위 예시에서 f1이 “4” 이고 f2가 “b” 인 경우는 없기 때문에 0 값이 있어야 하나, tapply() 함수 적용 시 결측값 NA를 반환 table(): 하나 이상의 factor의 수준 또는 수준의 조합으로 분할표 생성 Factor가 3개 이상인 경우 배열로 다차원 분할표 표현 # table() 적용 예시 t1 &lt;- table(f1, f2) t1 f2 f1 a b 3 1 3 4 4 0 5 2 2 typeof(t1); attributes(t1); str(t1) [1] &quot;integer&quot; $dim [1] 3 2 $dimnames $dimnames$f1 [1] &quot;3&quot; &quot;4&quot; &quot;5&quot; $dimnames$f2 [1] &quot;a&quot; &quot;b&quot; $class [1] &quot;table&quot; &#39;table&#39; int [1:3, 1:2] 1 4 2 3 0 2 - attr(*, &quot;dimnames&quot;)=List of 2 ..$ f1: chr [1:3] &quot;3&quot; &quot;4&quot; &quot;5&quot; ..$ f2: chr [1:2] &quot;a&quot; &quot;b&quot; # factor가 한개인 경우 table(f1) f1 3 4 5 4 4 4 # factor가 3개인 경우 year = c(&quot;1&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;3&quot;,&quot;4&quot;) gender = c(&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;F&quot;) grade = c(&quot;A&quot;,&quot;C&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;C&quot;) table(gender, grade, year) , , year = 1 grade gender A B C F 0 0 0 M 1 0 1 , , year = 2 grade gender A B C F 0 1 0 M 0 0 0 , , year = 3 grade gender A B C F 1 0 0 M 0 1 0 , , year = 4 grade gender A B C F 0 0 1 M 0 0 0 테이블 관련 함수 tabulate() 함수 정수로 이루어진 벡터에 각 정수 값이 발생한 횟수를 카운팅한 결과를 반환 \\(\\rightarrow\\) table() 함수의 핵심 함수 # tabulate() 함수 사용 인수(argument) tabulate( bin, # 정수형(수치형) 벡터 또는 factor nbins, # 사용할 수준(bin)의 개수 ) tabulate() 함수 예시 x &lt;- c(2, 2, 2, 1, 3, 4, 5, 5, 10, 8, 8) tabulate(x) [1] 1 3 1 1 2 0 0 2 0 1 tabulate(x, nbins = 3) [1] 1 3 1 addmargins() 함수 테이블 객체(분할표)를 인수로 받아 각 요인의 수준 및 수준 조합 별 합계 값을 테이블과 동시 반환 # addmargins() 함수 사용 인수 addmargins( T # 테이블 또는 배열 객체 ) addmargins() 예시 t1 &lt;- table(f1, f2) addmargins(t1) f2 f1 a b Sum 3 1 3 4 4 4 0 4 5 2 2 4 Sum 7 5 12 # 3차원 이상 테이블 t2 &lt;- table(gender, grade, year) is.table(t2); is.array(t2) [1] TRUE [1] TRUE addmargins(t2) , , year = 1 grade gender A B C Sum F 0 0 0 0 M 1 0 1 2 Sum 1 0 1 2 , , year = 2 grade gender A B C Sum F 0 1 0 1 M 0 0 0 0 Sum 0 1 0 1 , , year = 3 grade gender A B C Sum F 1 0 0 1 M 0 1 0 1 Sum 1 1 0 2 , , year = 4 grade gender A B C Sum F 0 0 1 1 M 0 0 0 0 Sum 0 0 1 1 , , year = Sum grade gender A B C Sum F 1 1 1 3 M 1 1 1 3 Sum 2 2 2 6 ftable() 함수 “평평한(flat)” 교차표 생성 다차원 교차표 작성 시 행변수와 열변수 교환을 통해 재사용 가능 ftable( x, # factor, table 또는 ftable 클래스를 갖는 객체 row.vars, # 행 변수 지정 색인(정수, 문자) col.vars # 열 변수 지정 색인(정수, 문자) ) ftable() 함수 사용 예시 t3 &lt;- ftable(t2) t3; attributes(t3); str(t3) year 1 2 3 4 gender grade F A 0 0 1 0 B 0 1 0 0 C 0 0 0 1 M A 1 0 0 0 B 0 0 1 0 C 1 0 0 0 $dim [1] 6 4 $class [1] &quot;ftable&quot; $row.vars $row.vars$gender [1] &quot;F&quot; &quot;M&quot; $row.vars$grade [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; $col.vars $col.vars$year [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &#39;ftable&#39; int [1:6, 1:4] 0 0 0 1 0 1 0 1 0 0 ... - attr(*, &quot;row.vars&quot;)=List of 2 ..$ gender: chr [1:2] &quot;F&quot; &quot;M&quot; ..$ grade : chr [1:3] &quot;A&quot; &quot;B&quot; &quot;C&quot; - attr(*, &quot;col.vars&quot;)=List of 1 ..$ year: chr [1:4] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; # 테이블 내 행 변수 바꾸기 t4 &lt;- ftable(t2, row.vars = c(&quot;year&quot;, &quot;gender&quot;)) t4 grade A B C year gender 1 F 0 0 0 M 1 0 1 2 F 0 1 0 M 0 0 0 3 F 1 0 0 M 0 1 0 4 F 0 0 1 M 0 0 0 # 테이블 내 열 변수 바꾸기 t5 &lt;- ftable(t2, col.vars = 1) t5 gender F M grade year A 1 0 1 2 0 0 3 1 0 4 0 0 B 1 0 0 2 1 0 3 0 1 4 0 0 C 1 0 1 2 0 0 3 0 0 4 1 0 margin.table() 함수 배열 형식으로 지정된 교차표(table() 반환 결과)에서 지정된 차원 색인에 대한 표 합계 계산 결과 반환 margin.table( x, # table 또는 ftable 클래스를 갖는 객체 margin # 차원 색인 번호 ) margin.table() 예시 t2 , , year = 1 grade gender A B C F 0 0 0 M 1 0 1 , , year = 2 grade gender A B C F 0 1 0 M 0 0 0 , , year = 3 grade gender A B C F 1 0 0 M 0 1 0 , , year = 4 grade gender A B C F 0 0 1 M 0 0 0 margin.table(t2, 1) # 1 차원(행): 성별 gender F M 3 3 margin.table(t2, 2) # 2 차원(열): 성적 grade A B C 2 2 2 margin.table(t2, 3) # 3 차원(배열 방 번호): 학년 year 1 2 3 4 2 1 2 1 prop.table() 함수 table 객체 빈도에 대한 비율 계산 전체, 차원 단위 비율 계산 가능 prop.table( x, # table 또는 ftable 클래스를 갖는 객체 margin # 차원 색인 번호 ) prop.table() 예시 margin = NULL: 각 셀을 전체 cell의 합으로 나눈 비율 margin = 1: 각 행 별 셀에 대해 각 행에 해당하는 cell 합으로 나눈 비율 \\((n_{ij}/n_{i.})\\), \\(n_{i.} = \\sum_{j=1}^{J} n_{ij}\\) margin = 2: 각 열 별 셀에 대해 각 열에 해당하는 cell 합으로 나눈 비율 \\((n_{ij}/n_{.j})\\), \\(n_{.j} = \\sum_{i=1}^{I} n_{ij}\\) # 2차원 교차표 prop.table(t1) # margin = NULL f2 f1 a b 3 0.08333333 0.25000000 4 0.33333333 0.00000000 5 0.16666667 0.16666667 prop.table(t1, 1) # margin = 1 (row) f2 f1 a b 3 0.25 0.75 4 1.00 0.00 5 0.50 0.50 prop.table(t1, 2) # margin = 2 (column) f2 f1 a b 3 0.1428571 0.6000000 4 0.5714286 0.0000000 5 0.2857143 0.4000000 "],["data-frame.html", "2.8 데이터 프레임(data frame)", " 2.8 데이터 프레임(data frame) 학습목표(4 주차): 데이터 프레임 클래스에 대해 알아보고, 데이터 프레임을 생성, 병합(merge), 연산에 대한 함수들에 대해 알아본다. Excel 스프레드시트와 같은 형태 Table 2.6: 스프레드시트 기본 형태 예시 이름 직장 나이 김어준 딴지일보 51 주진우 시사인 46 김용민 프리랜서 45 정봉주 정당인 59 데이터 프레임은 데이터 유형에 상관없이 2차원 형태의 데이터 구조 행렬과 리스트를 혼합한 자료 형태 \\(\\rightarrow\\) 동일한 길이의 벡터로 이루어진 리스트를 구성요소로 갖는 리스트 행렬과 유사한 구조를 갖고 있지만 각기 다른 유형의 자료형태로 자료행렬을 구성할 수 있다는 점에서 행렬과 차이를 갖음 행렬과 마찬가지로 변수(열)의 길이(행의 개수)는 모두 동일해야 함 R에서 가장 빈번하게 활용되고 있는 데이터 클래스임 데이터 프레임의 각 열(컬럼)은 벡터로 간주 2.8.1 데이터 프레임 생성 데이터 프레임 생성 함수: data.frame() data.frame( # 값 또는 이름(tag) = 값 ..., # 논리값. # 변수명(열 이름)이 구문 상 유효한 변수인지 또는 중복이 있는지 확인 check.names, # 논리값. 문자형 벡터의 factor 형 강제 변환 여부 stringsAsFactors, ) 데이터 프레임 생성 예시: 모 병원에서 얻은 환자의 인구학적 정보 id &lt;- c(1:10) sex &lt;- rep(c(&quot;Female&quot;, &quot;Male&quot;), each = 5) age &lt;- c(34, 22, 54, 43, 44, 39, 38, 28, 31, 42) sbp &lt;- c(112, 118, 132, 128, 128, 124, 121, 119, 124, 109) height &lt;- c(165, 158, 161, 160, 168, 172, 175, 182, 168, 162) weight &lt;- c(52, 48, 59, 60, 48, 72, 73, 82, 64, 60) df &lt;- data.frame(id, sex, age, sbp, height, weight, stringsAsFactors = FALSE) df attributes(df); str(df); summary(df) $names [1] &quot;id&quot; &quot;sex&quot; &quot;age&quot; &quot;sbp&quot; &quot;height&quot; &quot;weight&quot; $class [1] &quot;data.frame&quot; $row.names [1] 1 2 3 4 5 6 7 8 9 10 &#39;data.frame&#39;: 10 obs. of 6 variables: $ id : int 1 2 3 4 5 6 7 8 9 10 $ sex : chr &quot;Female&quot; &quot;Female&quot; &quot;Female&quot; &quot;Female&quot; ... $ age : num 34 22 54 43 44 39 38 28 31 42 $ sbp : num 112 118 132 128 128 124 121 119 124 109 $ height: num 165 158 161 160 168 172 175 182 168 162 $ weight: num 52 48 59 60 48 72 73 82 64 60 id sex age sbp Min. : 1.00 Length:10 Min. :22.00 Min. :109.0 1st Qu.: 3.25 Class :character 1st Qu.:31.75 1st Qu.:118.2 Median : 5.50 Mode :character Median :38.50 Median :122.5 Mean : 5.50 Mean :37.50 Mean :121.5 3rd Qu.: 7.75 3rd Qu.:42.75 3rd Qu.:127.0 Max. :10.00 Max. :54.00 Max. :132.0 height weight Min. :158.0 Min. :48.00 1st Qu.:161.2 1st Qu.:53.75 Median :166.5 Median :60.00 Mean :167.1 Mean :61.80 3rd Qu.:171.0 3rd Qu.:70.00 Max. :182.0 Max. :82.00 # stringsAsFactors = TRUE 인 경우 sex의 summary() 결과 df &lt;- data.frame(id, sex, age, sbp, height, weight, stringsAsFactors = TRUE) summary(df) id sex age sbp height Min. : 1.00 Female:5 Min. :22.00 Min. :109.0 Min. :158.0 1st Qu.: 3.25 Male :5 1st Qu.:31.75 1st Qu.:118.2 1st Qu.:161.2 Median : 5.50 Median :38.50 Median :122.5 Median :166.5 Mean : 5.50 Mean :37.50 Mean :121.5 Mean :167.1 3rd Qu.: 7.75 3rd Qu.:42.75 3rd Qu.:127.0 3rd Qu.:171.0 Max. :10.00 Max. :54.00 Max. :132.0 Max. :182.0 weight Min. :48.00 1st Qu.:53.75 Median :60.00 Mean :61.80 3rd Qu.:70.00 Max. :82.00 summary() 함수는 객체의 클래스에 따라 요약 통계량을 출력해주는 함수 데이터 프레임이 가지고 있는 변수들의 특징을 손쉽게 알아볼 수 있기 때문에 가장 많이 호출되는 함수 중 하나 숫자형 벡터: 최솟값(minimum), 1/4 분위수(1st quantile), 중앙값(median), 평균(mean), 3/4 분위수(3rd quantile), 최댓값을 출력 요인형 객체: 요인의 각 수준 별 빈도를 출력 2차원 이상 table() 객체에 적용 시 \\(\\chi^2\\) 검정(독립성 검정) 결과값을 출력함. 이미 정의된 데이터 프레임에 데이터를 추가 가능 예를 들어 dbp라는 벡터에 이완기 혈압(diastolic blood pressure) 데이터가 입력되어 있고 df에 dbp 변수를 새롭게 추가 시 df$dbp &lt;- x 형태로 추가 위 형태로 이미 존재하고 있는 변수(열)에 새로운 값 재할당 가능 이러한 형태로 문자형 벡터 추가 시 문자형 벡터는 자동으로 factor로 형 변환 되지는 않음 x &lt;- 1:nrow(df) dbp &lt;- c(73, 70, 88, 82, 75, 77, 74, 81, 72, 64) # df에 &quot;dbp&quot; 열을 생성하고 x 값 대입 df$dbp &lt;- x df # df의 dbp에 dbp 벡터의 값을 재할당 df$dbp &lt;- dbp df # df에 운동여부 exercyn 라는 변수 추가 # exercyn 는 &quot;Y&quot; 또는 &quot;N&quot; 두 값을 가짐 df$exercyn &lt;- c(&quot;Y&quot;, &quot;Y&quot;, &quot;N&quot;, &quot;Y&quot;, &quot;N&quot;, &quot;N&quot;, &quot;N&quot;, &quot;Y&quot;, &quot;N&quot;, &quot;Y&quot;) str(df) &#39;data.frame&#39;: 10 obs. of 8 variables: $ id : int 1 2 3 4 5 6 7 8 9 10 $ sex : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 1 1 1 1 2 2 2 2 2 $ age : num 34 22 54 43 44 39 38 28 31 42 $ sbp : num 112 118 132 128 128 124 121 119 124 109 $ height : num 165 158 161 160 168 172 175 182 168 162 $ weight : num 52 48 59 60 48 72 73 82 64 60 $ dbp : num 73 70 88 82 75 77 74 81 72 64 $ exercyn: chr &quot;Y&quot; &quot;Y&quot; &quot;N&quot; &quot;Y&quot; ... 행렬 및 벡터에서 언급 되었던 rownames(), colnames(), names(), dim(), ncol()/NCOL(),nrow()/NROW() 함수 적용 가능 rownames(df); colnames(df); names(df) [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; [1] &quot;id&quot; &quot;sex&quot; &quot;age&quot; &quot;sbp&quot; &quot;height&quot; &quot;weight&quot; &quot;dbp&quot; [8] &quot;exercyn&quot; [1] &quot;id&quot; &quot;sex&quot; &quot;age&quot; &quot;sbp&quot; &quot;height&quot; &quot;weight&quot; &quot;dbp&quot; [8] &quot;exercyn&quot; dim(df); ncol(df); nrow(df) [1] 10 8 [1] 8 [1] 10 # rownames() 함수를 통해 행이름 변경 rownames(df) &lt;- letters[1:10] df #colnames() 함수를 통해 열 이름 변경 varname_orig &lt;- colnames(df) colnames(df) &lt;- paste0(&quot;V&quot;, 1:ncol(df)) df # names() 함수와 colnames()는 거의 동일한 기능 수행 # 두 함수의 차이점? names(df) [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;V4&quot; &quot;V5&quot; &quot;V6&quot; &quot;V7&quot; &quot;V8&quot; names(df) &lt;- varname_orig df 참고: R Markdown에서 데이터 프레임의 데이터를 손쉽게 테이블로 출력하는 방법(html 문서) R Markdwon의 YAML 부분에 다음과 같이 옵션을 추가하면 별다른 함수 처리 없이 데이터 프레임을 표 형태로 html 문서에 붙일 수 있음. 아래 예시에서 output 이후 df_print: paged 옵션을 추가 옵션 추가 시 들여쓰기(탭 구분)은 YAML 문서의 트리 구조를 표현한 것이기 때문에 꼭 들여쓰기를 정확히 일치시켜야 함 --- title: &quot;문서 제목&quot; author: &quot;이름&quot; date: &quot;`r Sys.Date()`&quot; output: html_document: df_print: paged --- 2.8.2 데이터 프레임 접근 및 필터링 접근방법 리스트 데이터 접근 방식 # 추출(접근) 연산자(함수) `df$col_name` 형태로 접근 df$height [1] 165 158 161 160 168 172 175 182 168 162 # df[[index]] 또는 df[[&quot;col_name&quot;]] 형태로 접근 df[[4]] [1] 112 118 132 128 128 124 121 119 124 109 df[[&quot;sex&quot;]] [1] Female Female Female Female Female Male Male Male Male Male Levels: Female Male w &lt;- df[[4]] attributes(w); str(w) NULL num [1:10] 112 118 132 128 128 124 121 119 124 109 # df[index] 또는 df[&quot;col_name&quot;] 형태로 접근 h &lt;- df[&quot;height&quot;] attributes(h); str(h) $names [1] &quot;height&quot; $row.names [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; $class [1] &quot;data.frame&quot; &#39;data.frame&#39;: 10 obs. of 1 variable: $ height: num 165 158 161 160 168 172 175 182 168 162 행렬 데이터 접근 방식 # df[idx_row, idx_col] 또는 df[row_name, col_name] # 형태 데이터 접근 # 열 index 접근 df[, 3]; [1] 34 22 54 43 44 39 38 28 31 42 # 형 강제 변환 방지 df[, 3, drop = FALSE] # 행 index 접근 df[8, ] # 행과 열 index 접근 df[1:4, 5:6] # 열 이름으로 접근 df[, c(&quot;sex&quot;, &quot;sbp&quot;)] # 행 이름으로 접근 df[c(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;), ] # 행과 열 이름으로 접근 df[c(&quot;a&quot;, &quot;f&quot;), c(&quot;sex&quot;, &quot;height&quot;, &quot;dbp&quot;)] # 행 또는 열 제외 df[-c(2:6), ] df[-c(1, 5:7), -c(1, 8)] 필터링 벡터, 행렬과 마찬가지로 비교 연산자를 이용해 조건에 맞는 부분 데이터 추출 가능 # %in% 연산자를 이용해 데이터 프레임의 부분 변수 추출 # id, age 열을 제외한 나머지 데이터 프레임 추출 varname_df &lt;- names(df) df[, !varname_df %in% c(&quot;id&quot;, &quot;age&quot;)] # 조건 연산자 사용 # sex 가 Female이고 나이가 40 이상인 데이터 추출 df[df$sex == &quot;Female&quot; &amp; df$age &gt;= 40, ] # id가 3보다 작은 데이터 추출 df[df[, 1] &lt; 3, ] # subset 함수 이용한 데이터 추출 # sbp 가 120 이상이고 dbp 가 80 이상인 데이터 추출 subset(df, sbp &gt;= 120 &amp; dbp &gt;= 80) # 성별, 수축기, 이완기 혈압 변수만 추출 subset(df, select = c(sex, sbp, dbp)) # id 변수 제거 subset(df, select = -c(id)) 데이터 프레임 또는 리스트 접근 시 df$col_name 를 사용한다면 매번 데이터 프레임 이름과 $을 반복하기 때문에 코드가 불필요하게 복잡해짐. R에서는 데이터 프레임 내부의 열 이름을 직접 접근할 수 있도록 도와주는 몇 가지 함수(예: with(), attach() 등)가 있는데, with()와 within() 활용법에 대해 간략히 알아봄. 위 예제에서 sex 가 Female이고 나이가 40 이상인 데이터 추출한다고 했을 때 with() 함수 사용 # with() 함수: 데이터 환경(객체 내)에서 주어진 표현식의 결과를 반환 with( data, #리스트 또는 데이터 프레임 expr, # 실제 명령을 수행할 표현식, ) with(df, df[sex == &quot;Female&quot; &amp; age &gt;= 40, ]) within() 함수는 with()와 유사하지만 코드블록({...})을 이용해 보다 자유롭게 데이터를 수정 및 추가할 수 있음 df2 &lt;- within(df, { hospital &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;) mean_age &lt;- mean(age) }) 2.8.3 데이터 프레임 관련 함수 유틸리티 함수 보통 데이터 분석은 외부에서 데이터를 읽은 후 특정 객체에 읽어온 데이터를 할당하는데, 이 경우 데이터가 저장된 객체는 대부분은 데이터 프레임 형태임. 읽어온 데이터는 보통 많은 행(표본)으로 구성되어 있기 때문에 데이터를 손쉽게 살펴보는 방법이 필요 head()/tail() 함수 객체(벡터, 행렬, 테이블, 데이터 프레임 등)의 처음 또는 끝에서 부터 몇 개의 데이터(default = 6L) 를 순차적으로 보여줌 # 앞에서 불러온 전복 데이터셋 확인 dim(abalone) [1] 4177 9 #처음 1에서 6행 까지 데이터 출력 head(abalone) # 제일 마지막 행부터 위로 6개 데이터 까지 출력 tail(abalone) View() 함수 2차원 데이터의 readble 한 스프레드시트 제공 View(abalone) 데이터 프레임 결합 및 분리 함수 rbind()/cbind() 함수 행렬에서 사용한 rbind()/cbind()를 데이터 프레임에도 적용 가능 a = data.frame(x1 = rep(0,5), x2 = rep(&quot;x&quot;,5)) b = data.frame(x1 = rep(1,5), x2 = rep(&quot;d&quot;,5)) c = data.frame(x3 = rep(2,5), x4 = rep(&quot;z&quot;,5)) d &lt;- list(1, &quot;d&quot;) e &lt;- list(x5 = rep(4, 5), x6 = rep(&quot;y&quot;, 5)) # rbind()를 이용해 두 데이터 프레임 a-b 합치기 ab &lt;- rbind(a, b) ab # 변수명이 다른 경우 rbind(a, c) #변수명이 다르기때문에 행으로 묶을 수 없다. Error in match.names(clabs, names(xi)): 이전에 사용된 이름들과 일치하지 않습니다. # rbind()를 이용해 데이터 프레임-리스트 합치기 abd &lt;- rbind(ab, d) abd # cbind()를 이용해 두 데이터 프레임 a-c 합치기 ac &lt;- cbind(a, c) ac # 행 길이가 다르면 작은 길이의 데이터를 재사용 cbind(a, d) # cbind()를 이용해 두 데이터 프레임-리스트 합치기 ace &lt;- cbind(ac, e) merge() 함수 두 데이터 프레임을 공통된 값을 기준으로 병합 Excel의 vlookup() 함수 또는 데이터베이스 SQL 쿼리 중 join과 동일한 역할을 함 cbind()의 경우는 단순히 열을 합치는 것이지만 merge()는 공통되는 열을 기준으로 두 데이터셋을 병합 공통된 데이터가 있을 때만 데이터 병합 수행 # merge() 함수 인수 merge( x, # 병합할 데이터 프레임 y, # 병합할 데이터 프레임 by, # 병합 기준으로 사용할 컬럼 (문자열 벡터) by.x, # 병합에 사용할 x와 y의 열 이름이 다른 경우 by.y, # by.x와 by.y에 각각 공통 데이터에 해당하는 열 이름 지정 # 둘 다 문자형 스칼라 또는 벡터값 인수로 받음 all, # 논리값 이순 # TRUE인 경우 x, y 중 공통된 값을 갖는 행이 없을 때 # 해당 쪽을 NA를 채워 병합 # 결과적으로 x, y 전체 행이 결과에 포함 all.x, # x,y 중 특정 쪽에 공통된 값이 없더라도 항상 all.y, # 결과에 포함 ) merge() 함수 예시 d1 = data.frame(Name = c(&quot;Park&quot;, &quot;Hanzo&quot;, &quot;Mercy&quot;, &quot;Soldier76&quot; ), country = c(&quot;Korea&quot;, &quot;Japan&quot;, &quot;Swiss&quot;, &quot;USA&quot;)) d2 = data.frame(Age = c(19,38,37,56,31), Name = c(&quot;Park&quot;, &quot;Hanzo&quot;, &quot;Mercy&quot;, &quot;Soldier76&quot;,&quot;Mei&quot; ) ) d1; d2 dim(d1); dim(d2) [1] 4 2 [1] 5 2 # 두 데이터 병합 01 merge(d1, d2, by = &quot;Name&quot;) # 두 데이터 병합 02 names(d2)[2] &lt;- &quot;Surname&quot; merge(d1, d2, by.x = &quot;Name&quot;, by.y = &quot;Surname&quot;) # 두 데이터 병합 03 merge(d1, d2, by.x = &quot;Name&quot;, by.y = &quot;Surname&quot;, all = T) split() 함수 Factor 형에서 언급한 split() 함수를 통해 그룹 별로 데이터 분할 분할된 데이터는 리스트에 저장 split(df, df$sex) $Female id sex age sbp height weight dbp exercyn a 1 Female 34 112 165 52 73 Y b 2 Female 22 118 158 48 70 Y c 3 Female 54 132 161 59 88 N d 4 Female 43 128 160 60 82 Y e 5 Female 44 128 168 48 75 N $Male id sex age sbp height weight dbp exercyn f 6 Male 39 124 172 72 77 N g 7 Male 38 121 175 73 74 N h 8 Male 28 119 182 82 81 Y i 9 Male 31 124 168 64 72 N j 10 Male 42 109 162 60 64 Y 데이터 정렬 함수 sort() 함수 데이터(벡터)의 정렬(오름차순 또는 내림차순) 결과 반환 # sort() 함수 인수 sort( x, # 정렬할 벡터 decreasing, # 논리값, 내림차순 여부 # default = FALSE na.last # 논리값. 결측 존재 시 NA 값 위치 지정 ) # TRUE: 정렬 후 결측은 마지막에 위치 # FALSE: 맨 처음 NA 위치 예시 # 오름차순 정렬 sort(df2$age) [1] 22 28 31 34 38 39 42 43 44 54 # 내림차순 정렬 sort(df$height, decreasing = TRUE) [1] 182 175 172 168 168 165 162 161 160 158 order() 함수 데이터 정렬을 위해 순서에 대한 색인 생성 결과 반환 데이터 프레임에서 특정 열 기준으로 데이터 정렬 시 주로 사용 # 나이 기준으로 오름차순으로 데이터 정렬 with(df, df[order(age), ]) # 키 순으로 내림차순 정렬 df[order(df$height, decreasing = T), ] 2.8.4 *apply() 계열 함수 apply(), lapply(), sapply() 등 apply 계열 함수는 R에서 가장 일반적으로 사용되는 함수 중 하나 반복문(for-loop)를 대신하기 위해 활용되며, R 객체를 입력 받아 원소 별 혹은 그루 별 함수를 적용 데이터 전체에 함수를 한번에 적용하는 vectorizing 연산을 수행함 apply() 함수 배열 또는 행렬에 주어진 함수를 적용한 뒤 그 결과를 벡터 또는 리스트로 반환 행 또는 열 차원 기준 함수 적용 동일한 유형의 벡터로 구성된 데이터셋에 적용 apply( X, # 배열, 행렬, 또는 같은 형태로 정의된 데이터 프레임 MARGIN, # MARGIN = 1: 행 기준 # MARGIN = 2: 열 기준 # MARGIN = c(1,2): 행과 열 방향 모두 FUN # 적용할 함수 ) 예시1: 행렬 및 배열 apply() 적용 X &lt;- matrix(1:9, nrow = 3) X [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 # 행 기준으로 합계 계산 apply(X, 1, sum) [1] 12 15 18 # 열 기준으로 합계 계산 apply(X, 2, sum) [1] 6 15 24 # 배열에 apply 적용 # 각 학생의 퀴즈와 중간-기말 각각 평균 계산 Z # 성적 , , 1 [,1] [,2] [1,] 75 65 [2,] 84 78 [3,] 93 92 , , 2 [,1] [,2] [1,] 82 88 [2,] 78 75 [3,] 85 88 apply(Z, c(1,2), mean) [,1] [,2] [1,] 78.5 76.5 [2,] 81.0 76.5 [3,] 89.0 90.0 # 각 시점 별 개별 학생의 퀴즈-중간, 퀴즈-기말 평균 계산 apply(Z, c(1, 3), mean) [,1] [,2] [1,] 70.0 85.0 [2,] 81.0 76.5 [3,] 92.5 86.5 예시2: 데이터 프레임 위에서 사용한 df와 2.7.1 요인(factor) 절에서 잠깐 예시로 사용된 전복(abalone) 데이터셋 사용 Abalone dataset 변수 설명(코드북) names(abalone) &lt;- c(&quot;sex&quot;, &quot;length&quot;, &quot;diameter&quot;, &quot;height&quot;, &quot;whole.wt&quot;, &quot;shucked.wt&quot;, &quot;viscera.wt&quot;, &quot;shell.wt&quot;, &quot;rings&quot;) head(abalone) # sex를 제외한 나머지 수치형 변수에 대한 기초통계량 계산 # 평균: mean() 함수 사용 apply(abalone[, -1], 2, mean) length diameter height whole.wt shucked.wt viscera.wt shell.wt 0.5239921 0.4078813 0.1395164 0.8287422 0.3593675 0.1805936 0.2388309 rings 9.9336845 # 표준편차: sd() 함수 사용 apply(abalone[, -1], 2, sd) length diameter height whole.wt shucked.wt viscera.wt shell.wt 0.12009291 0.09923987 0.04182706 0.49038902 0.22196295 0.10961425 0.13920267 rings 3.22416903 # 개별 전복에 대해 내장, 육질, 껍질 무게 합계 계산 apply(abalone[, c(&quot;shucked.wt&quot;, &quot;viscera.wt&quot;, &quot;shell.wt&quot;)], 1, sum) -&gt; ab_wt_sum head(ab_wt_sum, 10) [1] 0.4755 0.2180 0.6080 0.4845 0.1840 0.3385 0.7085 0.7035 0.4940 0.7855 # 데이터에 결측이 포함된 경우 # diameter 변수에 10개의 결측을 임의 생성 set.seed(20200410) idx &lt;- sample(1:NROW(abalone), 10) # 비복원 추출 ab2 &lt;- abalone ab2[idx, 3] &lt;- NA # 성별 제외한 나머지 변수의 평균 계산 apply(ab2[, -1], 2, mean) length diameter height whole.wt shucked.wt viscera.wt shell.wt 0.5239921 NA 0.1395164 0.8287422 0.3593675 0.1805936 0.2388309 rings 9.9336845 # NA 결과를 피하려면? apply(ab2[, -1], 2, mean, na.rm = TRUE) length diameter height whole.wt shucked.wt viscera.wt shell.wt 0.5239921 0.4079578 0.1395164 0.8287422 0.3593675 0.1805936 0.2388309 rings 9.9336845 참고 1: 결측이 포함된 벡터 연산 시 결측에 대한 처리 지정 없이 함수를 적용하면 결측값을 반환 R에서 제공되는 연산 관련 일반 함수는 결측처리에 대한 옵션을 인수로 받음 보통 인수 형태는 na.rm = T/F 형태이고 다음의 함수를 통해 데이터에 결측 처리에 대한 속성 및 클래스를 부여함 na.omit()/na.exclude(): NA가 포함되어 있는 행 생략 위 두 함수는 기본적으로 동일하지만, 특정 함수(예: 회귀분석을 수행하는 lm()) 함수에서는 다른 결과를 출력 참고 2: 위 예제에서 보여준 행 또는 열의 합 또는 평균 계산은 매우 자주 사용되기 때문에 rowSums(), colSums(), rowMeans(), colMeans() 함수가 제공됨 colMeans(abalone[,-1]) # apply 결과와 비교 length diameter height whole.wt shucked.wt viscera.wt shell.wt 0.5239921 0.4078813 0.1395164 0.8287422 0.3593675 0.1805936 0.2388309 rings 9.9336845 tapply() 함수 2.7.1 요인(factor) 절에서 설명 tapply()는 1개의 벡터를 대상으로만 함수를 호출 데이터 프레임에 적용하려면? \\(\\rightarrow\\) aggregate() 함수 사용 aggregate() 데이터를 특정 factor의 수준 별로 나눈 후, 각 그룹마다 함수 적용 aggregate()는 다음 두 가지 형태로 함수 적용 가능 # aggregate() 기본 인수 aggregate( x, # R 객체, 주로 데이터 프레임 by, # 그룹으로 묶을 값의 리스트 FUN, # 그룹별 적용할 함수 ) aggregate( formula, # y ~ x 형태로 y는 계산에 사용할 값 # x는 group 변수 # y 대신 .은 그룹 변수를 제외하고 # 적용할 함수의 대상이 되는 모든 변수 data, # formula를 적용할 데이터 FUN # 적용할 함수 ) 예시: 임상연구 자료(df) # 성별에 따라 연속형 변수의 평균 계산 aggregate(df[,-c(1:2, 8)], by =df[&quot;sex&quot;], mean) # 수식 표현형 사용 aggregate(. ~ sex, data = df[,-8], mean) # 요인이 2개인 경우 aggregate(df[,-c(1:2, 8)], by = list(sex = df[[&quot;sex&quot;]], exercise = df[[&quot;exercyn&quot;]]), mean) aggregate(. ~ sex + exercyn, data = df[,-1], mean) lapply() 함수 특정 함수를 벡터, 리스트, 데이터 프레임 등에 적용하고 그 결과를 리스트로 반환 lapply( X, #벡터, 리스트, 표현식, 또는 데이터 프레임 FUN, # 적용할 함수 ) -예시: abalone 데이터를 사용해 일변량 회귀분석 실시 # abalone 데이터를 이용해 단순회귀분석 결과 출력 # 종속변수: rings # 설명변수: 성별을 제외한 모든 연속형 변수 # lm() 함수를 이용한 일변량 회귀분석 실시 univ_reg &lt;- lapply(abalone[,-c(1, 9)], function(x) lm(abalone$rings ~ x)) # univ_reg # 위 객체로부터 회귀모형 요약 통계량 결과 summ_reg &lt;- lapply(univ_reg, summary) # summ_reg # 추정 회귀계수를 데이터로 저장 ## summary(lm_object)의 속성 파악 str(summ_reg[[1]]) List of 11 $ call : language lm(formula = abalone$rings ~ x) $ terms :Classes &#39;terms&#39;, &#39;formula&#39; language abalone$rings ~ x .. ..- attr(*, &quot;variables&quot;)= language list(abalone$rings, x) .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 .. .. .. ..$ : chr [1:2] &quot;abalone$rings&quot; &quot;x&quot; .. .. .. ..$ : chr &quot;x&quot; .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;x&quot; .. ..- attr(*, &quot;order&quot;)= int 1 .. ..- attr(*, &quot;intercept&quot;)= int 1 .. ..- attr(*, &quot;response&quot;)= int 1 .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: 0x5590180c0268&gt; .. ..- attr(*, &quot;predvars&quot;)= language list(abalone$rings, x) .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;abalone$rings&quot; &quot;x&quot; $ residuals : Named num [1:4177] 6.0975 -0.3331 -1.0235 1.3217 -0.0342 ... ..- attr(*, &quot;names&quot;)= chr [1:4177] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... $ coefficients : num [1:2, 1:4] 2.102 14.946 0.186 0.345 11.328 ... ..- attr(*, &quot;dimnames&quot;)=List of 2 .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;x&quot; .. ..$ : chr [1:4] &quot;Estimate&quot; &quot;Std. Error&quot; &quot;t value&quot; &quot;Pr(&gt;|t|)&quot; $ aliased : Named logi [1:2] FALSE FALSE ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;x&quot; $ sigma : num 2.68 $ df : int [1:3] 2 4175 2 $ r.squared : num 0.31 $ adj.r.squared: num 0.31 $ fstatistic : Named num [1:3] 1875 1 4175 ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;value&quot; &quot;numdf&quot; &quot;dendf&quot; $ cov.unscaled : num [1:2, 1:2] 0.0048 -0.0087 -0.0087 0.0166 ..- attr(*, &quot;dimnames&quot;)=List of 2 .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;x&quot; .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;x&quot; - attr(*, &quot;class&quot;)= chr &quot;summary.lm&quot; summ_reg[[1]]$coefficients Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 2.101883 0.1855477 11.32800 2.544353e-29 x 14.946411 0.3451570 43.30323 0.000000e+00 # summ_reg에서 coefficients만 추출 res &lt;- lapply(summ_reg, function(lst) lst$coefficients) res $length Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 2.101883 0.1855477 11.32800 2.544353e-29 x 14.946411 0.3451570 43.30323 0.000000e+00 $diameter Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 2.318574 0.1727366 13.42260 3.01241e-40 x 18.669921 0.4114954 45.37091 0.00000e+00 $height Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 3.938464 0.1442530 27.30248 3.678478e-151 x 42.971441 0.9904086 43.38759 0.000000e+00 $whole.wt Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 6.989239 0.08244313 84.77648 0.000000e+00 x 3.552909 0.08561680 41.49780 1.888678e-315 $shucked.wt Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 7.736643 0.0861330 89.82206 0.000000e+00 x 6.113633 0.2039254 29.97976 5.087464e-179 $viscera.wt Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 7.257427 0.08306853 87.36674 0.000000e+00 x 14.819227 0.39322428 37.68645 8.574726e-268 $shell.wt Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 6.462117 0.07714642 83.76431 0 x 14.535675 0.27908233 52.08382 0 # res 결과를 2차원 배열 형태로 변환 # do.call() 함수 사용 # 리스트로 주어진 인자에 함수를 적용하여 결과 반환 res &lt;- do.call(rbind, res) res Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 2.101883 0.18554766 11.32800 2.544353e-29 x 14.946411 0.34515697 43.30323 0.000000e+00 (Intercept) 2.318574 0.17273658 13.42260 3.012410e-40 x 18.669921 0.41149538 45.37091 0.000000e+00 (Intercept) 3.938464 0.14425297 27.30248 3.678478e-151 x 42.971441 0.99040860 43.38759 0.000000e+00 (Intercept) 6.989239 0.08244313 84.77648 0.000000e+00 x 3.552909 0.08561680 41.49780 1.888678e-315 (Intercept) 7.736643 0.08613300 89.82206 0.000000e+00 x 6.113633 0.20392536 29.97976 5.087464e-179 (Intercept) 7.257427 0.08306853 87.36674 0.000000e+00 x 14.819227 0.39322428 37.68645 8.574726e-268 (Intercept) 6.462117 0.07714642 83.76431 0.000000e+00 x 14.535675 0.27908233 52.08382 0.000000e+00 sapply() 힘수 lapply() 함수와 유사하나(lapply()의 wrapper 함수), 결과를 벡터 또는 행렬로 반환하는 점에서 차이를 보임 예시: 회귀분석 # 각 변수별 회귀계수(절편항과 설명변수) 반환 univ_reg2 &lt;- sapply(abalone[,-c(1, 9)], function(x) { coef(lm(abalone$rings ~ x)) # lm 클래스에서 회귀계수 반환 }) univ_reg2 length diameter height whole.wt shucked.wt viscera.wt (Intercept) 2.101883 2.318574 3.938464 6.989239 7.736643 7.257427 x 14.946411 18.669921 42.971441 3.552909 6.113633 14.819227 shell.wt (Intercept) 6.462117 x 14.535675 attributes(univ_reg2) # 행렬 반환 $dim [1] 2 7 $dimnames $dimnames[[1]] [1] &quot;(Intercept)&quot; &quot;x&quot; $dimnames[[2]] [1] &quot;length&quot; &quot;diameter&quot; &quot;height&quot; &quot;whole.wt&quot; &quot;shucked.wt&quot; [6] &quot;viscera.wt&quot; &quot;shell.wt&quot; # as.data.frame(univ_reg2) mapply() 함수 sapply()와 유사하지만 다수의 인수를 함수에 전달해 적용 임의의 함수 FUN()이 있고, FUN()을 수행하기 위해 필요한 인수가 데이터로 저장되어 있을 때 이를 불러들여 함수를 적용 mapply( FUN, # 적용할 함수 ..., # 적용할 인수 ) 난수 생성 예시: rnorm() 함수 사용 rnorm(n, mean, sd): 평균이 mean이고 표준편차가 sd인 정규분포에서 n개의 난수 생성 # 평균이 각각 0, 1, 2, 4 이고 # 표준편차가 1, 1, 1, 1 인 정규난수를 # 각각 20, 40, 60, 100 개 생성 rn_res &lt;- mapply(rnorm, c(20, 40, 60, 100), c(0:2, 4), rep(1, 4)) # rn_res # 생성한 난수의 평균과 표준편차 확인 sapply(rn_res, mean); sapply(rn_res, sd) [1] 0.1277941 0.8607565 1.9070456 3.9012846 [1] 0.8954115 0.7916029 0.9990486 0.9088889 "],["is-as-function.html", "2.9 객체의 유형 판별 및 변환", " 2.9 객체의 유형 판별 및 변환 지금까지 R 객체를 알아보면서 is.na(), is.null() 등 스칼라의 데이터 타입을 확인하는 함수부터 str(), attributes(), class()와 같이 객체의 속성 및 구조에 대해 확인하는 함수들에 대해 간략히 소개함. R은 스크립트 언어이기 때문에 모든 명령 실행이 함수 기반으로 이루어짐. 특정 객체에만 적용할 수 있는 함수들이 있는 반면, 함수를 통해 새로운 속성을 갖는 객체가 생성되기도 함. 그렇기 때문에 함수 적용 또는 반환 후 생성된 객체의 타입을 확인하거나 객체의 유형을 변환하는 작업은 R에서 데이터 분석을 진행하는 과정에서 빈번하게 발생함. 객체 유형 판별을 위해 is.type_name(), 객체 타입 변환을 위해 as.type_name() 형태의 함수를 제공함. 지금까지 배운 R 객체에 대한 is. 과 as. 계열 함수는 아래와 같음. Table 2.7: R 객체 타입 판별 및 변환 함수 is 계열 함수 as 계열 함수 설명 is.factor() as.factor() 주어진 객체가 factor 형인지 판단/변환 is.ordered() as.ordered 주어진 객체가 순서형 factor인지 판단/변환 is.numeric() as.numeric() 주어진 객체가 수치형인지 판단/변환 is.character() as.character() 주어진 객체가 문자형인지 판단/변환 is.matrix() as.matrix() 주어진 객체가 행렬인지 판단/변환 is.array() as.array() 주어진 객체가 배열인지 판단/변환 is.list() as.list() 주어진 객체가 리스트인지 판단/변환 is.data.frame() as.data.frame() 주어진 객체가 데이터 프레임인지 판단/변환 is/as계열 함수 사용 예시 x &lt;- c(&quot;M&quot;, &quot;F&quot;); f &lt;- factor(x) # x가 문자열인가? is.character(x) [1] TRUE # f가 factor인가? is.factor(f) [1] TRUE #f가 숫자형인가? is.numeric(f) [1] FALSE # f를 수치형으로 변환 f &lt;- as.numeric(f) is.numeric(f) [1] TRUE f [1] 2 1 # 다시 f를 factor형으로 변환 as.factor(f) [1] 2 1 Levels: 1 2 2차원 데이터 객체 유형 판별 및 변환 X &lt;- matrix(rnorm(9), 3) d &lt;- data.frame(group = rep(LETTERS[1:3], each = 2), meas = c(mapply(rnorm, c(2, 2, 2), c(1, 2, 3), c(1, 1, 1)))) # 객체 유형 확인 is.matrix(X); is.data.frame(X) [1] TRUE [1] FALSE is.matrix(d); is.data.frame(d) [1] FALSE [1] TRUE # 객체 유형 변환 as.data.frame(X); as.matrix(d) group meas [1,] &quot;A&quot; &quot;2.028870&quot; [2,] &quot;A&quot; &quot;1.996936&quot; [3,] &quot;B&quot; &quot;2.835169&quot; [4,] &quot;B&quot; &quot;1.105901&quot; [5,] &quot;C&quot; &quot;1.095014&quot; [6,] &quot;C&quot; &quot;2.927883&quot; as.list(X); as.list(d) [[1]] [1] 0.3288415 [[2]] [1] 0.2479955 [[3]] [1] -0.7521625 [[4]] [1] -0.02180829 [[5]] [1] 1.354002 [[6]] [1] -0.1578651 [[7]] [1] -0.3734678 [[8]] [1] -2.285178 [[9]] [1] -1.143963 $group [1] &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;C&quot; &quot;C&quot; $meas [1] 2.028870 1.996936 2.835169 1.105901 1.095014 2.927883 "],["string-regexp.html", "3 문자열 처리와 정규표현식", " 3 문자열 처리와 정규표현식 학습 목표 텍스트 문자 처리에 있어 가장 기본인 정규 표현식(regular rexpression)에 대해 알아본다. R에서 기본으로 제공하는 문자열 차리 함수에 대해 알아본다 학습 필요성 실제 데이터는 다양한 형태의 텍스트(문자열)을 포함 R에서 문자열을 이용한 반복 계산 가능 대규모 텍스트 데이터(웹문서, 블로그, SNS, 뉴스, 논문, 상품평, …)로부터 새로운 정보 및 지식을 도출하기 위한 텍스트 처리에 대한 기본적 이해 여러 문자열로 이루어진 방대한 텍스트 벡터에서 특정 패턴을 갖고 있는 구문을 선별해야 할 경우, 패턴을 도식화 할 수 있는 함축적 표현 필요 \\(\\rightarrow\\) 정규 표현식 정규 표현식의 기본함수 grep(), grepl(): 문자형 벡터에서 정규 표현식 또는 문자 패턴의 일치를 검색. grep(): 일치하는 특정 문자열을 포함하는 문자형 벡터 또는 인덱스를 반환 grepl(): 문자열 포함 여부에 대한 논리값 반환 regexpr(), gregexpr(): 문자형 벡터에서 정규 표현식 또는 문자열 패턴과 일치하는 원소를 검색하고, 일치가 시작되는 문자열의 인덱스와 일치 길이를 반환 sub(), gsub(): 문자열 벡터에서 정규 표현식 또는 문자열 패턴과 일치하는 원소를 검색하고 해당 문자열을 다른 문자열로 변경 regexec(): regexpr()와 동일하게 일치가 시작되는 문자열의 인덱스를 반환하지만 괄호로 묶인 하위 표현식의 위치를 추가로 반환 정규 표현식 및 문자열 처리를 위한 함수의 종류는 매우 다양하지만, 본 강의에서는 정규 표현식의 이해를 위해 일부만 소개할 것임 문자열 기초 탈출 지시자(escape indicator): \\ 키보드로 입력할 수 없는 문자를 입력하기 위해 사용 문자열에 백슬래쉬 \\를 입력하려면 \\\\로 표시 # 문자열에 따옴표(single of double quote, &#39;, &quot;) 입력 double_quote &lt;- &quot;\\&quot;&quot; double_quote [1] &quot;\\&quot;&quot; single_quote &lt;- &#39;\\&#39;&#39; single_quote [1] &quot;&#39;&quot; x &lt;- c(&quot;\\&quot;&quot;, &quot;\\\\&quot;, &#39;\\&#39;&#39;) writeLines(x) &quot; \\ &#39; # 백슬레쉬가 포함된 문자열 x &lt;- &quot;abc\\n\\tabc&quot; # \\n: Enter # \\t: tab 문자를 표현 writeLines(x) abc abc # 특수문자 표현 x &lt;- &quot;\\u00b5&quot; # 그리스 문자 mu 표현 (유니코드) x [1] &quot;µ&quot; 참고자료 Youtube 동영상: 영어 강의가 옥의 티… regexr.com: 정규 표현식의 패턴 확인 가능 Wikibooks R programming: Text processing "],["유용한-문자열-관련-함수.html", "3.1 유용한 문자열 관련 함수", " 3.1 유용한 문자열 관련 함수 3.1.1 nchar() 인간이 눈으로 읽을 수 있는 문자의 개수(길이)를 반환 공백, 줄바꿈 표시자(예: \\n)도 하나의 문자 개수로 인식 한글의 한 글자는 2 바이트(byte)지만 한 글자로 인식 \\(\\rightarrow\\) byte 단위 반환 가능 # 문자열을 구성하는 문자 개수 반환 nchar( x, # 문자형 벡터 type # &quot;bytes&quot;: 바이트 단위 길이 반환 # &quot;char&quot;: 인간이 읽을 수 있는 글자 길이 반환 # &quot;width&quot;: 문자열이 표현된 폭의 길이 반환 ) 예시 x &lt;- &quot;Carlos Gardel&#39;s song: Por Una Cabeza&quot; nchar(x) [1] 36 y &lt;- &quot;abcde\\nfghij&quot; nchar(y) [1] 11 z &lt;- &quot;양준일: 가나다라마바사&quot; nchar(z) [1] 12 # 문자열 벡터 str &lt;- sentences[1:10] nchar(str) [1] 42 43 38 40 36 37 43 43 35 40 s &lt;- c(&quot;abc&quot;, &quot;가나다&quot;, &quot;1234[]&quot;, &quot;R programming\\n&quot;, &quot;\\&quot;R\\&quot;&quot;) nchar(s, type = &quot;char&quot;) [1] 3 3 6 14 3 nchar(s, type = &quot;byte&quot;) [1] 3 9 6 14 3 nchar(s, type = &quot;width&quot;) [1] 3 6 6 13 3 백터의 원소 개수를 반환하는 length() 함수와는 다름. 3.1.2 paste(), paste0() 하나 이상의 문자열을 연결하여 하나의 문자열로 만들어주는 함수 Excel의 문자열 연결자인 &amp;와 거의 동일한 기능을 수행 paste( ..., # 한 개 이상의 R 객체. 강제로 문자형 변환 sep # 연결 구분자: 디폴트 값은 공백(&quot; &quot;) collapse # 묶을 객체가 하나의 문자열 벡터인 경우 # 모든 원소를 collapse 구분자로 묶은 길이가 1인 벡터 반환 ) paste0()은 paste()의 wrapper 함수이고 paste()의 구분자 인수 sep = \"\" 일 때와 동일한 결과 반환 예시 i &lt;- 1:length(letters) paste(letters, i) # sep = &quot; &quot; [1] &quot;a 1&quot; &quot;b 2&quot; &quot;c 3&quot; &quot;d 4&quot; &quot;e 5&quot; &quot;f 6&quot; &quot;g 7&quot; &quot;h 8&quot; &quot;i 9&quot; &quot;j 10&quot; [11] &quot;k 11&quot; &quot;l 12&quot; &quot;m 13&quot; &quot;n 14&quot; &quot;o 15&quot; &quot;p 16&quot; &quot;q 17&quot; &quot;r 18&quot; &quot;s 19&quot; &quot;t 20&quot; [21] &quot;u 21&quot; &quot;v 22&quot; &quot;w 23&quot; &quot;x 24&quot; &quot;y 25&quot; &quot;z 26&quot; paste(letters, i, sep = &quot;_&quot;) # sep = &quot;-&quot; [1] &quot;a_1&quot; &quot;b_2&quot; &quot;c_3&quot; &quot;d_4&quot; &quot;e_5&quot; &quot;f_6&quot; &quot;g_7&quot; &quot;h_8&quot; &quot;i_9&quot; &quot;j_10&quot; [11] &quot;k_11&quot; &quot;l_12&quot; &quot;m_13&quot; &quot;n_14&quot; &quot;o_15&quot; &quot;p_16&quot; &quot;q_17&quot; &quot;r_18&quot; &quot;s_19&quot; &quot;t_20&quot; [21] &quot;u_21&quot; &quot;v_22&quot; &quot;w_23&quot; &quot;x_24&quot; &quot;y_25&quot; &quot;z_26&quot; paste0(letters, i) # paste(letters, i, sep = &quot;&quot;) 동일 [1] &quot;a1&quot; &quot;b2&quot; &quot;c3&quot; &quot;d4&quot; &quot;e5&quot; &quot;f6&quot; &quot;g7&quot; &quot;h8&quot; &quot;i9&quot; &quot;j10&quot; &quot;k11&quot; &quot;l12&quot; [13] &quot;m13&quot; &quot;n14&quot; &quot;o15&quot; &quot;p16&quot; &quot;q17&quot; &quot;r18&quot; &quot;s19&quot; &quot;t20&quot; &quot;u21&quot; &quot;v22&quot; &quot;w23&quot; &quot;x24&quot; [25] &quot;y25&quot; &quot;z26&quot; # collapse 인수 활용 paste(letters, collapse = &quot;&quot;) [1] &quot;abcdefghijklmnopqrstuvwxyz&quot; writeLines(paste(str, collapse = &quot;\\n&quot;)) The birch canoe slid on the smooth planks. Glue the sheet to the dark blue background. It&#39;s easy to tell the depth of a well. These days a chicken leg is a rare dish. Rice is often served in round bowls. The juice of lemons makes fine punch. The box was thrown beside the parked truck. The hogs were fed chopped corn and garbage. Four hours of steady work faced us. Large size in stockings is hard to sell. # 3개 이상 객체 묶기 paste(&quot;Col&quot;, 1:2, c(TRUE, FALSE, TRUE), sep =&quot; &quot;, collapse = &quot;&lt;-&gt;&quot;) [1] &quot;Col 1 TRUE&lt;-&gt;Col 2 FALSE&lt;-&gt;Col 1 TRUE&quot; # paste 함수 응용 # 스트링 명령어 실행 exprs &lt;- paste(&quot;lm(mpg ~&quot;, names(mtcars)[3:5], &quot;, data = mtcars)&quot;) exprs [1] &quot;lm(mpg ~ disp , data = mtcars)&quot; &quot;lm(mpg ~ hp , data = mtcars)&quot; [3] &quot;lm(mpg ~ drat , data = mtcars)&quot; sapply(1:length(exprs), function(i) coef(eval(parse(text = exprs[i])))) [,1] [,2] [,3] (Intercept) 29.59985476 30.09886054 -7.524618 disp -0.04121512 -0.06822828 7.678233 3.1.3 sprintf() C 언어의 sprintf() 함수와 동일하며 특정 변수들의 값을 이용해 문자열을 반환함 수치형 값의 소숫점 자리수를 맞추거나 할 때 유용하게 사용 포맷팅 문자열을 통해 수치형의 자릿수를 지정 뿐 아니라 전체 문자열의 길이 및 정렬 가능 대표적인 포맷팅 문자열은 아래 표와 같음. Format 설명 %s 문자열 %d 정수형 %f 부동 소수점 수 %e, %E 지수형 예시 options()$digits # [1] 7 pi # 파이 값 [1] 3.141593 sprintf(&quot;%f&quot;, pi) [1] &quot;3.141593&quot; # 소숫점 자리수 3자리 까지 출력 sprintf(&quot;%.3f&quot;, pi) [1] &quot;3.142&quot; # 소숫점 출력 하지 않음 sprintf(&quot;%1.0f&quot;, pi) [1] &quot;3&quot; # 출력 문자열의 길이를 5로 고정 후 # 소숫점 한 자리까지 출력 sprintf(&quot;%5.1f&quot;, pi) [1] &quot; 3.1&quot; nchar(sprintf(&quot;%5.1f&quot;, pi)) [1] 5 # 빈 공백에 0값 대입 sprintf(&quot;%05.1f&quot;, pi) [1] &quot;003.1&quot; # 양수/음수 표현 sprintf(&quot;%+f&quot;, pi) [1] &quot;+3.141593&quot; sprintf(&quot;%+f&quot;, -pi) [1] &quot;-3.141593&quot; # 출력 문자열의 첫 번째 값을 공백으로 sprintf(&quot;% f&quot;, pi) [1] &quot; 3.141593&quot; # 왼쪽 정렬 sprintf(&quot;%-10.3f&quot;, pi) [1] &quot;3.142 &quot; # 수치형에 정수 포맷을 입력하면? sprintf(&quot;%d&quot;, pi) Error in sprintf(&quot;%d&quot;, pi): &#39;%d&#39;는 유효하지 않은 포맷입니다; 수치형 객체들에는 포맷 %f, %e, %g 또는 %a를 사용해 주세요 sprintf(&quot;%d&quot;, 100); sprintf(&quot;%d&quot;, 20L) [1] &quot;100&quot; [1] &quot;20&quot; # 지수형 sprintf(&quot;%e&quot;, pi) [1] &quot;3.141593e+00&quot; sprintf(&quot;%E&quot;, pi) [1] &quot;3.141593E+00&quot; sprintf(&quot;%.2E&quot;, pi) [1] &quot;3.14E+00&quot; # 문자열 sprintf(&quot;%s = %.2f&quot;, &quot;Mean&quot;, pi) [1] &quot;Mean = 3.14&quot; # 응용 mn &lt;- apply(cars, 2, mean) std &lt;- apply(cars, 2, sd) # Mean ± SD 형태로 결과 출력 (소숫점 2자리 고정) res &lt;- sprintf(&quot;%.2f \\U00B1 %.2f&quot;, mn, std) resp &lt;- paste(paste0(names(cars), &quot;: &quot;, res), collapse = &quot;\\n&quot;) writeLines(resp) speed: 15.40 ± 5.29 dist: 42.98 ± 25.77 3.1.4 substr() 문자열에서 특정 부분을 추출하는 함수 보통 한 문자열이 주어졌을 때 start에서 end 까지 추출 substr( x, # 문자형 벡터 start, # 문자열 추출 시작 위치 stop # 무자열 추출 종료 위치 ) 예시 cnu &lt;- &quot;충남대학교 자연과학대학 정보통계학과&quot; substr(cnu, start = 14, stop = nchar(str)) [1] &quot;정보통계학과&quot; # 문자열 벡터에서 각 원소 별 적용 substr(str, 5, 15) [1] &quot;birch canoe&quot; &quot; the sheet &quot; &quot; easy to te&quot; &quot;e days a ch&quot; &quot; is often s&quot; [6] &quot;juice of le&quot; &quot;box was thr&quot; &quot;hogs were f&quot; &quot; hours of s&quot; &quot;e size in s&quot; 3.1.5 tolower(), toupper() 대문자를 소문자(tolower()) 혹은 소문자를 대문자(toupper())로 변환 LETTERS; tolower(LETTERS) [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; letters; toupper(letters) [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; 3.1.6 glue 패키지를 활용한 문자열 다루기 glue 패키지에서 제공하는 glue() 함수를 통해 지금까지 학습한 paste(), paste0() 보다 손쉽게 문자열을 결합할 수 있음 중괄호({}, curly bracket)를 활용해 R 객체에 저장되어 있는 값과 지정한 문자열을 결합 3.1.6.1 glue 패키지 설치 # CRAN에 배포된 패키지 설치 install.packages(&#39;glue&#39;) # 개발자 버전 설치 install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/glue&quot;) 3.1.6.2 사용 방법 R 객체를 직접 문자열과 결합 \\(\\rightarrow\\) 문자열 + {R 객체명} library(glue) name &lt;- &quot;Boncho Ku&quot; glue(&quot;My name is {name}.&quot;) My name is Boncho Ku. 긴 문자열과 R 객체를 결합 시 함수 내 ,로 구분 후 결합 가능 name &lt;- &quot;Boncho Ku&quot; age &lt;- 42 anniversary &lt;- as.Date(&quot;2013-03-24&quot;) glue(&quot;My name is {name}, &quot;, &quot;My age next year is {age + 1}, &quot;, &quot;My wedding aniversary is {anniversary}.&quot;) My name is Boncho Ku, My age next year is 43, My wedding aniversary is 2013-03-24. 함수 내 임시변수를 활용한 문자열 결함 glue(&quot;My name is {name_temp}, &quot;, &quot;My age next year is {age_temp + 1}, &quot;, &quot;My wedding aniversary is {anniversary_temp}.&quot;, name_temp = &quot;Boncho Ku&quot;, age_temp = 42, anniversary_temp = as.Date(&quot;2013-03-24&quot;)) My name is Boncho Ku, My age next year is 43, My wedding aniversary is 2013-03-24. 데이터 프레임 변수에 일괄 적용 가능 dat &lt;- head(iris) glue(&quot;The {dat$Species} has a sepal length {dat$Sepal.Length}&quot;) The setosa has a sepal length 5.1 The setosa has a sepal length 4.9 The setosa has a sepal length 4.7 The setosa has a sepal length 4.6 The setosa has a sepal length 5 The setosa has a sepal length 5.4 단순히 새로 줄바꿈(Enter)으로 두 줄 이상 문자열을 생성 가능 glue(&quot;The first line The second line The third line&quot;) The first line The second line The third line 문장 끝에 \\\\를 붙이면 줄바꿈이 실행되지 않음 glue(&quot;The first line, \\\\ The second line, \\\\ The third line&quot;) The first line, The second line, The third line 이중 중괄호({{}}): {R 객체명}을 그대로 출럭 name &lt;- &quot;Boncho Ku&quot; glue(&quot;My name is {name}, not {{name}}.&quot;) My name is Boncho Ku, not {name}. .open 및 .close를 사용해 대체 구분기호 지정 가능 one &lt;- 1 glue(&quot;The value of $\\\\int (\\\\sqrt{2\\\\pi}\\\\sigma)^{-1}&quot;, &quot;\\\\exp[-(x - \\\\mu)^2/2\\\\sigma^2] dx$&quot;, &quot; is $&lt;&lt;one&gt;&gt;$&quot;, .open = &quot;&lt;&lt;&quot;, .close = &quot;&gt;&gt;&quot;) The value of $\\int (\\sqrt{2\\pi}\\sigma)^{-1}\\exp[-(x - \\mu)^2/2\\sigma^2] dx$ is $1$ 위 문자열을 Rmarkdown 문서에 수식으로 표현하고 싶다면 inline R code chunk 사용 `r glue(\"The value of $\\\\int (\\\\sqrt{2\\\\pi}\\\\sigma)^{-1}\", \"\\\\exp[-(x - \\\\mu)^2/2\\\\sigma^2] dx$\", \" is $&lt;&lt;one&gt;&gt;$\", .open = \"&lt;&lt;\", .close = \"&gt;&gt;\") ` The value of \\(\\int (\\sqrt{2\\pi}\\sigma)^{-1}\\exp[-(x - \\mu)^2/2\\sigma^2] dx\\) is \\(1\\) "],["regexp-basic-fun.html", "3.2 정규표현식 기본 함수", " 3.2 정규표현식 기본 함수 3.2.1 grep(), grepl() 정규표현식을 이용한 특정 문자 패턴 검색 시 가장 빈번히 사용되는 함수들 중 하나임. grep() 특정 문자 벡터에서 찾고자 하는 패턴과 일치하는 원소의 인덱스, 원소값 반환 # 일치하는 특정 문자열을 포함하는 원소값(문자형) 또는 인덱스(정수)를 반환 grep( pattern, # 정규 표현식 또는 문자 패턴 string, # 패턴을 검색할 문자열 벡터 value # 논리값 # TRUE: pattern에 해당하는 원소값 반환 # FALSE: pattern이 있는 원소의 색인 반환 ) x &lt;- c(&quot;Equator&quot;, &quot;North Pole&quot;, &quot;South Pole&quot;) # x에서 Pole 이 있는 원소의 문자열 반환 grep(&quot;Pole&quot;, x, value = T) [1] &quot;North Pole&quot; &quot;South Pole&quot; # x에서 Pole 이 있는 원소의 색인 반환 grep(&quot;Pole&quot;, x, value = F) [1] 2 3 # x에서 Eq를 포함한 원소 색인 반환 grep(&quot;Eq&quot;, x) [1] 1 grepl() grep()과 유사한 기능을 갖지만, 함수의 반환값이 논리형 벡터임 # 일치하는 특정 문자열을 포함하는 원소 색인에 대한 논리값 반환 grepl( pattern, # 정규 표현식 또는 문자 패턴 string # 패턴을 검색할 문자열 벡터 ) 사용 예시 # grepl() 예시 # Titanic data 불러오기 url1 &lt;- &quot;https://raw.githubusercontent.com/&quot; url2 &lt;- &quot;agconti/kaggle-titanic/master/data/train.csv&quot; titanic &lt;- read.csv(paste0(url1, url2), stringsAsFactors = FALSE) # 승객이름 추출 pname &lt;- titanic$Name # 승객 이름이 James 인 사람만 추출 g &lt;- grepl(&quot;James&quot;, pname) pname[g] [1] &quot;Moran, Mr. James&quot; [2] &quot;Crease, Mr. Ernest James&quot; [3] &quot;Sobey, Mr. Samuel James Hayden&quot; [4] &quot;Bateman, Rev. Robert James&quot; [5] &quot;Watt, Mrs. James (Elizabeth \\&quot;Bessie\\&quot; Inglis Milne)&quot; [6] &quot;Smith, Mr. James Clinch&quot; [7] &quot;Brown, Mrs. James Joseph (Margaret Tobin)&quot; [8] &quot;Bracken, Mr. James H&quot; [9] &quot;Reed, Mr. James George&quot; [10] &quot;Baxter, Mrs. James (Helene DeLaudeniere Chaput)&quot; [11] &quot;Drew, Mrs. James Vivian (Lulu Thorne Christian)&quot; [12] &quot;Flynn, Mr. James&quot; [13] &quot;Scanlan, Mr. James&quot; [14] &quot;Webber, Mr. James&quot; [15] &quot;McGough, Mr. James Robert&quot; [16] &quot;Farrell, Mr. James&quot; [17] &quot;Sharp, Mr. Percival James R&quot; [18] &quot;Downton, Mr. William James&quot; [19] &quot;Elsbury, Mr. William James&quot; [20] &quot;Kelly, Mr. James&quot; [21] &quot;Hawksford, Mr. Walter James&quot; [22] &quot;Lester, Mr. James&quot; [23] &quot;Slemen, Mr. Richard James&quot; [24] &quot;Banfield, Mr. Frederick James&quot; 3.2.2 regexpr(), gregexpr() grep()과 grepl()의 한계점 보완: 특정 문자 패턴의 일치여부에 대한 정보를 제공하지만 위치 및 정규식의 일치 여부를 알려주지는 않음 regexpr() 문자열에서 패턴이 일치하는 문자(표현)가 첫 번째 등장하는 위치와 몇 개의 문자로 구성(길이) 되어 있는지를 반환 예시 x &lt;- c(&quot;Darth Vader: If you only knew the power of the Dark Side. Obi-Wan never told you what happend to your father&quot;, &quot;Luke: He told me enough! It was you who killed him!&quot;, &quot;Darth Vader: No. I&#39;m your father&quot;) # grep 계열 함수 grep(&quot;you&quot;, x); grepl(&quot;you&quot;, x) [1] 1 2 3 [1] TRUE TRUE TRUE # regexpr() regexpr(&quot;you&quot;, x) # 각 x의 문자열에서 you가 처음 나타난 위치 및 길이 반환 [1] 17 33 22 attr(,&quot;match.length&quot;) [1] 3 3 3 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE regexpr(&quot;father&quot;, x) # 패턴을 포함하지 않은 경우 -1 반환 [1] 111 -1 27 attr(,&quot;match.length&quot;) [1] 6 -1 6 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE substr() 함수와 regexpr() 함수를 이용해 텍스트 내 원하는 문자 추출 가능 idx &lt;- regexpr(&quot;father&quot;, x) substr(x, idx, idx + attr(idx, &quot;match.length&quot;) - 1) [1] &quot;father&quot; &quot;&quot; &quot;father&quot; gregexpr() 영역에 걸쳐 패턴과 일치하는 문자의 위치 및 길이 반환(regexpr()의 global 버전) gregexpr(&quot;you&quot;, x) # 각 x의 문자열에서 you가 나타난 모든 위치 및 길이 반환 [[1]] [1] 17 86 106 attr(,&quot;match.length&quot;) [1] 3 3 3 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[2]] [1] 33 attr(,&quot;match.length&quot;) [1] 3 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[3]] [1] 22 attr(,&quot;match.length&quot;) [1] 3 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE gregexpr(&quot;father&quot;, x) # 패턴을 포함하지 않은 경우 -1 반환 [[1]] [1] 111 attr(,&quot;match.length&quot;) [1] 6 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[2]] [1] -1 attr(,&quot;match.length&quot;) [1] -1 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[3]] [1] 27 attr(,&quot;match.length&quot;) [1] 6 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE 3.2.3 sub(), gsub() 검색하고자 하는 패턴을 원하는 문자로 변경 문자열 벡터의 패턴을 일치시키거나 문자열 정리가 필요할 때 사용 sub() 문자열에서 첫 번째 일치하는 패턴만 변경 sub(pattern, # 검색하고자 하는 문자, 패턴, 표현 replacement, # 검색할 패턴 대신 변경하고자 하는 문자 및 표현 x # 문자형 벡터 ) 예시 jude &lt;- c(&quot;Hey Jude, don&#39;t make it bad&quot;, &quot;Take a sad song and make it better&quot;, &quot;Remember to let her into your heart&quot;, &quot;Then you can start to make it better&quot;) sub(&quot;a&quot;, &quot;X&quot;, jude) [1] &quot;Hey Jude, don&#39;t mXke it bad&quot; [2] &quot;TXke a sad song and make it better&quot; [3] &quot;Remember to let her into your heXrt&quot; [4] &quot;Then you cXn start to make it better&quot; gsub() 문자열에서 일치하는 모든 패턴 변경 예시 sub(&quot; &quot;, &quot;_&quot;, jude) [1] &quot;Hey_Jude, don&#39;t make it bad&quot; [2] &quot;Take_a sad song and make it better&quot; [3] &quot;Remember_to let her into your heart&quot; [4] &quot;Then_you can start to make it better&quot; gsub(&quot; &quot;, &quot;_&quot;, jude) [1] &quot;Hey_Jude,_don&#39;t_make_it_bad&quot; [2] &quot;Take_a_sad_song_and_make_it_better&quot; [3] &quot;Remember_to_let_her_into_your_heart&quot; [4] &quot;Then_you_can_start_to_make_it_better&quot; gsub(&quot;a&quot;, &quot;X&quot;, jude) [1] &quot;Hey Jude, don&#39;t mXke it bXd&quot; [2] &quot;TXke X sXd song Xnd mXke it better&quot; [3] &quot;Remember to let her into your heXrt&quot; [4] &quot;Then you cXn stXrt to mXke it better&quot; 3.2.4 regexec() regexpr()과 유사하게 작동하지만 괄호(())로 묶인 하위 표현식에 대한 인덱스를 제공 (): 정규 표현식의 메타 문자 중 하나로 그룹을 나타냄 \\(\\rightarrow\\) 정규표현식 내 논리적 테스트 수행 가능 bla &lt;- c(&quot;I like statistics&quot;, &quot;I like R programming&quot;, &quot;I like bananas&quot;, &quot;Estates and statues are too expensive&quot;) grepl(&quot;like&quot;, bla) [1] TRUE TRUE TRUE FALSE grepl(&quot;are&quot;, bla) [1] FALSE FALSE FALSE TRUE grepl(&quot;(like|are)&quot;, bla) [1] TRUE TRUE TRUE TRUE 찾고자 하는 패턴을 두 그룹으로 나눌 때 유용 예시 gregexpr(&quot;stat&quot;, bla) [[1]] [1] 8 attr(,&quot;match.length&quot;) [1] 4 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[2]] [1] -1 attr(,&quot;match.length&quot;) [1] -1 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[3]] [1] -1 attr(,&quot;match.length&quot;) [1] -1 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[4]] [1] 2 13 attr(,&quot;match.length&quot;) [1] 4 4 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE gregexpr(&quot;(st)(at)&quot;, bla) [[1]] [1] 8 attr(,&quot;match.length&quot;) [1] 4 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[2]] [1] -1 attr(,&quot;match.length&quot;) [1] -1 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[3]] [1] -1 attr(,&quot;match.length&quot;) [1] -1 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[4]] [1] 2 13 attr(,&quot;match.length&quot;) [1] 4 4 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE # &quot;at&quot;에 대한 패턴을 찾지 못하고 # &quot;stat&quot; 패턴과 과 동일한 결과 반환 regexec(&quot;(st)(at)&quot;, bla) [[1]] [1] 8 8 10 attr(,&quot;match.length&quot;) [1] 4 2 2 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[2]] [1] -1 attr(,&quot;match.length&quot;) [1] -1 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[3]] [1] -1 attr(,&quot;match.length&quot;) [1] -1 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE [[4]] [1] 2 2 4 attr(,&quot;match.length&quot;) [1] 4 2 2 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE # &quot;stat&quot; 패턴도 동시에 반환됨을 유의 # 첫 번째 일치 패턴만 반환 3.2.5 strsplit() 문자열에서 매칭되는 특정 패턴(문자)을 기준으로 문자열을 분할함 strsplit( x, # 문자형 벡터 split # 분할 구분 문자(정규표현식 포함) ) 예시 jude_w1 &lt;- strsplit(jude, &quot; &quot;) jude_w1 [[1]] [1] &quot;Hey&quot; &quot;Jude,&quot; &quot;don&#39;t&quot; &quot;make&quot; &quot;it&quot; &quot;bad&quot; [[2]] [1] &quot;Take&quot; &quot;a&quot; &quot;sad&quot; &quot;song&quot; &quot;and&quot; &quot;make&quot; &quot;it&quot; &quot;better&quot; [[3]] [1] &quot;Remember&quot; &quot;to&quot; &quot;let&quot; &quot;her&quot; &quot;into&quot; &quot;your&quot; &quot;heart&quot; [[4]] [1] &quot;Then&quot; &quot;you&quot; &quot;can&quot; &quot;start&quot; &quot;to&quot; &quot;make&quot; &quot;it&quot; &quot;better&quot; # 공백, 쉼표가 있는 경우 구분 jude_w2 &lt;- strsplit(jude, &quot;(\\\\s|,)&quot;) jude_w2 [[1]] [1] &quot;Hey&quot; &quot;Jude&quot; &quot;&quot; &quot;don&#39;t&quot; &quot;make&quot; &quot;it&quot; &quot;bad&quot; [[2]] [1] &quot;Take&quot; &quot;a&quot; &quot;sad&quot; &quot;song&quot; &quot;and&quot; &quot;make&quot; &quot;it&quot; &quot;better&quot; [[3]] [1] &quot;Remember&quot; &quot;to&quot; &quot;let&quot; &quot;her&quot; &quot;into&quot; &quot;your&quot; &quot;heart&quot; [[4]] [1] &quot;Then&quot; &quot;you&quot; &quot;can&quot; &quot;start&quot; &quot;to&quot; &quot;make&quot; &quot;it&quot; &quot;better&quot; "],["reg-exp.html", "3.3 정규 표현식(regular expression)", " 3.3 정규 표현식(regular expression) 주어진 문자열에 특정한 패턴이 있는 경우, 해당 패턴을 일반화(수식화)한 문자열 특정 패턴을 표현한 문자열을 메타 문자(meta character) 라고 지칭 일반적으로 특정 규칙 또는 패턴이 문자열을 찾고(to find), 해당 규칙에 해당하는 문자열을 대체(replace, substitute) 하기 위해 사용 R 언어 뿐 아니라 타 프로그래밍 언어(C, Perl, Python 등) 워드 프로세서, 텍스트 편집기, 검색 엔진, 운영체제(Windows, Linux 등)에서도 범용적으로 사용 정규식이라고도 불리우며 영어로는 regex 또는 regexp 로 명칭됨 3.3.1 기본 메타 문자 Table 3.1: 정규표현식 메타 문자: 기본 Expression Name 설명 . Period (마침표) 무엇이든 한 글자를 의미 + Plus + 앞에 오는 표현이 하나 이상 포함 * Asterisk * 앞에 오는 표현이 0 또는 하나 이상 포함 ? Question mark ? 앞에 오는 표현이 0 또는 하나 포함 ^ Caret ^ 뒤에 오는 표현으로 시작 $ Dollar $ 앞에 오는 표연으로 끝나는 경우 {} Curly bracket {} 앞에 정확히 {}에 있는 숫자만큼 반복되는 패턴 (예시 참고) () Parenthesis () 정규 표현식 내 하위(그룹) 표현식 (예시 참고) 메타 문자를 메타 문자가 아닌 문자 자체로 인식하기 위해서는 해당 문자 앞에 \\\\를 붙임 # 마침표가 있는 위치 반환 str2 &lt;- str[1:2] regexpr(&quot;.&quot;, str2) [1] 1 1 attr(,&quot;match.length&quot;) [1] 1 1 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE # 에러 출력 regexpr(&quot;\\.&quot;, str2) Error: &quot;&quot;\\.&quot;로 시작하는 문자열 중에서 &#39;\\.&#39;는 인식할 수 없는 이스케이프입니다 # 정확한 표현 regexpr(&quot;\\\\.&quot;, str2) [1] 42 43 attr(,&quot;match.length&quot;) [1] 1 1 attr(,&quot;index.type&quot;) [1] &quot;chars&quot; attr(,&quot;useBytes&quot;) [1] TRUE . 마침표(period) 어떤 임의의 한 문자를 의미 # 문자열 자체가 존재하니까 참값 반환 grepl(&quot;.&quot;, jude) [1] TRUE TRUE TRUE TRUE grepl(&quot;.&quot;, &quot;#@#%@FDSAGF$%&quot;) [1] TRUE # 문자없음 &quot;&quot; grepl(&quot;.&quot;, &quot;&quot;) [1] FALSE # a로 시작하고 중간에 어떤 글자가 하나 존재하고 b로 끝나는 패턴 bla2 &lt;- c(&quot;aac&quot;, &quot;aab&quot;, &quot;accb&quot;, &quot;acadb&quot;) g &lt;- grepl(&quot;a.b&quot;, bla2) bla2[g] [1] &quot;aab&quot; &quot;acadb&quot; # a와 b 사이 어떤 두 문자 존재하는 패턴 g &lt;- grepl(&quot;a..b&quot;, bla2) bla2[g] [1] &quot;accb&quot; + (plus) + 에 선행된 패턴이 한 번 이상 매칭 \\(\\rightarrow\\) + 앞에 문자를 1개 이상 포함 # &quot;a&quot;를 적어도 하나 이상 포함한 원소 반환 grepl(&quot;a+&quot;, c(&quot;ab&quot;, &quot;aa&quot;, &quot;aab&quot;, &quot;aaab&quot;, &quot;b&quot;)) [1] TRUE TRUE TRUE TRUE FALSE # &quot;l&quot;과 &quot;n&quot; 사이에 &quot;o&quot;가 하나 이상인 원소 반환 grepl(&quot;lo+n&quot;, c(&quot;bloon&quot;, &quot;blno&quot;, &quot;leno&quot;, &quot;lnooon&quot;, &quot;lololon&quot;)) [1] TRUE FALSE FALSE FALSE TRUE * (asterisk) * 앞에 선행된 문자 또는 패턴이 0번 이상 매치 \\(\\rightarrow\\) * 앞에 문자를 0개 또는 1개 이상 포함 # xx가 &quot;a&quot;를 0 또는 1개 이상 포함하고 있는가? xx &lt;- c(&quot;bbb&quot;, &quot;acb&quot;, &quot;def&quot;, &quot;cde&quot;, &quot;zde&quot;, &quot;era&quot;, &quot;xsery&quot;) # &quot;a&quot; 존재와 상관 없이 모든 문자열이 조건에 부합 g &lt;- grepl(&quot;a*&quot;, xx) xx[g] [1] &quot;bbb&quot; &quot;acb&quot; &quot;def&quot; &quot;cde&quot; &quot;zde&quot; &quot;era&quot; &quot;xsery&quot; # &quot;aab&quot;와 &quot;c&quot; 사이에 &quot;d&quot;가 없거나 하나 이상인 경우 # &quot;caabec&quot;인 경우 &quot;aab&quot;와 &quot;c&quot; 사이에 &quot;e&quot;가 존재하기 때문에 FALSE grepl(&quot;aabd*c&quot;, c(&quot;aabddc&quot;, &quot;caabec&quot;, &quot;aabc&quot;)) [1] TRUE FALSE TRUE ? (question) ? 앞에 항목은 선택 사항이며 많아야 한 번 매치 \\(\\rightarrow\\) ? 앞의 문자를 0개 또는 1개 포함 xx &lt;- c(&quot;ac&quot;, &quot;abbc&quot;, &quot;abc&quot;, &quot;abcd&quot;, &quot;abbdc&quot;) g &lt;- grepl(&quot;ab?c&quot;, xx) ## &quot;a&quot;와 &quot;c&quot; 사이 &quot;b&quot;가 0개 또는 1개 포함 xx[g] [1] &quot;ac&quot; &quot;abc&quot; &quot;abcd&quot; yy &lt;- c(&quot;aabc&quot;, &quot;aabbc&quot;, &quot;daabec&quot;, &quot;aabbbc&quot;, &quot;aabbbbc&quot;) g &lt;- grepl(&quot;aabb?c&quot;, yy) ## &quot;aab&quot;와 &quot;c&quot; 사이에 &quot;b&quot;가 0개 또는 1개 있는 경우 일치 yy[g] [1] &quot;aabc&quot; &quot;aabbc&quot; ^ (caret) ^ 뒤에 나오는 문자(열)로 시작하는 문자열 반환 # str에서 &quot;The&quot;로 시작하는 문자열 반환 g &lt;- grepl(&quot;^The&quot;, str) str[g] [1] &quot;The birch canoe slid on the smooth planks.&quot; [2] &quot;These days a chicken leg is a rare dish.&quot; [3] &quot;The juice of lemons makes fine punch.&quot; [4] &quot;The box was thrown beside the parked truck.&quot; [5] &quot;The hogs were fed chopped corn and garbage.&quot; [^]: 대괄호(straight bracket) 안에 첫 번째 문자가 ^인 경우 ^뒤에 있는 문자들을 제외한 모든 문자와 매치 xx &lt;- c(&quot;abc&quot;, &quot;def&quot;, &quot;xyz&quot;, &quot;werx&quot;, &quot;wbcsp&quot;, &quot;cba&quot;) # &quot;a&quot;, &quot;b&quot;, &quot;c&quot;를 순서 상관 없이 동시에 포함하지 않은 문자열 반환 g &lt;- grepl(&quot;[^abc]&quot;, xx) xx[g] [1] &quot;def&quot; &quot;xyz&quot; &quot;werx&quot; &quot;wbcsp&quot; ^[]: [] 안에 들어간 문자 중 어느 한 단어로 시작하는 문자열 반환 xx &lt;- c(&quot;def&quot;, &quot;wasp&quot;, &quot;sepcial&quot;, &quot;statisitc&quot;, &quot;abbey load&quot;, &quot;cross&quot;, &quot;batman&quot;) g &lt;- grepl(&quot;^[abc]&quot;, xx) xx[g] [1] &quot;abbey load&quot; &quot;cross&quot; &quot;batman&quot; $ (dollar) $ 앞에 나오는 문자 및 패턴과 문자열의 맨 마지막 문자 패턴과 매치 g &lt;- grepl(&quot;father$&quot;, x) writeLines(x[g]) Darth Vader: If you only knew the power of the Dark Side. Obi-Wan never told you what happend to your father Darth Vader: No. I&#39;m your father {} (curly bracket) {} 앞의 문자 패턴이 {} 안에 숫자만큼 반복되는 패턴을 매치 {n}: 정확히 n 번 매치 {n,m}: n 번에서 m 번 매치 {n, }: 적어도 n 번 이상 매치 xx &lt;- c(&quot;tango&quot;, &quot;jazz&quot;, &quot;swing jazz&quot;, &quot;hip hop&quot;, &quot;groove&quot;, &quot;rock&#39;n roll&quot;, &quot;heavy metal&quot;) # &quot;z&quot;가 정확히 2번 반복되는 원소 반환 g &lt;- grepl(&quot;z{2}&quot;, xx) xx[g] [1] &quot;jazz&quot; &quot;swing jazz&quot; # &quot;e&quot;가 2번 이상 반복되는 원소 반환 yy &lt;- c(&quot;deer&quot;, &quot;abacd&quot;, &quot;abcd&quot;, &quot;daaeb&quot;, &quot;eel&quot;, &quot;greeeeg&quot;) g &lt;- grepl(&quot;e{2,}&quot;, yy) xx[g] [1] &quot;tango&quot; &quot;groove&quot; &quot;rock&#39;n roll&quot; &quot;heavy metal&quot; # &quot;b&quot;가 2번 이상 4번 이하 반복되고 앞에 &quot;a&quot;가 있는 원소 반환 zz &lt;- c(&quot;ababababab&quot;, &quot;abbb&quot;, &quot;cbbe&quot;, &quot;xabbbbcd&quot;) g &lt;- grepl(&quot;ab{2,4}&quot;, zz) zz[g] [1] &quot;abbb&quot; &quot;xabbbbcd&quot; 참고: 위에서 소개한 메타 문자 중 *는 {0,}, +는 {1,}, ?는 {0,1}과 동일한 의미를 가짐 () (parenthesis) 특정 문자열을 ()로 grouping 한 개 이상의 그룹 지정 가능 # ab가 1~4회 이상 반복되는 문자열 반환 g &lt;- grepl(&quot;(ab){1,4}&quot;, zz) zz[g] [1] &quot;ababababab&quot; &quot;abbb&quot; &quot;xabbbbcd&quot; # &quot;The&quot;로 시작하고 &quot;punch&quot;가 포함된 문자열 ㅂ반환 g &lt;- grepl(&quot;^(The)+.*(punch)&quot;, str) str[g] [1] &quot;The juice of lemons makes fine punch.&quot; | (vertical bar) |를 기준으로 좌우 문자 패턴 중 하나를 의미하며 OR 조건과 동일한 의미를 가짐 [] 의 경우 메타문자나 문자 한글자에 대해서만 적용되는 반면 |는 문자를 묶어 문자열로 지정 가능 g &lt;- grepl(&quot;(is|was)&quot;, str) str[g] [1] &quot;These days a chicken leg is a rare dish.&quot; [2] &quot;Rice is often served in round bowls.&quot; [3] &quot;The box was thrown beside the parked truck.&quot; [4] &quot;Large size in stockings is hard to sell.&quot; g &lt;- grepl(&quot;(are|were)&quot;, str) str[g] [1] &quot;These days a chicken leg is a rare dish.&quot; [2] &quot;The hogs were fed chopped corn and garbage.&quot; 3.3.2 문자 집합 Table 3.2: 정규표현식 메타 문자: 문자집합 Expression 설명 \\w 문자(letter), 숫자(digit), 또는 _ (underscore) 포함 \\d 숫자 0에서 9 \\s 공백문자(line break, tab, spaces) \\W \\w에 포함하지 않는 표현 \\D 숫자가 아닌 표현 \\S 공백이 아닌 표현 # \\w 를 이용해 email 추출 email &lt;- c(&quot;demo@naver.com&quot;, &quot;sample@gmail.com&quot;, &quot;coffee@daum.net&quot;, &quot;redbull@nate.com&quot;, &quot;android@gmail.com&quot;, &quot;secondmoon@gmail.com&quot;, &quot;zorba1997@korea.re.kr&quot;) # 이메일 주소가 naver 또는 gmail만 추출 g &lt;- grepl(&quot;\\\\w+@(naver|gmail)\\\\.\\\\w+&quot;, email) email[g] [1] &quot;demo@naver.com&quot; &quot;sample@gmail.com&quot; &quot;android@gmail.com&quot; [4] &quot;secondmoon@gmail.com&quot; # 숫자를 포함하는 문자열 추출: \\d ex &lt;- c(&quot;ticket&quot;, &quot;51203&quot;, &quot;+-.,!@#&quot;, &quot;ABCD&quot;, &quot;_&quot;, &quot;010-123-4567&quot;) g &lt;- grepl(&quot;\\\\d&quot;, ex) ex[g] [1] &quot;51203&quot; &quot;010-123-4567&quot; # 뒤쪽 공백문자 제거 xx &lt;- c(&quot;some text on the line 1; \\n and then some text on line two &quot;) sub(&quot;\\\\s+$&quot;, &quot;&quot;, xx) [1] &quot;some text on the line 1; \\n and then some text on line two&quot; # 영문자(소문자 및 대문자 포함), 숫자, 언더바(_)를 제외한 문자 포함 g &lt;- grepl(&quot;\\\\W&quot;, ex) ex[g] [1] &quot;+-.,!@#&quot; &quot;010-123-4567&quot; # 숫자를 제외한 모든 문자 반환 g &lt;- grepl(&quot;\\\\D&quot;, ex) ex[g] [1] &quot;ticket&quot; &quot;+-.,!@#&quot; &quot;ABCD&quot; &quot;_&quot; &quot;010-123-4567&quot; # 영문자, 숫자, 언더바를 제외한 모든 문자 포함하고 # 숫자와 특수문자를 포함하는 문자열도 제외 g &lt;- grepl(&quot;\\\\W\\\\D&quot;, ex) ex[g] [1] &quot;+-.,!@#&quot; ## 공백, 탭을 제외한 모든 문자 포함 blank &lt;- c(&quot; &quot;, &quot;_&quot;, &quot;abcd&quot;, &quot;\\t&quot;, &quot;%^$#*#*&quot;) g &lt;- grepl(&quot;\\\\S&quot;, blank) blank[g] [1] &quot;_&quot; &quot;abcd&quot; &quot;%^$#*#*&quot; 3.3.3 문자 클래스 문자 집합을 더 세분화하여 특정 목적에 맞는 정규 표현형 대괄호([]) 안에 특정 패턴에 해당하는 문자로 규칙 표현하고 하이픈(-)을 사용해 특정 문자의 범위 지정 가능 응용 가능한 문자 클래스 Table 3.3: 정규표현식 주요 문자 클래스 Expression 설명 [a-z] 알파벳 소문자 중 하나 [A-Z] 알파벳 대문자 중 하나 [0-9] 0에서 9까지 숫자 중 하나 [a-zA-Z] 모든 알파벳 중 하나 [a-z0-9] 알파벳 소문자나 숫자 중 한 문자 [가-힝] 모든 한글 중 하나 [(abc)d] 문자열 ‘abc’와 문자 ’d’ 중 하나 POSIX (Portable Operating System Interface): 서로 다른 UNIX OS의 API를 정리하여 이식성이 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로 IEEE가 책정한 애플리케이션 인터페이스 규격 (“POSIX” 2018 Accessed: 2020-04-16) Table 3.4: 정규표현식: POSIX 문자 클래스 Expression 설명 [[:punct:]] 구둣점 문자 [][!#$%&amp;’()*+,./:;&lt;=&gt;?@\\^_`{|}~-] [[:alpha:]] 알파벳 [A-Za-z]와 동일한 표현 [[:lower:]] 소문자 알파벳 [a-z]와 동일 [[:upper:]] 대문자 알파벳 [A-Z]와 동일 [[:digit:]] 숫자 0 ~ 9 [0-9]와 동일 [[:alnum:]] 알파벳과 숫자 [0-9A-Za-z]와 동일 [[:cntrl:]] 제어문자 b [[:print:]] 모든 인쇄 가능한 문자 [[:space:]] 공백문자 \\t\\r\\n\\v\\f [[:blank:]] 공백문자 중 \\t \\n [[:xdigit:]] 16 진수 movie &lt;- c(&quot;terminator 3: rise of the machiens&quot;, &quot;les miserables&quot;, &quot;avengers: infinity war&quot;, &quot;iron man&quot;, &quot;indiana jones: the last crusade&quot;, &quot;irish man&quot;, &quot;mission impossible&quot;, &quot;the devil wears prada&quot;, &quot;parasite (gisaengchung)&quot;, &quot;once upon a time in hollywood&quot;) # 각 영화제목의 첫글자를 대문자로 변경 # \\b는 단어의 양쪽 가장 자리의 빈 문자를 의미 # \\\\1은 () 첫 번째 그룹, \\\\U는 대문자(perl) gsub(&quot;\\\\b(\\\\w)&quot;, &quot;\\\\U\\\\1&quot;, movie, perl = T) [1] &quot;Terminator 3: Rise Of The Machiens&quot; &quot;Les Miserables&quot; [3] &quot;Avengers: Infinity War&quot; &quot;Iron Man&quot; [5] &quot;Indiana Jones: The Last Crusade&quot; &quot;Irish Man&quot; [7] &quot;Mission Impossible&quot; &quot;The Devil Wears Prada&quot; [9] &quot;Parasite (Gisaengchung)&quot; &quot;Once Upon A Time In Hollywood&quot; # 엑셀에서 ()로 표시된 음수 데이터를 읽어온 경우 # 이를 음수로 표시 num &lt;- c(&quot;0.123&quot;, &quot;0.456&quot;, &quot;(0.45)&quot;, &quot;1.25&quot;) gsub(&quot;\\\\(([0-9.]+)\\\\)&quot;, &quot;-\\\\1&quot;, num) [1] &quot;0.123&quot; &quot;0.456&quot; &quot;-0.45&quot; &quot;1.25&quot; 3.3.4 정규 표현식 예시 텍스트 데이터를 처리할 때 일반적으로 많이 활용되는 정규 표현식 정제되지 않은 데이터 가공 시 유용하게 활용 공백 제거 선행 예제에서 문자열 뒤에 존재하는 공백 제거 예시 확인 다음 예시들은 선행 및 모든 공백 제거에 대한 정규 표현식에 대해 살펴봄 필요 표현식 공백을 다른 문자로 교체 해주는 함수 \\(\\rightarrow\\) gsub() 공백 character class: \\\\s 처음과 끝 지정 meta character: ^, $ 조건을 찾기 위한 meta character: +, | 모든 공백을 제거하려면 \\(\\rightarrow\\) \\\\s 앞쪽 공백만 제거하려면? \\(\\rightarrow\\) ^\\\\s+ 뒤쪽 공백만 제거하려면? \\(\\rightarrow\\) \\\\s+$ 양쪽 공백 모두를 제거하려면? 문장의 맨 앞에 곻백이 하나 이상 존재하거나(OR, |), 문장 맨 끝에 공백이 하나 이상 존재 \\(\\rightarrow\\) (^\\\\s+|\\\\s+$) txt &lt;- c(&quot; 신종 코로나바이러스 감염증(코로나19) 환자 가운데 회복해서 항체가 생긴 사람 중 절반가량은 체내에 바이러스가 남아 있는 것으로 나타났다. &quot;) txt [1] &quot; 신종 코로나바이러스 감염증(코로나19) 환자 가운데 회복해서 항체가\\n 생긴 사람 중 절반가량은 체내에 바이러스가 남아 있는 것으로 나타났다. &quot; # 모근 공백 제거 gsub(&quot;\\\\s&quot;, &quot;&quot;, txt) [1] &quot;신종코로나바이러스감염증(코로나19)환자가운데회복해서항체가생긴사람중절반가량은체내에바이러스가남아있는것으로나타났다.&quot; # 앞쪽 공백만 제거 gsub(&quot;^\\\\s+&quot;, &quot;&quot;, txt) [1] &quot;신종 코로나바이러스 감염증(코로나19) 환자 가운데 회복해서 항체가\\n 생긴 사람 중 절반가량은 체내에 바이러스가 남아 있는 것으로 나타났다. &quot; # 뒤쪽 공백만 제거 gsub(&quot;\\\\s+$&quot;, &quot;&quot;, txt) [1] &quot; 신종 코로나바이러스 감염증(코로나19) 환자 가운데 회복해서 항체가\\n 생긴 사람 중 절반가량은 체내에 바이러스가 남아 있는 것으로 나타났다.&quot; # 양쪽에 존재하는 공백들 제거 gsub(&quot;(^\\\\s+|\\\\s+$)&quot;, &quot;&quot;, txt) [1] &quot;신종 코로나바이러스 감염증(코로나19) 환자 가운데 회복해서 항체가\\n 생긴 사람 중 절반가량은 체내에 바이러스가 남아 있는 것으로 나타났다.&quot; # 가운데 \\n 뒤에 존재하는 공백들을 없애려면?? gsub(&quot;(^\\\\s+| {2,}|\\\\s+$)&quot;, &quot;&quot;, txt) [1] &quot;신종 코로나바이러스 감염증(코로나19) 환자 가운데 회복해서 항체가\\n생긴 사람 중 절반가량은 체내에 바이러스가 남아 있는 것으로 나타났다.&quot; 핸드폰 번호 추출 대한민국 핸드폰 번호의 형태 필요한 표현식 처음 세 자리: ^(01)\\\\d{1} 가운데 3~4자리: -\\\\d{3,4} 마지막 4자리: -\\\\d{4} phone &lt;- c(&quot;042-868-9999&quot;, &quot;02-3345-1234&quot;, &quot;010-5661-7578&quot;, &quot;016-123-4567&quot;, &quot;063-123-5678&quot;, &quot;070-5498- 1904&quot;, &quot;011-423-2912&quot;, &quot;010-6745-2973&quot;) g &lt;- grepl(&quot;^(01)\\\\d{1}-\\\\d{3,4}-\\\\d{4}&quot;, phone) phone[g] [1] &quot;010-5661-7578&quot; &quot;016-123-4567&quot; &quot;011-423-2912&quot; &quot;010-6745-2973&quot; 이메일 추출 정규 표현식을 이용해 이메일(e-mail) 주소만 텍스트 문서에서 추출 이메일 주소 구성 필요한 표현식 E-mail ID(@ 왼쪽): 어떤 알파벳, 숫자, 특수문자가 1개 이상 \\(\\rightarrow\\) [A-Za-z0-9[:punct:]]+ E-mail ID(@ 오른쪽-1): 어떤 알파벳이나 숫자가 하나 이상 존재하고 특수문자 포함(.xx.xx 추출에 필요) \\(\\rightarrow\\) @[A-Za-z0-9[:punct:]]+ E-mail ID(@ 오른쪽-2): .xx 또는 .xxx 검색 \\(\\rightarrow\\) \\\\.[A-Za-z]+ 예시 네이버 뉴스 크롤링 (“R 에서 원하는 키워드의 네이버 뉴스를 웹크롤링(스크래핑) 하는 방법” 2018) 검색 포탈: 네이버 검색범위: 2020년 4월 21일 검색 keyword: 21대 국회위원 선거 검색 뉴스 개수: 39개 검색결과 저장 파일: dataset/news-scraping.csv 개별 기사에 해당하는 URL로부터 ID 생성 각 뉴스로부터 기자들의 e-mail 추출 추출 후 기사 ID, 기사제목, e-mail 주소로 구성된 데이터 프레임 생성 # 크롤링한 데이터 불러오기 news_naver &lt;- read.csv(&quot;dataset/test.news-scraping.csv&quot;, header = T, stringsAsFactors = FALSE) # regmatches 함수: regexpr(), gregexpr(), regexec()로 검색한 패턴을 # 텍스트(문자열)에서 추출 # ID 추출 id &lt;- regmatches(news_naver$url, regexpr(&quot;\\\\d{10}&quot;, news_naver$url)) contents &lt;- news_naver$news_content news_naver2 &lt;- data.frame(id, title = news_naver$news_title, stringsAsFactors = FALSE) tmp &lt;- regmatches(contents, gregexpr(&quot;\\\\b[A-Za-z0-9[:punct:]]+@[A-Za-z0-9[:punct:]]+\\\\.[A-Za-z]+&quot;, contents)) names(tmp) &lt;- id x &lt;- t(sapply(tmp, function(x) x[1:2], simplify = &quot;array&quot;)) colnames(x) &lt;- paste0(&quot;email&quot;, 1:2) email &lt;- data.frame(id = row.names(x), x, stringsAsFactors = F) res &lt;- merge(news_naver2, email, by = &quot;id&quot;) head(res) # stringr 패키지 사용 # email &lt;- str_extract_all(contents, # &quot;\\\\b[A-Za-z0-9[:punct:]]+@[A-Za-z0-9[:punct:]]+\\\\.[A-Za-z]+&quot;, # simplify = TRUE) # email &lt;- data.frame(email, stringsAsFactors = FALSE) # names(email) &lt;- paste0(&quot;email&quot;, 1:2) # res &lt;- data.frame(id, title = news_naver$news_title, email, # stringsAsFactors = FALSE) # head(res) References "],["r-수학-함수-분포-함수-모형식-표현.html", "4 R 수학 함수, 분포 함수, 모형식 표현 ", " 4 R 수학 함수, 분포 함수, 모형식 표현 "],["수학함수.html", "4.1 수학함수", " 4.1 수학함수 R은 광범위한 수학 함수를 내장하고 있고 다음 열거한 함수 목록은 그 일부임 exp(): 지수(e)를 밑으로 하는 지수 함수 log(): 자연 로그 함수 log10(): 10을 밑으로 하는 로그 sqrt(): 제곱근 abs(): 절대값 sin(), cos(), tan() … : 삼각함수 min(), max(): 벡터 내 최솟값과 최댓값 반환 which.min(), which.max(): 벡터 내 최댓값과 최솟값에 대한 인덱스 반환 sum(), prod(): 벡터 원소들의 합과 곱 결과 반환 cumsum(), cumprod(): 백터 원소들의 누적합과 누적곱 round(), floor(), ceiling(): 수치형 값의 반올림, 내림, 올림 factorial(): 팩토리얼 함수 \\(n!\\) choose(): 조합 함수 (\\(_n C_r = \\frac{n!}{r!(n-r)!}\\)) rev(): 역순으로 배열 rank(): 백터 원소 값들의 순위 반환 sweep(): 각 원소에서 요약통계량(예: 평균)으로부터 편차 계산 시 유용 확장예제1: 확률계산 \\(P_i\\): \\(n\\) 개의 독립적인 사건이 있고 \\(i\\) 번째 사건이 발생할 확률 \\(n = 3\\) 일 때, 각 사건의 이름을 각각 A, B, C 라고 할 때 이 중 사건 하나가 발생할 확률 P(사건 하나가 발생할 확률) = P(A가 일어나고 B와 C가 일어나지 않을 확률) + P(A가 일어나지 않고 B가 일어나고 C가 일어나지 않을 확률) + P(A, B가 일어나지 않고 C만 일어날 확률) 여기서 P(A가 일어나고 B와 C가 일어나지 않을 확률) = \\(P_A(1-P_B)(1-P_C)\\) \\(\\rightarrow\\) 나머지도 마찬가지임 일반화 하면 \\[ \\sum_{i=1}^{n} P_i(1-P_1)(1-P_2)\\cdots (1-P_{i-1})(1-P_{i+1})\\cdots (1-P_{n}) \\] 수학함수로 구현: prod() 함수 활용 # 벡터 p에서 p_i 계산 함수 p &lt;- c(0.2, 0.4, 0.3) notp &lt;- 1 - p p[1] * prod(notp[-1]) + p[2] * prod(notp[-2]) + p[3] * prod(notp[-3]) [1] 0.452 p &lt;- runif(10, 0, 1) notp &lt;- 1 - p # 일반화 하려면 어떻게 해야 할까? -&gt; 반복문 활용 tot &lt;- 0 for (i in 1:length(p)) { tot &lt;- tot + p[i] * prod(notp[-i]) } 확장예제2: 누적합, 누적곱 # cumsum, cumprod 함수 사용 예시 x &lt;- c(2, 4, 1, 3, 7, 8) cumsum(x); cumprod(x) [1] 2 6 7 10 17 25 [1] 2 8 8 24 168 1344 확장예제3: 최솟값, 최댓값 # which.min, which.max 사용 예시 set.seed(100) x &lt;- sample(1:100, 100) idx_min &lt;- which.min(x) x[idx_min] [1] 1 idx_max &lt;- which.max(x) x[idx_max] [1] 100 # min(), max(), pmin(), pmax() 비교 set.seed(5) x &lt;- runif(5, 2, 4) y &lt;- runif(5, 2, 4) z &lt;- cbind(x, y) min(z); max(z) # z의 전체 값 중 최솟값과 최댓값 반환 [1] 2.2093 [1] 3.913 pmin(z); pmax(z) # 아무 값을 반환하지 않음 x y [1,] 2.400429 3.402115 [2,] 3.370437 3.055920 [3,] 3.833752 3.615870 [4,] 2.568799 3.913000 [5,] 2.209300 2.220906 x y [1,] 2.400429 3.402115 [2,] 3.370437 3.055920 [3,] 3.833752 3.615870 [4,] 2.568799 3.913000 [5,] 2.209300 2.220906 # 두 열을 비교해 각 행에서 최솟값, 최댓값을 반환 pmin(z[, 1], z[, 2]) [1] 2.400429 3.055920 3.615870 2.568799 2.209300 pmax(z[, 1], z[, 2]) [1] 3.402115 3.370437 3.833752 3.913000 2.220906 확장예제5: sweep() 함수 활용 X &lt;- matrix(1:12, 3, 4) m &lt;- apply(X, 2, mean) M &lt;- matrix(m, ncol = 4, nrow = 3, byrow = TRUE) X - M [,1] [,2] [,3] [,4] [1,] -1 -1 -1 -1 [2,] 0 0 0 0 [3,] 1 1 1 1 # sweep 함수 활용 sweep(X, 2, colMeans(X)) [,1] [,2] [,3] [,4] [1,] -1 -1 -1 -1 [2,] 0 0 0 0 [3,] 1 1 1 1 확장예제6: 미분/적분 문자의 미분 및 수치 적분 가능 # 도함수 구하기 ## D() 함수 사용 dx &lt;- D(expression(exp(x^2)), &quot;x&quot;) # exp(x^2)을 x에 대해서 1차 미분한 도함수 set.seed(3) x &lt;- runif(3, 1, 2) eval(dx) # 위 입력한 x에 대한 도함수 값 출력 [1] 9.141245 94.842390 18.856751 ## deriv() 함수 사용 grad &lt;- D(expression(x*sin(x)), &quot;x&quot;) # 도함수를 R의 function으로 바로 반환 가능 dx2 &lt;- deriv(expression(x*sin(x)), &quot;x&quot;, function.arg = TRUE) dx2(x) [1] 1.074580 1.757109 1.361092 attr(,&quot;gradient&quot;) x [1,] 1.3778035 [2,] 0.5482219 [3,] 1.2386966 # 수치 적분 ## integrate() 함수 사용 ## 주어진 함수의 적분식을 구한 후, 입력 구간에 대한 적분값 계산 integrate(f = function(x) x^2, lower = 0, upper = 1) 0.3333333 with absolute error &lt; 3.7e-15 "],["통계-분포-함수.html", "4.2 통계 분포 함수", " 4.2 통계 분포 함수 R은 현존하는 대부분의 통계 확률 분포 함수를 제공하고 접두사 + 분포이름 형태의 함수명을 갖고 있으며, 보통 다음과 같은 접두사를 통해 분포 함수 생성 d: 밀도(density)의 약어로 확률 밀도함수(probability density function, pdf) 또는 이산형 분포의 확률 질량 함수(probability mass function, pmf) q: 분위수(quantile)의 약어로 상위 %에 해당하는 \\(x\\) 값을 반환 p: 누적분포함수(cumulative density function, cdf) r: 특정 분포로부터 난수(확률변수) 생성 예: dnorm(), qnorm(), pnorm(), rnorm() 은 정규분포 관련 함수임 Table 4.1: 일반적인 R 통계 분포함수(일부 제시) Distribution Density/Mass function R pdf R cdf R quantile RV generation Parameter 균일분포 \\(\\frac{1}{b -a},~\\mathrm{for}~x \\in [a, b]\\) dunif punif qunif runif min (a), max (b) 지수분포 \\(\\lambda \\exp{(-\\lambda x)}\\) dexp pexp qexp rexp rate (\\(\\lambda\\)) 정규분포 \\(\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp \\left\\{-\\frac{(x - \\mu)^2}{2\\sigma^2} \\right \\}\\) dnorm pnorm qnorm rnorm mean (\\(\\mu\\)), sd (\\(\\sigma\\)) \\(\\chi^2\\) 분포 \\(\\frac{1}{\\Gamma(\\nu/2)2^{\\nu/2}}x^{(\\nu/2) - 1}e^{(-x/2)}\\) dchisq pchisq qchisq rchisq df (\\(\\nu\\)) \\(t\\) 분포 \\(\\frac{\\Gamma(\\frac{\\nu + 1}{2})}{\\Gamma{(\\frac{\\nu}{2}})}\\frac{1}{\\sqrt{\\nu\\pi}}\\frac{1}{(1 + x^2/\\nu)^{(\\nu + 1)/2}}\\) dt pt qt rt df (\\(\\nu\\)) 이항분포 \\({n \\choose x} p^x (1 - p)^{n - x}\\) dbinom pbinom qbinom rbinom size (\\(n\\)), prob (\\(p\\)) 포아송 분포 \\(\\frac{e^{-\\lambda}\\lambda^x}{x!}\\) dpois ppois qpois rpois lambda (\\(\\lambda\\)) 예제: 확률 분포 함수 ## 카이제곱분포 x &lt;- seq(0, 30, by = 0.1) y &lt;- dchisq(x, df = 3) # 자유도가 3인 카이제곱분포 밀도 함수 plot(x, y, type = &quot;l&quot;, bty = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, main = expression(paste(&quot;PDF of &quot;, ~chi^2, &quot; distribution&quot;)), lwd = 2, cex.main = 2) # P(5 &lt; V &lt; 10) pchisq(10, df = 3) - pchisq(5, df = 3) [1] 0.153231 ## 그림에 표현 idx &lt;- x &gt;= 5 &amp; x &lt;= 10 polygon(c(5, x[idx], 10), c(0, y[idx], 0), col = &quot;blue&quot;, border = &quot;blue&quot;) abline(h = 0, col = &quot;darkgray&quot;) text(x = 10, y = 0.05, cex = 2, bquote(P({5 &lt;= V} &lt;= 10 ) == .(sprintf(&quot;%.3f&quot;, pchisq(10, df = 3) - pchisq(5, df = 3)))), adj = 0) # 분위수 qchisq(pchisq(10, df = 3), df = 3) [1] 10 # 난수 생성 v &lt;- rchisq(1000, df = 3) mean(v) # 카이제곱분포의 평균은 이론적으로 자유도 값과 같음 [1] 2.994 "],["모형식-표현.html", "4.3 모형식 표현", " 4.3 모형식 표현 R에서 통계적 모형 표현 방법 지금까지 별다른 설명 없이 ~가 들어간 수식표현을 특정함수(예: lm(), t.test(), 심지어 그래프 생성에 필요한 함수 등)의 인수로 사용함. R은 (통계적) 모형을 표현하기 위해 formula 표현을 사용 \\(\\rightarrow\\) 일반적으로 좌변 ~ 우변형태로 표시 보통은 특정 함수 내에서 호출되며 데이터에 포함되어 있는 변수를 평가하지 않고 해당 함수에서 해석할 수 있도록 변수값을 불러올 수 있음. formula는 “language” 객체의 일종이며 “formula” 클래스를 속성으로 갖는 평가되지 않은 표현식(unevaluated expression) typeof(quote(x + 10)) # 객체의 형태가 &quot;language&quot; [1] &quot;language&quot; class(quote(x + 10)) # 객체의 클래스가 &quot;call&quot; [1] &quot;call&quot; R에서 formula을 특정하는 ~의 의미는 “즉시 평가(evaluate)하지 않고 이 코드의 의미를 전달(캡쳐)” \\(\\rightarrow\\) 인용(quote) 연산자로 볼 수 있는 이유임 # 수식 표현 a &lt;- y ~ x b &lt;- y ~ x + b c &lt;- ~ x + y + z typeof(c); class(c); attributes(c) [1] &quot;language&quot; [1] &quot;formula&quot; $class [1] &quot;formula&quot; $.Environment &lt;environment: R_GlobalEnv&gt; 가장 기본적인 formula의 형태는 아래와 같음 반응변수(response variable) ~ 독립변수(independent variables) ~ 는 “(좌변)은 (우변)의 함수로 나타낸 모형” 으로 해석됨. 우변과 좌변 모두 일반적으로 여러 개의 변수들이 있을 수 있으며, 해당 변수의 추가는 +로 표시됨 좌변은 반응변수, 우변은 설명변수를 의미 일반적으로 좌변에 \\(y\\)로 표현되는 반응변수는 학문 분야에 따라 종속변수(dependent variable), 표적변수(target variable), 결과변수(outcome variable), 레이블(label, \\(y\\)가 범주형일 경우) 등으로 명칭되며, 우변에 \\(y\\)를 설명하기 위해 사용하는 변수(\\(x\\))를 마찬가지로 분야와 성격에 따라 독립변수(independent variable), 설명변수(exploratory variable), 예측변수(predictor variable), 위험 인자(risk factor), 공변량(covariate) 등으로 명칭된다. formula를 구성하는 항으로 벡터 객체를 직접 사용할 수 있으나, 데이터 프레임의 변수명을 formula의 항으로 구성할 수 있음. formula의 항으로 지정된 벡터 또는 변수들의 값은 formula를 호출해 사용할 때 까지 연결되지 않은 “언어”로써만 존재 formula는 양면수식(two-sided formula, 좌변과 우변 모두에 하나 이상의 항이 존재)과 단면수식(one-sided formula, 우변에만 하나 이상의 항 존재) set.seed(1) x1 &lt;- rnorm(100, 2, 4) x2 &lt;- runif(100, 2, 4) x3 &lt;- rpois(100, 3) y &lt;- 2*x1 + 3*x2 + 0.5*x3 + 5 + rnorm(100, 0, 4) f1 &lt;- y ~ x # y는 x의 함수 f2 &lt;- y ~ x1 + x2 # y는 x1과 x2의 함수를 지칭하는 모형 typeof(f2); class(f2); attributes(f2) [1] &quot;language&quot; [1] &quot;formula&quot; $class [1] &quot;formula&quot; $.Environment &lt;environment: R_GlobalEnv&gt; names(iris) [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; f3 &lt;- Species ~ Sepal.Length + Sepal.Width + Petal.Length # 붓꽃의 종은 꽃받침 길이와 너비, 꽃잎의 길이에 대한 함수 f4 &lt;- ~ x1 + x2 f5 &lt;- y ~ x1 + x2 + x3 length(f3); length(f4) [1] 3 [1] 2 f4[[1]]; f4[[2]] `~` x1 + x2 f5[[1]]; f5[[2]]; f5[[3]] `~` y x1 + x2 + x3 수식 사용 이유 변수 간의 관계를 알기 쉽게 표현 복잡한 변수의 관계를 표현해 함수 내에서 손쉽게 해당 항에 대응하는 데이터 값에 접근 가능 수식표현 방법 위에서 기술환대로 좌변항 ~ 우변항으로 표현 formula() 또는 as.formula() 함수를 통해 텍스트를 formula 형태로 생성 가능 f6 &lt;- &quot;y ~ x1 + x2 + x3&quot; h &lt;- as.formula(f6) h y ~ x1 + x2 + x3 h &lt;- formula(f6) h y ~ x1 + x2 + x3 fs &lt;- c(f1, f2, f6) # formula 객체를 concatenate 할 경우 list 객체 fl &lt;- lapply(fs, as.formula) formula로 표현한 모형의 항에 대응하는 값으로 데이터 행렬 및 데이터 프레임 생성 model.frame(): formula 객체에 표현된 항에 대응하는 데이터 값으로 이루어진 데이터 프레임 반환 model.matrix(): 디자인 행렬을 생성하는 함수 d1 &lt;- model.frame(y ~ x1 + x2) # 벡터값을 데이터 프레임으로 반환 head(d1) # formula를 구성하고 있는 변수명에 대응하는 변수를 데이터 프레임에서 추출 f3 Species ~ Sepal.Length + Sepal.Width + Petal.Length d2 &lt;- model.frame(f3, iris) head(d2) # model.matrix()에서는 디자인 행렬만 반환 # y 값은 포함하지 않고 우변에 해당하는 항에 대응하는 데이터 반환 X1 &lt;- model.matrix(y ~ x1 + x2) head(X1) (Intercept) x1 x2 1 1 -0.5058152 2.535016 2 1 2.7345733 2.437291 3 1 -1.3425144 3.033594 4 1 8.3811232 2.537901 5 1 3.3180311 2.362337 6 1 -1.2818735 3.037152 formula 관련 함수 terms(): formula 객체에 포함되어 있는 항의 구조 파악 all.vars(): formula에 포함되어 있는 변수명 추출 update(): formula를 구성하는 항을 수정 terms(f2) y ~ x1 + x2 attr(,&quot;variables&quot;) list(y, x1, x2) attr(,&quot;factors&quot;) x1 x2 y 0 0 x1 1 0 x2 0 1 attr(,&quot;term.labels&quot;) [1] &quot;x1&quot; &quot;x2&quot; attr(,&quot;order&quot;) [1] 1 1 attr(,&quot;intercept&quot;) [1] 1 attr(,&quot;response&quot;) [1] 1 attr(,&quot;.Environment&quot;) &lt;environment: R_GlobalEnv&gt; all.vars(f2) [1] &quot;y&quot; &quot;x1&quot; &quot;x2&quot; update(f2, ~ . + x3) y ~ x1 + x2 + x3 formula에 사용되는 연산자와 의미 Symbol Example Meaning + X + Z 변수 항 포함 - X + Z - X 변수 항 제거 : X:W X와 W의 교호작용 %in% X%in%W 지분(nesting) * X*Z X + Z + X:Z ^ (X+W+Z)^3 3차 교호작용항까지 모든 항을 포함 I I(X^2) as is: X^2을 포함 1 X - 1 절편 제거 . Y ~ . 모든 변수 포함(X + W + Z) 일반 연산 시 A %in% B의 의미는 A가 B의 원소를 포함하는지에 대한 논리값을 반환해 주지만, formula에서 %in%은 중첩 또는 지분(nesting)을 내포함. R의 리스트 객체는 중첩 및 지분 구조의 대표적 형태임. 예를 들어 리스트에 포함된 한 원소에 대응하는 데이터의 형태 및 값은 동일 리스트의 다른 원소에 대응한 데이터의 형태 및 값이 다름. 즉, 리스트 객체는 한 객체에 여러 형태의 데이터 구조를 가질 수 있고 이를 중접된 구조라고 함. 또한 실험계획법(experimental design)에서 지분 설계(nested design) 방법이 있는데, 두 개 요인(factor) A와 B가 존재할 때 A의 수준에 따른 B의 수준이 모두 다른 경우, 즉 교호작용이 존재하지 않는 형태의 실험설계법을 지칭함. 예를 들어 A사와 B사의 오랜지 주스 당도에 차이가 있는지를 알기 위해 각 회사에서 생산하고 있는 주스 3종을 랜덤하게 선택했다고 가정해 보자. 여기서 주 관심사는 두 회사에서 생산한 주스의 당도의 동질성이지 오랜지 주스 간 당도 차이는 관삼사항이 아님. 이 경우, 주 관심요인은 회사(C)이고, 요인 C는 회사 A, B라는 두 개의 수준(level)을 갖고 있음. 오랜지 주스(O)는 각 회사 별로 3개의 수준을 갖고 있는데, 각 회사에서 생산하는 오랜지 주스는 생산 공정에 차이가 있기 떄문에 각 회사에 지분되어 있음. 즉, 회사 A에서 생산한 오랜지 주스 O1, O2, O3은 회사 B에서 생산한 O1, O2, O3과 다름. set.seed(10) x &lt;- runif(30) z &lt;- runif(30, 2, 3) w &lt;- sample(0:1, 30, replace = TRUE) y &lt;- 3 + 2.5*x + x^2 + 1.5*z + 0.5 * w + 2*w*x + rnorm(30, 0, 2) head(model.matrix(~ x)) (Intercept) x 1 1 0.50747820 2 1 0.30676851 3 1 0.42690767 4 1 0.69310208 5 1 0.08513597 6 1 0.22543662 head(model.matrix(~ x + z)) # x + z (Intercept) x z 1 1 0.50747820 2.535597 2 1 0.30676851 2.093088 3 1 0.42690767 2.169803 4 1 0.69310208 2.899832 5 1 0.08513597 2.422638 6 1 0.22543662 2.747746 head(model.matrix(~ x + z - x)) # x + z에서 z 항 제거 (Intercept) z 1 1 2.535597 2 1 2.093088 3 1 2.169803 4 1 2.899832 5 1 2.422638 6 1 2.747746 head(model.matrix(~ x:w)) # 교호작용항만 포함 (Intercept) x:w 1 1 0.5074782 2 1 0.3067685 3 1 0.0000000 4 1 0.0000000 5 1 0.0000000 6 1 0.0000000 head(model.matrix(~ x*w)) # x + w + x:w (Intercept) x w x:w 1 1 0.50747820 1 0.5074782 2 1 0.30676851 1 0.3067685 3 1 0.42690767 0 0.0000000 4 1 0.69310208 0 0.0000000 5 1 0.08513597 0 0.0000000 6 1 0.22543662 0 0.0000000 head(model.matrix(~ (x + z + w)^3)) # x + z + w + x:z + z:w + x:w + x:w:z (Intercept) x z w x:z x:w z:w x:z:w 1 1 0.50747820 2.535597 1 1.2867602 0.5074782 2.535597 1.2867602 2 1 0.30676851 2.093088 1 0.6420935 0.3067685 2.093088 0.6420935 3 1 0.42690767 2.169803 0 0.9263056 0.0000000 0.000000 0.0000000 4 1 0.69310208 2.899832 0 2.0098799 0.0000000 0.000000 0.0000000 5 1 0.08513597 2.422638 0 0.2062536 0.0000000 0.000000 0.0000000 6 1 0.22543662 2.747746 0 0.6194427 0.0000000 0.000000 0.0000000 head(model.matrix(~ x + I(x^2))) # x + x^2 (Intercept) x I(x^2) 1 1 0.50747820 0.257534127 2 1 0.30676851 0.094106916 3 1 0.42690767 0.182250156 4 1 0.69310208 0.480390494 5 1 0.08513597 0.007248133 6 1 0.22543662 0.050821668 # head(model.matrix(~ x + x^2)) head(model.matrix(~ x - 1)) x 1 0.50747820 2 0.30676851 3 0.42690767 4 0.69310208 5 0.08513597 6 0.22543662 dat &lt;- data.frame(y, x, w, z) head(model.matrix(y ~ ., data = dat)) (Intercept) x w z 1 1 0.50747820 1 2.535597 2 1 0.30676851 1 2.093088 3 1 0.42690767 0 2.169803 4 1 0.69310208 0 2.899832 5 1 0.08513597 0 2.422638 6 1 0.22543662 0 2.747746 head(model.matrix(y ~ .^2, data = dat)) (Intercept) x w z x:w x:z w:z 1 1 0.50747820 1 2.535597 0.5074782 1.2867602 2.535597 2 1 0.30676851 1 2.093088 0.3067685 0.6420935 2.093088 3 1 0.42690767 0 2.169803 0.0000000 0.9263056 0.000000 4 1 0.69310208 0 2.899832 0.0000000 2.0098799 0.000000 5 1 0.08513597 0 2.422638 0.0000000 0.2062536 0.000000 6 1 0.22543662 0 2.747746 0.0000000 0.6194427 0.000000 # nested 구조 dat2 &lt;- expand.grid(C = c(&quot;A&quot;, &quot;B&quot;), O = paste0(&quot;O&quot;, 1:3), y = runif(3, 1, 2)) dat2 &lt;- dat2[order(dat2$C, dat2$O), ] model.matrix(y ~ C + O %in% C, data = dat2) (Intercept) CB CA:OO2 CB:OO2 CA:OO3 CB:OO3 1 1 0 0 0 0 0 7 1 0 0 0 0 0 13 1 0 0 0 0 0 3 1 0 1 0 0 0 9 1 0 1 0 0 0 15 1 0 1 0 0 0 5 1 0 0 0 1 0 11 1 0 0 0 1 0 17 1 0 0 0 1 0 2 1 1 0 0 0 0 8 1 1 0 0 0 0 14 1 1 0 0 0 0 4 1 1 0 1 0 0 10 1 1 0 1 0 0 16 1 1 0 1 0 0 6 1 1 0 0 0 1 12 1 1 0 0 0 1 18 1 1 0 0 0 1 attr(,&quot;assign&quot;) [1] 0 1 2 2 2 2 attr(,&quot;contrasts&quot;) attr(,&quot;contrasts&quot;)$C [1] &quot;contr.treatment&quot; attr(,&quot;contrasts&quot;)$O [1] &quot;contr.treatment&quot; "],["r-markdown.html", "5 R Markdown", " 5 R Markdown Sketch 동일한 문서에 코드, 결과, 텍스트가 동시에 있을 수 있을까? 만약 결과와 도표가 자동으로 생성된 경우 데이터가 변경 되더라도 자동으로 문서를 업데이트 할 수 있을까? 최종 완료한 문서가 미래에도 열 수 있을까? 이러한 모든 과정이 매우 쉽다면?? Figure 5.1: R markdown 세계(https://ulyngs.github.io/rmarkdown-workshop-2019 에서 발췌) "],["r-markdown의-구성.html", "5.1 R Markdown의 구성", " 5.1 R Markdown의 구성 본 절의 내용 중 일부는 지난 학기 강의노트 1.7절과 중복되거나 재구성한 내용이 포함됨. R Markdown은 R 코드와 분석 결과(표, 그림 등)을 포함한 문서 또는 컨텐츠를 제작하는 도구로 일반적으로 아래 열거한 형태로 활용함 문서 또는 논문(pdf, html, docx) 프리젠테이션(pdf, html, pptx) 웹 또는 블로그 재현가능(reproducible)한 분석 및 연구8 가능 신뢰성 있는 문서 작성 Copy &amp; paste를 하지 않고 효율적 작업 가능 R 마크다운 파일 = .Rmd 확장자를 가진 일반 텍스트 파일 --- title: &quot;Untitled.Rmd&quot; date: &quot;2020-09-11&quot; output: html_document --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` ## R Markdown Markdown은 HTML, PDF 및 MS Word 문서를 작성하기 위한 간단한 형식의 지정 구문입니다. R Markdown 사용에 대한 자세한 내용은 &lt;http://rmarkdown.rstudio.com&gt;을 참조하십시오. **Knit** 버튼을 클릭하면 두 가지를 모두 포함하는 문서가 생성됩니다. 문서에 포함 된 R 코드 청크의 출력 내용뿐 아니라 다음과 같이 R 코드 청크를 포함 할 수 있습니다. ```{r cars} summary(cars) ``` ## Including Plots You can also embed plots, for example: ```{r pressure, echo=FALSE} plot(pressure) ``` `echo = FALSE` 매개 변수가 코드 청크에 추가 되었습니다. 플롯을 생성 한 R 코드의 인쇄를 방지합니다. 위 R Markdown 문서는 아래 그림과 같이 YAML, Markdown 텍스트, Code Chunk 세 부분으로 구성됨. Figure 5.2: R markdown structure YAML (YAML Ain’t Markup Language) R Markdown 문서의 metadata로 문서의 맨 처음에 항상 포함(header)되어야 함. R Markdown 문서의 최종 출력 형태(html, pdf, docx, pptx 등), 제목, 저자, 날짜 등의 정보 등을 포함 최종 문서 생성 과정 Rmd 파일을 knitr 을 통해 .md 파일로 변환 후 pandoc 이라는 문서 변환기를 통해 원하는 문서 포맷으로 출력 Figure 1.9: R Markdown의 최종 결과물 산출과정(http://applied-r.com/project-reporting-template/) "],["r-markdown-기본-문법syntax.html", "5.2 R Markdown 기본 문법(syntax)", " 5.2 R Markdown 기본 문법(syntax) R Markdown의 기본 문법은 Rstudio 풀다운 메뉴 [Help] \\(\\rightarrow\\) [Markdown Quick Reference] 에서 확인 가능 5.2.1 텍스트 문법 강조(emphasis) 이텔릭체: *italic1*, _italic2_ \\(\\rightarrow\\) italic1, italic2 볼드(굵은)체: *bold1*, __bold2__ \\(\\rightarrow\\) bold1, bold2 Inline code `inline code` \\(\\rightarrow\\) inline code 아래/위 첨자(sub/superscript) subscript~2~ \\(\\rightarrow\\) subscript2 superscript^2^ \\(\\rightarrow\\) superscript2 삭제표시(strike through) ~~strikethrough~~ \\(\\rightarrow\\) strikethrough 생략표시(ellipsis) ... \\(\\rightarrow\\) … 긴/짧은 대쉬(en/em-dash) 긴 대쉬: --- \\(\\rightarrow\\) — 짧은 대쉬: -- \\(\\rightarrow\\) – 특수문자 탈출 지정자 \\*, \\_, \\~, \\\\ \\(\\rightarrow\\) *, _, ~, \\ 하이퍼링크 -[text](link) \\(\\rightarrow\\) R Markdown Cheat-sheet 외부그림 삽입 ![image title](path/to/image): ![장난꾸러기](figures/son-02.jpg) 장난꾸러기 강제 줄바꿈(line breaks) 하나의 줄에서 공백(space) 두 개 이상 또는 백슬레시(\\) 입력 후 [Enter] End a line with two spaces to start a new paragraph End a line with two spaces to start a new paragraph End a line with two spaces to start\\ a new paragraph End a line with two spaces to start a new paragraph 각주(footnote) A footnote^[주석내용] \\(\\rightarrow\\) A footnote9 주석(comment) &lt;!-- this is a comment that won't be shown --&gt; \\(\\rightarrow\\) RStudio에서 단축키 [Ctrl] + [Shift] + [C]를 통해 전체 line 에 대해 주석처리 가능 5.2.2 Block-level elements 장/절(header) # Header 1 (chapter, 장) ## Header 2 (section, 절) ### Header 3 (subsection, 관) 목록(list) 비순서(unordered) 목록: -, *, + 중 어느 하나로 입력 가능 - one item * two item + sub-item 1 + sub-item 2 - subsub-item 1 - subsub-item 2 one item two item sub-item 1 sub-item 2 subsub-item 1 subsub-item 2 순서(ordered) 목록: 비순서 목록의 기호 대신 숫자로 리스트 생성 1. the first item - sub-item 1 2. the second item 3. the third item the first item sub-item 1 the second item the third item 같은 숫자로 적어도 순서대로 목록 생성 1. the first item - sub-item 1 1. the second item 1. the third item the first item sub-item 1 the second item the third item 인용구(blockquote): &gt;로 시작 &gt; &quot;There are three kinds of lies: lies, damn lies, and statistics&quot; &gt; &gt; --- Benjamin Disraeli “There are three kinds of lies: lies, damn lies, and statistics” — Benjamin Disraeli 5.2.3 수식표현(math expression) 줄 안에 수식 입력 시 $수식표현$ 으로 입력 수식 display style (보통 교과서에 정리 및 정의에 기술된 수식들) 적용 시 $$ ~ $$ 안에 수식 입력 수식 표현은 LaTeX 의 수식 표현을 동일하게 준용(https://www.latex4technics.com/, https://latex.codecogs.com/legacy/eqneditor/editor.php 에서 수식 입력 명령어 학습 가능) LaTeX 수식 입력 코드는 예시 \\[ P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x} \\] Inline equation: $P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}$ \\(\\rightarrow\\) \\(P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}\\) Math block: $$P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}$$ \\[P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}\\] $ $ 또는 $$ $$ 안에 LaTeX에서 제공하는 수식 함수 사용 가능 $$\\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array}$$ \\[\\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array}\\] $$\\Theta = \\begin{pmatrix}\\alpha &amp; \\beta\\\\ \\gamma &amp; \\delta \\end{pmatrix}$$ \\[\\Theta = \\begin{pmatrix}\\alpha &amp; \\beta\\\\ \\gamma &amp; \\delta \\end{pmatrix}\\] $$\\begin{align} g(X_{n}) &amp;= g(\\theta)+g&#39;({\\tilde{\\theta}})(X_{n}-\\theta) \\notag \\\\ \\sqrt{n}[g(X_{n})-g(\\theta)] &amp;= g&#39;\\left({\\tilde{\\theta}}\\right) \\sqrt{n}[X_{n}-\\theta ] \\end{align}$$ \\[\\begin{aligned} g(X_{n}) &amp;= g(\\theta)+g&#39;({\\tilde{\\theta}})(X_{n}-\\theta) \\notag \\\\ \\sqrt{n}[g(X_{n})-g(\\theta)] &amp;= g&#39;\\left({\\tilde{\\theta}}\\right) \\sqrt{n}[X_{n}-\\theta ] \\end{aligned}\\] "],["r-code-chunks.html", "5.3 R Code Chunks", " 5.3 R Code Chunks 실제 R code가 실행되는 부분임 Code chunk 실행 시 다양한 옵션 존재(본 강의에서는 몇 개의 옵션만 다룰 것이며, 더 자세한 내용은 https://yihui.org/knitr/options/ 또는 R Markdown 레퍼런스 가이드 참조 Code chunk는 ```{r}로 시작되며 r은 code 언어 이름을 나타냄. Code chunk는 ``` 로 종료 R Markdown 문서 작성 시 단축키 [Ctrl] + [Alt] + [I]를 입력하면 Chunk 입력창이 자동 생성됨 Code chunk의 옵션 조정을 통해 코드의 출력여부, 코드 출력 시 코드의 출력 형태, 코드의 결과물 출력 조정 가능 Figure 5.3: Chunk anatomy (https://ulyngs.github.io/rmarkdown-workshop-2019 에서 발췌) 자주 활용하는 chunk 옵션 코드 실행 관련 청크 Table 5.1: 코드 실행 관련 청크 Chunk 옵션 Default 설명 eval TRUE R 실행(코드 실행 결과)에 대응하는 결과 출력 여부 include TRUE 출력 문서에 코드 청크의 내용을 포함할지 여부 ```{r ex01-1, eval=TRUE} summary(iris) hist(iris$Sepal.Length) ``` ```{r ex01-2, eval=FALSE} summary(iris) hist(iris$Sepal.Length) ``` #청크 옵션 eval=TRUE summary(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 Median :5.800 Median :3.000 Median :4.350 Median :1.300 Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 Species setosa :50 versicolor:50 virginica :50 hist(iris$Sepal.Length) #청크 옵션 eval=FALSE summary(iris) hist(iris$Sepal.Length) 소스 코드 출력(텍스트) 결과 관련 청크 Table 5.2: 소스 코드 출력 결과 관련 청크 Chunk 옵션 Default 설명 echo TRUE R 실행 결과에 대응하는 코드 출력 여부 results markup 출력 결과 포맷 지정을 위한 옵션으로 추가적으로 3 가지 옵션 선택 가능: ‘hide’, ‘asis’, ‘hold’, ‘markup’ error TRUE 코드 또는 스크립트에 구문오류 메세지 출력 여부 message TRUE 코드로부터 생성된 메세지 출력 여부 warning TRUE 경고 메세지 출력 여부 echo: 코드 청크에 작성한 R-script 출력 여부 결정 echo = FALSE 이면 소스 코드 출력 없이 그림 결과만 출력 ```{r ex01-2, echo=TRUE} require(ggthemes) # ggtheme 패키지 불러오기 require(ggpubr) # ggpubr 패키지 불러오기 iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) ``` ```{r ex01-3, echo=FALSE} require(ggthemes) # ggtheme 패키지 불러오기 require(ggpubr) # ggpubr 패키지 불러오기 iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) ``` # echo = TRUE require(ggthemes) # ggtheme 패키지 불러오기 require(ggpubr) # ggpubr 패키지 불러오기 iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) results: 코드의 텍스트 출력 결과 포맷 지정 markup (default): 코드 청크 내 스크립트의 출력 형태에 따라 텍스트 출력 결과를 mark-up asis: 변환하지 않은 원래 R 출력 결과 그대로(as is) 출력 hide: R 스크립트로 생성된 텍스트 출력을 보여주지 않음(warning, message 출력 예외) hold: 코드 청크로 생성된 모든 소스 및 출력을 단일 블록으로 축소 # results = &#39;markup&#39;인 경우 아래 텍스트를 mark-up # (이 경우 아래 텍스트는 ``` ``` 블럭 처리)한 결과를 md 파일로 전송 cat(&quot;I&#39;m raw **Markdown** content.\\n&quot;) I&#39;m raw **Markdown** content. Figure 5.4: 청크 옵션 results = ’markup’인 경우 rmd vs. md 파일 비교 # results = &#39;asis&#39; 인 경우 텍스트를 그대로 md 파일에 입력 cat(&quot;I&#39;m raw **Markdown** content.\\n&quot;) I’m raw Markdown content. Figure 5.5: 청크 옵션 results = ’asis’인 경우 rmd vs. md 파일 비교 # results = &#39;hide&#39; cat(&quot;I&#39;m raw **Markdown** content.\\n&quot;) # 텍스트 결과를 출력하지 않음 # results = &#39;hold&#39;가 아닌 경우 한 라인 별 출력 결과 생성 x &lt;- rnorm(10) x [1] -1.43424955 -0.10313180 0.74521725 1.13518187 -0.34120156 -0.28293843 [7] 0.73607006 -0.04842061 0.41183250 -1.30495008 y &lt;- rnorm(10, 1, 2) y [1] 0.05739371 -0.94515758 0.33751964 -4.90967557 -1.44229169 4.49070989 [7] -0.08343401 -1.25037982 3.66813278 1.83514260 x + y [1] -1.3768558 -1.0482894 1.0827369 -3.7744937 -1.7834932 4.2077715 [7] 0.6526360 -1.2988004 4.0799653 0.5301925 # results = &#39;hold&#39;인 경우 코드 부분과 출력 부분이 따로 블록 처리 x &lt;- rnorm(10) x y &lt;- rnorm(10, 1, 2) y x + y [1] -2.42914157 -0.07257718 -0.56036810 -0.41890809 0.52003561 1.06279676 [7] 1.04722825 0.32477895 0.38578083 -0.23373547 [1] 1.01598968 1.89883597 -0.32339443 -0.18760988 0.05633705 1.84517885 [7] -2.95138803 2.09466879 -1.75244513 4.52681221 [1] -1.4131519 1.8262588 -0.8837625 -0.6065180 0.5763727 2.9079756 [7] -1.9041598 2.4194477 -1.3666643 4.2930767 error: 코드 청크 내 스크립트에 오류에 대한 보존 여부(stop()) 기본적으로 Rmarkdown 컴파일 시 error에 대한 옵션이 FALSE이기 때문에 스크립트(코드)에 오류가 포함되면 컴파일이 정지됨. error = TRUE 이면 오류 메세지를 포함한 텍스트 결과를 출력 3x &lt;- 3 x &lt;- 25 # 위 행이 구문 오류를 포함하고 있기 때문에 # 오류 이후의 코드는 실행되지 않음 x Error: &lt;text&gt;:1:2: 예상하지 못한 기호(symbol)입니다. 1: 3x ^ message/warning: 텍스트 출력물 중 경고(warning, warning() 함수의 출력 결과) 메세지 출력 여부 결정 # message = TRUE 인 경우 함수 message 출력 testit &lt;- function() { message(&quot;testing package startup messages&quot;) packageStartupMessage(&quot;initializing ...&quot;, appendLF = FALSE) Sys.sleep(1) packageStartupMessage(&quot; done&quot;) } # help(message) 예시 중 발췌 testit() testing package startup messages initializing ... done # message=FALSE -&gt; 메세지 출력하지 않음 testit() # 경고 메세지 출력 x &lt;- c(1, 2, &quot;new&quot;, 4:10) x &lt;- as.numeric(x) Warning: 강제형변환에 의해 생성된 NA 입니다 코드 서식 관련 청크 옵션 Table 5.3: 코드 서식 관련 청크 Chunk 옵션 Default 설명 comment TRUE 소스 코드 실행 출력의 각 줄 앞에 붙는 표시문자 출력 여부: 기본 값은 ‘##’ 임 highlight TRUE 구문 강조 여부 prompt FALSE R 프롬프트 출력 여부 tidy FALSE R 소스 코드 출력 정리 여부 comment: 텍스트 출력물에 주석 표시(default)를 함으로써 소스 코드와 출력 결과를 동시 선택과 복사를 가능(##는 주석 표시이기 때문에 실행되지 않음) 주석 표시를 제거하고 싶다면 comment = NA 또는 comment = '' # 디폴트 comment 사용 summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## highlight: 구문 강조 표시 여부 highlight=FALSE 일 때 소스 코드 출력 결과 # highlight=FALSE iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) prompt: R 콘솔 상 프롬프트 &gt;, + 출력 여부 &gt; # prompt = TRUE 인 경우 코드 출력 결과 &gt; require(ggthemes) # ggtheme 패키지 불러오기 &gt; require(ggpubr) # ggpubr 패키지 불러오기 &gt; iris %&gt;% + ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + + geom_point(size = 5) + + theme_pubclean() + + theme(axis.line = element_line(size = 0.8), + legend.title = element_text(face = &quot;bold&quot;, size = 15), + legend.text = element_text(face = &quot;bold&quot;, size = 12)) tidy: 코드를 사용자가 지정(혹은 formatR::tidy_sorce() 함수에 초기값으로 지정된 코드 정리 값)한 줄 당 문자 길이 등을 반영해 코드를 정리 tidy=TRUE 인 경우 자동으로 줄 바꿈 &gt; # tidy = FALSE 인 경우 코드 출력 결과 &gt; require(ggthemes) # ggtheme 패키지 불러오기 &gt; require(ggpubr) # ggpubr 패키지 불러오기 &gt; iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) &gt; # tidy = TRUE 인 경우 코드 출력 결과 &gt; require(ggthemes) # ggtheme 패키지 불러오기 &gt; require(ggpubr) # ggpubr 패키지 불러오기 &gt; iris %&gt;% + ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, + size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) 그림(plot) 출력 관련 청크 옵션 Table 5.4: Plot 출력 관련 청크 Chunk 옵션 Default 설명 fig.align default 최종 문서에 plot 정렬 방식 결정(center/left/right) fig.height/fig.width 7 그림 크기(단위: 인치) fig.cap NULL 그림 캡션(문자열 입력) dpi 72 dot per inche: 출력 그림 해상도 알아두면 좋은 청크 형태 Setup 청크 일반적으로 Rmarkdown 문서는 YAML 해더 뒤에 전역적 청크 옵션 지정과 R 패키지를 불러오는 것으로 시작 청크 옵션은 knitr::opts_chunk$set(청크 옵션 지정) 형태로 지정 가능 다음은 RStudio 에서 Rmd 문서 생성 시 맨 처음 나오는 코드 청크 예시임 ```{r ex01-2, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` 일반적 활용 예시 ```{r option-init, include=FALSE} knitr::opts_chunk$set(root.dir = &#39;../..&#39;, # 프로젝트 폴더 지정 eval = TRUE, echo = FALSE, cache = FALSE, include = TRUE, tidy = TRUE, tidy.opts = list(blank=FALSE, width.cutoff=120), # 소스 출력길이 지정 message = FALSE, warning = FALSE, engine = &quot;R&quot;, # Chunks will always have R code, unless noted error = TRUE, fig.path=&quot;Figures/&quot;, # Set the figure options fig.align = &quot;center&quot;, fig.width = 7, fig.height = 7, fig.keep=&#39;all&#39;, fig.retina=2) ``` 이미지 불러오기 ```{r, fig.cap = &quot;Taj Mahal&quot;} knitr::include_graphics(&quot;figures/taj.JPG&quot;, dpi = NA) ``` Figure 5.6: Taj Mahal ```{r, fig.cap = &quot;Scatterplot of the car dataset&quot;} cars %&gt;% ggplot(aes(x = speed, y = dist)) + geom_point(size = 5) + theme_tufte(base_size = 15) # ggtheme::theme_tufte() ``` R 생성 도표 포함 Figure 5.7: Scatterplot of the car dataset 테이블 삽입 가장 간단한 테이블은 knitr::kable() 함수를 통해 생성 가능 kable() 함수는 가장 단순한 형태의 표만 생성하기 때문에 복잡한 표를 만들기에는 한계가 존재함 이를 보완하기 위해 다음과 같은 패키지 활용 kableExtra: HTML 또는 LaTeX 용 표 생성 https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_pdf.pdf flextable + officer: HTML, 워드 문서 표 작성 https://davidgohel.github.io/flextable/ ```{r} knitr::kable(head(iris)) ``` Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa "],["inline-code.html", "5.4 인라인(inline) R 코드", " 5.4 인라인(inline) R 코드 문서의 모든 숫자를 인라인 R 코드를 통해 재현가능하게 생성 가능 인라인 R 코드는 `r 과 ` 사이에 변수 계산 스크립트를 입력해 작성 가능 예를 들어 `r 10 + 4` 는 14 출력 활용 예시 head(mtcars, 5) N &lt;- nrow(mtcars) mtcars 데이터셋에 포함된 자동차는 `r N ` 개다. \\(\\rightarrow\\) mtcars 데이터셋에 포함된 자동차는 32 개다. "],["yaml.html", "5.5 YAML", " 5.5 YAML R Markdown 문서의 가장 처음에 정의하는 metadata .Rmd 파일을 .md 파일로 변환 후 최종 출력문서 생성 시 필요한 pandoc의 옵션을 설정하는 것과 같은 의미임 일반적으로 문서 형태 및 생성을 위해 사용하는 R package (예: bookdown, officedown, rticles 등)에 따라 YAML 구성요소가 달라짐 기본 문법 /#: 주석 처리 YAML 문서의 시작과 끝은 --- 로 정의함 기본적으로 콜론(:)으로 구분된 태그(키): 값 쌍으로 구성됨 \\(\\rightarrow\\) key: value 여기서 콜론 바로 다음에는 반드시 공백문자가 있어야 함 한 key의 하위 키는 리스트 형태로 표현하고, 하위 키는 두 개 이상의 스페이스로 공백을 주어 표현 --- key : value subkey1: value1 subkey2: value2 subsubkey1: value3 --- R Markdown 기본 YAML 구조 --- title: &quot;문서 제목&quot; # 일반적으로 따옴표 사용 subtitle: &quot;문서 부제목&quot; author: &quot;문서 작성자&quot; date: &quot;문서 작성일자&quot; output: - &quot;html_document&quot; - &quot;word_document&quot; - &quot;pdf_document&quot; - &quot;md_document&quot; - &quot;isoslides_presentation&quot; - &quot;slidy_presentation&quot; - &quot;beamer_presentation&quot; bibliography: 참고문헌.bib # bibtex 서식 활용 . . . --- https://bookdown.org/yihui/rmarkdown/documents.html 에 자세한 예시 참고 "],["rmarkdown-citation.html", "5.6 참고문헌 인용", " 5.6 참고문헌 인용 참고문헌 정보가 BibTeX 포맷으로 저장된 .bib 파일을 YAML에 선언 후 인용 가능 참고문헌 표현: [@citation-identifier] 또는 @citation-identifier BibTeX 포맷은 Google Scholar 에서 쉽게 획득 가능 Citation 스타일은 YAML 헤더에 csl: style.csl로 변경 가능하며 Zotero 에서 .csl 파일 다운로드 가능 "],["r-외부-데이터-입출력.html", "6 R 외부 데이터 입출력", " 6 R 외부 데이터 입출력 R 기본 함수를 이용해서 데이터 저장 파일의 가장 기본적인 형태인 텍스트 파일을 읽고 저장하는 방법에 대해 먼저 살펴봄. Base R에서 외부 데이터를 읽고 저장을 위한 함수는 매우 다양하지만 가장 많이 사용되고 있는 함수들에 대해 살펴볼 것임 기본 R(base R)에서 제공하는 함수를 이용해 외부 데이터를 읽고, 내보내고, 저장하는 방법에 대해 살펴봄. 가장 일반적인 형태의 데이터는 보통 텍스트 파일 형태로 저장되어 있음, 일반적으로 첫 번째 줄: 변수명 두 번째 줄 부터: 데이터 입력 id sex age edulev height 1 Male 65 12 168 2 Female 74 9 145 3 Male 61 12 171 4 Male 85 6 158 5 Female 88 0 134 데이터의 자료값과 자료값을 구분하는 문자를 구분자(separator)라고 하며 주로 공백(), 콤마(,), tab 문자(\\t) 등이 사용됨 주로 확장자 명이 *.txt 이며, 콤마 구분자인 경우 보통은 *.csv (comma separated values)로 저장 #titanic3.csv 파일 일부 &quot;pclass&quot;,&quot;survived&quot;,&quot;name&quot;,&quot;sex&quot;,&quot;age&quot;, 1,1,&quot;Allen, Miss. Elisabeth Walton&quot;,&quot;female&quot; 1,1,&quot;Allison, Master. Hudson Trevor&quot;,&quot;male&quot; 1,0,&quot;Allison, Miss. Helen Loraine&quot;, &quot;female&quot; 1,0,&quot;Allison, Mr. Hudson Joshua Creighton&quot;,&quot;male&quot; 1,0,&quot;Allison, Mrs. Hudson J C (Bessie Waldo Daniels)&quot;,&quot;female&quot; "],["text-import-export.html", "6.1 텍스트 파일 입출력", " 6.1 텍스트 파일 입출력 외부 데이터를 불러온다는 것은 외부에 저장되어 있는 파일을 R 작업환경으로 읽어온다는 의미이기 때문에, 현재 작업공간의 작업 디렉토리(working directory) 확인이 필요. read.table()/write.table(): 가장 범용적으로 외부 텍스트 데이터를 R 작업공간으로 데이터 프레임으로 읽고 저장하는 함수 텍스트 파일의 형태에 따라 구분자 지정 가능 # read.table(): 텍스트 파일 읽어오기 read.table( file, # 파일명. 일반적으로 폴더명 구분자 # 보통 folder/파일이름.txt 형태로 입력 header = FALSE, # 첫 번째 행을 헤더(변수명)으로 처리할 지 여부 sep = &quot;&quot;, # 구분자 &quot;,&quot;, &quot;\\t&quot; 등의 형태로 입력 comment.char = &quot;#&quot;, # 주석문자 지정 stringsAsFactors = TRUE, # 문자형 변수를 factor으로 변환할 지 여부 encoding = &quot;unknown&quot; # 텍스트의 encoding 보통 CP949 또는 UTF-8 # 한글이 입력된 데이터가 있을 때 사용 ) read.table() 예시 예시에 사용된 데이터들은 Clinical trial data analysis using R (Chen and Peace 2010)에서 제공되는 데이터임. # tab 구분자 데이터 불러오기 # dataset 폴더에 저장되어 있는 DBP.txt 파일 읽어오기 dbp &lt;- read.table(&quot;dataset/DBP.txt&quot;, sep = &quot;\\t&quot;, header = TRUE) str(dbp) &#39;data.frame&#39;: 40 obs. of 9 variables: $ Subject: int 1 2 3 4 5 6 7 8 9 10 ... $ TRT : chr &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ... $ DBP1 : int 114 116 119 115 116 117 118 120 114 115 ... $ DBP2 : int 115 113 115 113 112 112 111 115 112 113 ... $ DBP3 : int 113 112 113 112 107 113 100 113 113 108 ... $ DBP4 : int 109 103 104 109 104 104 109 102 109 106 ... $ DBP5 : int 105 101 98 101 105 102 99 102 103 97 ... $ Age : int 43 51 48 42 49 47 50 61 43 51 ... $ Sex : chr &quot;F&quot; &quot;M&quot; &quot;F&quot; &quot;F&quot; ... # 문자형 값들을 factor로 변환하지 않는 경우 dbp2 &lt;- read.table(&quot;dataset/DBP.txt&quot;, sep = &quot;\\t&quot;, header = TRUE, stringsAsFactors = FALSE) str(dbp2) &#39;data.frame&#39;: 40 obs. of 9 variables: $ Subject: int 1 2 3 4 5 6 7 8 9 10 ... $ TRT : chr &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ... $ DBP1 : int 114 116 119 115 116 117 118 120 114 115 ... $ DBP2 : int 115 113 115 113 112 112 111 115 112 113 ... $ DBP3 : int 113 112 113 112 107 113 100 113 113 108 ... $ DBP4 : int 109 103 104 109 104 104 109 102 109 106 ... $ DBP5 : int 105 101 98 101 105 102 99 102 103 97 ... $ Age : int 43 51 48 42 49 47 50 61 43 51 ... $ Sex : chr &quot;F&quot; &quot;M&quot; &quot;F&quot; &quot;F&quot; ... # 데이터 형태 파악 head(dbp) # 콤마 구분자 데이터 불러오기 # dataset 폴더에 저장되어 있는 diabetes_csv.txt 파일 읽어오기 diab &lt;- read.table(&quot;dataset/diabetes_csv.txt&quot;, sep = &quot;,&quot;, header = TRUE) str(diab) &#39;data.frame&#39;: 403 obs. of 19 variables: $ id : int 1000 1001 1002 1003 1005 1008 1011 1015 1016 1022 ... $ chol : int 203 165 228 78 249 248 195 227 177 263 ... $ stab.glu: int 82 97 92 93 90 94 92 75 87 89 ... $ hdl : int 56 24 37 12 28 69 41 44 49 40 ... $ ratio : num 3.6 6.9 6.2 6.5 8.9 ... $ glyhb : num 4.31 4.44 4.64 4.63 7.72 ... $ location: chr &quot;Buckingham&quot; &quot;Buckingham&quot; &quot;Buckingham&quot; &quot;Buckingham&quot; ... $ age : int 46 29 58 67 64 34 30 37 45 55 ... $ gender : chr &quot;female&quot; &quot;female&quot; &quot;female&quot; &quot;male&quot; ... $ height : int 62 64 61 67 68 71 69 59 69 63 ... $ weight : int 121 218 256 119 183 190 191 170 166 202 ... $ frame : chr &quot;medium&quot; &quot;large&quot; &quot;large&quot; &quot;large&quot; ... $ bp.1s : int 118 112 190 110 138 132 161 NA 160 108 ... $ bp.1d : int 59 68 92 50 80 86 112 NA 80 72 ... $ bp.2s : int NA NA 185 NA NA NA 161 NA 128 NA ... $ bp.2d : int NA NA 92 NA NA NA 112 NA 86 NA ... $ waist : int 29 46 49 33 44 36 46 34 34 45 ... $ hip : int 38 48 57 38 41 42 49 39 40 50 ... $ time.ppn: int 720 360 180 480 300 195 720 1020 300 240 ... head(diab) # Encoding이 다른 경우(한글데이터 포함): # 한약재 사전 데이터 (CP949 encoding으로 저장) # tab 구분자 데이터 사용 # UTF-8로 읽어오기 herb &lt;- read.table(&quot;dataset/herb_dic_sample.txt&quot;, sep = &quot;\\t&quot;, header = TRUE, encoding = &quot;UTF-8&quot;, stringsAsFactors = FALSE) head(herb) # CP949로 읽어오기 herb &lt;- read.table(&quot;dataset/herb_dic_sample.txt&quot;, sep = &quot;\\t&quot;, header = TRUE, encoding = &quot;CP949&quot;, stringsAsFactors = FALSE) head(herb) read.table() + textConnection(): 웹사이트나 URL에 있는 데이터를 Copy + Paste 해서 읽어올 경우 유용하게 사용 textConnection(): 텍스트에서 한 줄씩 읽어 문자형 벡터처럼 인식할 수 있도록 해주는 함수 # Plasma 데이터: http://lib.stat.cmu.edu/datasets/Plasma_Retinol input1 &lt;- (&quot;64 2 2 21.4838 1 1298.8 57 6.3 0 170.3 1945 890 200 915 76 2 1 23.87631 1 1032.5 50.1 15.8 0 75.8 2653 451 124 727 38 2 2 20.0108 2 2372.3 83.6 19.1 14.1 257.9 6321 660 328 721 40 2 2 25.14062 3 2449.5 97.5 26.5 0.5 332.6 1061 864 153 615 72 2 1 20.98504 1 1952.1 82.6 16.2 0 170.8 2863 1209 92 799 40 2 2 27.52136 3 1366.9 56 9.6 1.3 154.6 1729 1439 148 654 65 2 1 22.01154 2 2213.9 52 28.7 0 255.1 5371 802 258 834 58 2 1 28.75702 1 1595.6 63.4 10.9 0 214.1 823 2571 64 825 35 2 1 23.07662 3 1800.5 57.8 20.3 0.6 233.6 2895 944 218 517 55 2 2 34.96995 3 1263.6 39.6 15.5 0 171.9 3307 493 81 562&quot;) input2 &lt;- (&quot;AGE: Age (years) SEX: Sex (1=Male, 2=Female). SMOKSTAT: Smoking status (1=Never, 2=Former, 3=Current Smoker) QUETELET: Quetelet (weight/(height^2)) VITUSE: Vitamin Use (1=Yes, fairly often, 2=Yes, not often, 3=No) CALORIES: Number of calories consumed per day. FAT: Grams of fat consumed per day. FIBER: Grams of fiber consumed per day. ALCOHOL: Number of alcoholic drinks consumed per week. CHOLESTEROL: Cholesterol consumed (mg per day). BETADIET: Dietary beta-carotene consumed (mcg per day). RETDIET: Dietary retinol consumed (mcg per day) BETAPLASMA: Plasma beta-carotene (ng/ml) RETPLASMA: Plasma Retinol (ng/ml)&quot;) plasma &lt;- read.table(textConnection(input1), sep = &quot;\\t&quot;, header = F) codebook &lt;- read.table(textConnection(input2), sep = &quot;:&quot;, header = F) varname &lt;- gsub(&quot;^\\\\s+&quot;, &quot;&quot;, codebook$V1) # 변수명 지정 names(plasma) &lt;- varname head(plasma) write.table(): R의 객체(벡터, 행렬, 데이터 프레임)를 저장 후 외부 텍스트 파일로 내보내기 위한 함수 # write.table() R 객체를 텍스트 파일로 저장하기 write.table( data_obj, # 저장할 객체 이름 file, # 저장할 위치 및 파일명 또는 # 또는 &quot;파일쓰기&quot;를 위한 연결 명칭 sep, # 저장 시 사용할 구분자 row.names = TRUE # 행 이름 저장 여부 ) 예시 # 위에서 읽어온 plasma 객체를 dataset/plasma.txt 로 내보내기 # 행 이름은 생략, tab으로 데이터 구분 write.table(plasma, &quot;dataset/plasma.txt&quot;, sep = &quot;\\t&quot;, row.names = F) 파일명 대신 Windows clipboard 로 내보내기 가능 # clipboard로 복사 후 excel 시트에 해당 데이터 붙여넣기 # Ctrl + V write.table(plasma, &quot;clipboard&quot;, sep = &quot;\\t&quot;, row.names = F) read.csv()/write.csv(): read.table() 함수의 wrapper 함수로 구분자 인수 sep이 콤마(,)로 고정(예시 생략) References "],["binary-import-export.html", "6.2 R 바이너리(binary) 파일 입출력", " 6.2 R 바이너리(binary) 파일 입출력 R 작업공간에 존재하는 한 개 이상의 객체들을 저장하고 읽기 위한 함수 R 데이터 관련 바이너리 파일은 한 개 이상의 객체가 저장된 바이너리 파일인 경우 *.Rdata 형태를 갖고, 단일 객체를 저장할 경우 보통 *.rds 파일 확장자로 저장 *.Rdata 입출력 함수 load(): *.Rdata 파일 읽어오기 save(): 한 개 이상 R 작업공간에 존재하는 객체를 .Rdata 파일로 저장 save.image(): 현재 R 작업공간에 존재하는 모든 객체를 .Rdata 파일로 저장 # 현재 작업공간에 존재하는 모든 객체를 &quot;output&quot; 폴더에 저장 # output 폴더가 존재하지 않는 경우 아래 명령 실행 # dir.create(&quot;output&quot;) ls() [1] &quot;codebook&quot; &quot;dbp&quot; &quot;dbp2&quot; &quot;def.chunk.hook&quot; [5] &quot;diab&quot; &quot;hook_output&quot; &quot;input1&quot; &quot;input2&quot; [9] &quot;plasma&quot; &quot;varname&quot; save.image(file = &quot;output/all_obj.Rdata&quot;) rm(list = ls()) ls() character(0) # 저장된 binary 파일(all_obj.Rdata) 불러오기 load(&quot;output/all_obj.Rdata&quot;) ls() [1] &quot;codebook&quot; &quot;dbp&quot; &quot;dbp2&quot; &quot;def.chunk.hook&quot; [5] &quot;diab&quot; &quot;hook_output&quot; &quot;input1&quot; &quot;input2&quot; [9] &quot;plasma&quot; &quot;varname&quot; # dnp, plasma 데이터만 output 폴더에 sub_obj.Rdata로 저장 save(dbp, plasma, file = &quot;output/sub_obj.Rdata&quot;) rm(list = c(&quot;dbp&quot;, &quot;plasma&quot;)) ls() [1] &quot;codebook&quot; &quot;dbp2&quot; &quot;def.chunk.hook&quot; &quot;diab&quot; [5] &quot;hook_output&quot; &quot;input1&quot; &quot;input2&quot; &quot;varname&quot; # sub_obj.Rdata 파일 불러오기 load(&quot;output/sub_obj.Rdata&quot;) ls() [1] &quot;codebook&quot; &quot;dbp&quot; &quot;dbp2&quot; &quot;def.chunk.hook&quot; [5] &quot;diab&quot; &quot;hook_output&quot; &quot;input1&quot; &quot;input2&quot; [9] &quot;plasma&quot; &quot;varname&quot; *.rds 입출력 함수 readRDS()/ saveRDS(): 단일 객체가 저장된 *.rds 파일을 읽거나 저장 대용량 데이터를 다룰 때 유용함 read.table() 보다 데이터를 읽는 속도가 빠르며, 다른 확장자 명의 텍스트 파일보다 높은 압축율을 보임 # 대용량 파일 dataset/pulse.csv 불러오기 # system.time(): 명령 실행 시가 계산 함수 system.time(pulse &lt;- read.csv(&quot;dataset/pulse.csv&quot;, header = T)) 사용자 시스템 elapsed 4.626 0.043 4.673 # saveRDS()함수를 이용해 output/pulse.rds 파일로 저장 saveRDS(pulse, &quot;output/pulse.rds&quot;) rm(pulse); ls() [1] &quot;codebook&quot; &quot;dbp&quot; &quot;dbp2&quot; &quot;def.chunk.hook&quot; [5] &quot;diab&quot; &quot;hook_output&quot; &quot;input1&quot; &quot;input2&quot; [9] &quot;plasma&quot; &quot;varname&quot; system.time(pulse &lt;- readRDS(&quot;output/pulse.rds&quot;)) 사용자 시스템 elapsed 0.081 0.000 0.081 "],["import-export-excel.html", "6.3 Excel 파일 입출력", " 6.3 Excel 파일 입출력 R에서 기본적으로 제공하는 파일 입출력 함수는 대부분 텍스트 파일(*.txt, *.csv, *.tsv10)을 대상으로 하고 있음 readr 패키지에서도 이러한 원칙은 유지됨 Excel 파일을 R로 읽어오기(과거 방법) *.xls 또는 *.xlsx 파일을 엑셀로 읽은 후 해당 데이터를 위 텍스트 파일 형태로 내보낸 후 해당 파일을 R로 읽어옴 xlsx 패키지 등을 이용해 엑셀 파일을 직접 읽어올 수 있으나, Java 기반으로 개발된 패키지이기 때문에 Java Runtime Environment를 운영체제에 설치해야만 작동 최근 tidyverse 중 하나인 readxl 패키지를 이용해 간편하게 R 작업환경에 엑셀 파일을 읽어오는 것이 가능(Hadley Wickham이 개발…) tidyverse의 한 부분임에도 불구하고 tidyverse 패키지 번들에는 포함되어 있지 않기 때문에 별도 설치 필요 readxl 패키지 구성 주요 함수 read_xls(), read_xlsx(), read_excel: 엑셀 파일을 읽어오는 함수로 각각 Excel 97 ~ 2003, Excel 2007 이상, 또는 버전 상관 없이 저장된 엑셀 파일에 접근함 excel_sheets(): 엑셀 파일 내 시트 이름 추출 \\(\\rightarrow\\) 한 엑셀 파일의 복수 시트에 데이터가 저장되어 있는 경우 활용 예시: 2020년 4월 23일 COVID-19 유병률 데이터 (Our World in Data) read_xlsx( path, # Excel 폴더 및 파일 이름 sheet = NULL, # 불러올 엑셀 시트 이름 # default = 첫 번째 시트 col_names = TRUE, # read_csv()의 인수와 동일한 형태 입력 col_types = NULL # read_csv()의 인수와 동일한 형태 입력 ) # 2020년 4월 21일자 COVID-19 국가별 유별률 및 사망률 집계 자료 # dataset/owid-covid-data.xlsx 파일 불러오기 # install.packages(&quot;readxl&quot;) require(readxl) 필요한 패키지를 로딩중입니다: readxl covid19 &lt;- read_xlsx(&quot;dataset/covid-19-dataset/owid-covid-data.xlsx&quot;) covid19 # 여러 시트를 동시에 불러올 경우 # dataset/datR4CTDA.xlsx 의 모든 시트 불러오기 path &lt;- &quot;dataset/datR4CTDA.xlsx&quot; sheet_name &lt;- excel_sheets(path) dL &lt;- lapply(sheet_name, function(x) read_xlsx(path, sheet = x)) names(dL) &lt;- sheet_name "],["control-structure.html", "7 제어문(Control Structure)", " 7 제어문(Control Structure) Sketch 프로그램 안의 특정 구문을 주어진 조건에 맞게 실행 여부를 제어하거나 동일한 작업을 반복할 수 있을까? 프로그램을 통해 특정 목적을 위한 나만의 함수를 만들 수 있을까? Figure 5.1: Flow-control example (https://homerhanumat.github.io/r-notes/flow.html) 참고: 본 장의 내용은 데이터과학 민주화와 Beginning Computer Programming with R의 내용을 기반으로 재구성함 "],["condition.html", "7.1 조건문(Conditionals)", " 7.1 조건문(Conditionals) if 구문을 통해 조건문 생성 불린 표현식(boolean expression): 참(TRUE) 또는 거짓(FALSE) 두 값 중 하나로 값이 도출되는 표현식11 비교 연산자(comparison operators) 같다, 같지 않다, 크다 등을 표현하기 위한 연산자 ==, !=, &gt;, &lt;, &gt;=, &lt;= 논리 연산자(logical operator) AND (&amp;, &amp;&amp;), OR (|, ||), NOT (!) x &lt;- 10; y &lt;- 13 # x가 2의 배수이고 y가 3의 배수 # 두 조건이 모두 참이여야 참 x %% 2 == 0 &amp; y %% 3 == 0 # x가 2의 배수이거나 y가 3의 배수 # 두 개 조건 중 하나만 참을 만족하면 참임 x %% 2 == 0 | y %% 3 == 0 # NOT (x &gt; y) !(x &gt; y) # 부정에 부정은 참 [1] FALSE [1] TRUE [1] TRUE 7.1.1 기본 구문 if (조건) 표현식 └ 괄호 안 조건을 만족하면 표현식을 실행하고 조건을 만족하지 않으면 실행하지 않음 x &lt;- 10 if (x &gt; 0) { print(&quot;x is positive&quot;) } x &lt;- -5 if (x &gt; 0) { print(&quot;x is positive&quot;) } [1] &quot;x is positive&quot; Figure 7.1: if 구문 기본 flow-chart if 구문의 사용 규칙 if 문은 조건을 정의하는 헤더 부분((, ))과 표현식이 위치하는 몸통 블록(body block, {표현식}) 으로 구성됨 (, )에 표현되는 조건은 벡터가 아닌 단일 값으로 나타내야 함. {, } 의 표현 또는 문장이 한 줄인 경우 블록 지정이 필요하지 않지만, 두 줄 이상인 경우 if 문의 범위를 지정해줘야 하기 때문에 꼭 중괄호(curly bracket, {})가 사용되야 함. # 조건문 사용 예시 x &lt;- c(TRUE, FALSE, FALSE) y &lt;- c(TRUE, TRUE, FALSE) z &lt;- &quot;Both TRUE!!&quot; if (x[1] &amp; y[1]) print(z) # x, y 첫 번째 원소만 사용 if (x &amp;&amp; y) print(z) # 강제로 첫 번째 원소만 사용 if (x &amp; y) print(z) # 경고 표시 Warning in if (x &amp; y) print(z): length &gt; 1 이라는 조건이 있고, 첫번째 요소만이 사용될 것입니다 [1] &quot;Both TRUE!!&quot; [1] &quot;Both TRUE!!&quot; [1] &quot;Both TRUE!!&quot; 대안 실행(alternative execution) 두 가지 경우가 존재하고 조건에 따라 어떤 명령을 실행할지를 결정 if와 else로 표현 가능 조건에 따라 실행이 분기(branch) 되기 때문에 if-else 구문을 분기문이라고도 함 else 는 if 조건을 배제(exclusive)한 나머지 경우이기 때문에 조건을 따로 지정하지 않으며, if와 동일하게 중괄호 내에 표현되어야 함 x &lt;- 9 if (x %% 2 == 0) { print(&quot;x is even&quot;) } else { print(&quot;x is odd&quot;) } [1] &quot;x is odd&quot; Figure 7.2: 대안실행(if-else 구문) flow-chart 7.1.2 연쇄 조건문(chained condition) 두 가지 이상의 분기가 존재하는 경우 조건 표현식 연쇄 조건문의 표현은 아래와 같음 if (조건1) { 표현식1 ... } else if (조건2) { 표현식2 ... } else { 표현식3 ... } x &lt;- 5; y &lt;- 10 if (x &lt; y) { print(&quot;x is less than y&quot;) } else if (x &gt; y) { print(&quot;x is greater than y&quot;) } else { print(&quot;x is equal to y&quot;) } [1] &quot;x is less than y&quot; Figure 7.3: 연쇄조건(if-else if-else 구문) flow-chart 7.1.3 중첩 조건문(nested contition) 하나의 조건문 내부에 하위 조건식이 존재하는 형태 if (조건1) { 표현식1 ... } else { if (조건2) { 표현식2 ... } else { 표현식3 ... } } x &lt;- 10; y &lt;- 10 if (x == y) { print(&quot;x is equal to y&quot;) } else { if (x &gt; y) { print(&quot;x is greater than y&quot;) } else { print(&quot;x is less than y&quot;) } } [1] &quot;x is equal to y&quot; Figure 7.4: 중첩 조건문 flow-chart 중첩 조건문은 코드의 가독성을 떨어뜨리기 때문에 피하는 것을 권장 중첩 조건문을 피하기 위한 한 가지 방법은 논리 연산자를 활용 # 중첩조건 x &lt;- 58 if (x &gt; 0) { if (x &lt; 10) { print(&quot;x는 한 자리 양수&quot;) } else { if (x &lt; 100) { print(&quot;x는 두 자리 양수&quot;) } else { print(&quot;x는 세 자리 이상 양수&quot;) } } } [1] &quot;x는 두 자리 양수&quot; # 연쇄 조건 x &lt;- 2020 if (x &gt; 0 &amp; x &lt; 10) { print(&quot;x는 한 자리 양수&quot;) } else if (x &gt;=10 &amp; x &lt; 100) { print(&quot;x는 두 자리 양수&quot;) } else { print(&quot;x는 세 자리 이상 양수&quot;) } [1] &quot;x는 세 자리 이상 양수&quot; 7.1.4 ifelse() 함수 if-else 구문을 사용하기 쉽게 구현된 R 내장 함수 if-else 구문과 다르게 조건 부분에 한 값(스칼라)이 아닌 논리형 벡터를 입력값으로 받아 조건에 따른 값(벡터)을 반환 # ifelse() 함수 인수 # help(ifelse) 참고 ifelse( test, 조건에 따른 논리형 벡터 yes, test에 정의한 조건이 참인 경우 새로운 벡터에 대입할 값 no, test 조건이 거짓인 경우 대입할 값 ) 사용 예시 # 평균이 23이고 표준편차가 5인 정규분포로부터 30개의 난수 추출 set.seed(12345) bmi &lt;- rnorm(30, 23, 5) bmi_cat &lt;- ifelse(bmi &lt; 25, &quot;normal&quot;, &quot;overweight&quot;) bmi_cat [1] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; [6] &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;normal&quot; [11] &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [16] &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [21] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;normal&quot; [26] &quot;overweight&quot; &quot;normal&quot; &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; # ifelse() 함수를 연쇄조건문 처럼 사용할 수 있다 bmi_cat2 &lt;- ifelse(bmi &lt; 18.5, &quot;underweight&quot;, ifelse(bmi &lt; 24.9, &quot;normal&quot;, ifelse(bmi &lt; 29.9, &quot;overweight&quot;, &quot;obesity&quot;))) bmi_cat2 [1] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; [6] &quot;underweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;underweight&quot; [11] &quot;normal&quot; &quot;obesity&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [16] &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [21] &quot;overweight&quot; &quot;obesity&quot; &quot;normal&quot; &quot;underweight&quot; &quot;underweight&quot; [26] &quot;obesity&quot; &quot;normal&quot; &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; "],["looping.html", "7.2 반복문(Looping)", " 7.2 반복문(Looping) Prerequisite 프로그램 또는 알고리즘 구현 시 특정 문장 또는 표현을 반복해야만 하는 상황이 발생 특히 시뮬레이션 시 반복문은 거의 필수적임 반복문을 통해 코딩의 효율을 극대화 할 수 있음 반복문은 특정 변수의 값을 갱신(update) 하기 위해 주로 사용 x &lt;- x + 1 # 현재 값에 1을 더해서 x를 새로운 값으로 update 통상적으로 특정 변수의 값을 갱신하기 위해 변수 값을 초기화(initialize) x &lt;- 0 # x 변수 초기화 x &lt;- x + 1 몇 번 반복이라는 정의가 없는 상태에서 특정 조건이 거짓(FALSE)이 될 때 까지 계속 반복 7.2.1 repeat 구문 repeat 표현식 repeat 다음에 오는 표현식을 무한 반복(infinite loop) repeat print(&quot;무한 루프에 걸림...ESC 키 누르시오!!&quot;) [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; ... ... 특정 작업에 대해 블록을 지정(중괄호)하고 블록 안에 표현 가능 일반적으로 특정 조건(if (조건) break)을 두어 무한루프에서 탈출 if 문의 조건은 언제 반복이 끝날 지를 제어하는 변수로 반복변수(iteration variable) 이라고도 함 언제까지(until) 반복(repeat) \\(\\rightarrow\\) REPEAT-UNTIL 구문으로 표현 repeat { 표현식 1 if (조건) break 반복변수 update } Figure 7.5: REPEAT 구문 flow-chart # REPEAT-UNTIL 예시 1 # 1:100 까지 합 계산 함수 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) repeat { tot &lt;- tot + i if (i &gt;= 100) break # i는 반복 변수 i &lt;- i + 1 } tot # check sum(1:100) [1] 5050 [1] 5050 tot에 i를 더한 후 i 가 조건을 만족하는지 확인 조건에 부합하지 않으면 다음 문장 실행(i에 1을 증가 후 업데이트) 1. 의 작업을 반복(loop) i가 조건에 부합하면 반복 종료 # REPEAT 예시 2 # 1에서 20 사이 숫자 알아맞추기 게임 set.seed(1) n &lt;- 20 number &lt;- sample(1:n, size = 1) cat(&quot;1에서 &quot;, n, &quot;까지 숫자 알아 맞추기&quot;, sep = &quot;&quot;) repeat { guess &lt;- readline(&quot;어떤 숫자를 생각하시나요? (종료: q 입력) &quot;) if (guess == &quot;q&quot;) { cat(&quot;재미가 없나봐요.\\n&quot;) break } else if (as.numeric(guess) == number) { cat(&quot;천재인데요?ㅋㅋㅋ&quot;) break } # 틀리면 계속 반복 } guess에 readline() 으로부터 값 입력 guess 값이 q 이면 종료 guess 값이 number 와 일치하면 종료 2.와 3. 조건에 부합하지 않으면 guess 값을 반복적으로 입력 어떤 숫자를 생각하시나요? (종료: q 입력) 1 어떤 숫자를 생각하시나요? (종료: q 입력) 2 어떤 숫자를 생각하시나요? (종료: q 입력) 3 천재인데요?ㅋㅋㅋ 7.2.2 while 구문 while (조건) 표현식 ... while에 지정된 조건이 참이면 계속해서 반복 repeat는 반복이 처음부터 시작되는 반면, while 문은 조건을 먼저 평가한 후 반복이 시작됨. while (FALSE)인 경우 루프 본문 코드가 실행되지 않음 while (TRUE)는 repeat 구문과 동일 while문 의 일반적 형태 while (조건) { 표현식 1 반복변수 update } Figure 7.6: WHILE 구문 flow-chart # WHILE 구문 예시 1 # 1:100 까지 합 계산 함수 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) while (i &lt;= 100) { tot &lt;- tot + i i &lt;- i + 1 } tot [1] 5050 초기값 i가 조건 i &lt;= 100 인지 확인 참인 경우 tot + i를 통해 tot을 업데이트 한 다음 i를 1만큼 증가 만약 i에 대한 조건 평가 결과가 거짓이면 while 구문을 빠져나감 # while 문 조건이 TRUE 인 경우 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) while (TRUE) { tot &lt;- tot + i if (i &gt;= 100) break i &lt;- i + 1 } tot [1] 5050 while 의 조건이 참이기 때문에 무한 반복 단 i가 100과 같거나 클 경우 구문 탈출 그 전 까지는 tot와 i를 갱신 # WHILE 구문 예시 2 # 문자열 벡터에서 특정 문자열의 인덱스를 반환 txtvec &lt;- c(&quot;R&quot;, &quot;package&quot;, &quot;flow-control&quot;, &quot;while&quot;, &quot;if&quot;, &quot;for&quot;, &quot;repeat&quot;) found &lt;- FALSE i &lt;- 1 word &lt;- readline(&quot;검색할 텍스트: &quot;) while (!found &amp; i &lt;= length(txtvec)) { if (txtvec[i] == word) { found &lt;- TRUE break } cat(i, &quot; 번째 위치에 해당 단어가 존재하지 않습니다.\\n&quot;, sep=&quot;&quot;) i &lt;- i + 1 } if (found) { cat(i, &quot; 번째 위치에 &quot;, word, &quot;를 찾았습니다.&quot;, sep = &quot;&quot;) } else { cat(word, &quot; 단어는 해당 문자열 벡터에 존재하지 않습니다.\\n&quot;, sep = &quot;&quot;) } found = FALSE, i = 1을 초기값으로 입력 readline()으로 입력한 텍스트를 word에 저장 found 가 참이고 i가 텍스트 벡터의 길이 값과 같을 때 까지 다음 구문 반복 txtvec 각 원소와 word 값이 같은지 확인 while 입력 결과 1 번째 위치에 해당 단어가 존재하지 않습니다. 2 번째 위치에 해당 단어가 존재하지 않습니다. 3 번째 위치에 해당 단어가 존재하지 않습니다. 4 번째 위치에 while 를 찾았습니다. temp 입력 결과 1 번째 위치에 해당 단어가 존재하지 않습니다. 2 번째 위치에 해당 단어가 존재하지 않습니다. 3 번째 위치에 해당 단어가 존재하지 않습니다. 4 번째 위치에 해당 단어가 존재하지 않습니다. 5 번째 위치에 해당 단어가 존재하지 않습니다. 6 번째 위치에 해당 단어가 존재하지 않습니다. 7 번째 위치에 해당 단어가 존재하지 않습니다. temp 단어는 해당 문자열 벡터에 존재하지 않습니다. repeat, while과 같이 반복의 횟수가 지정되지 않는 반목구문을 불확정 반복문(indefinite loop)이라고 함. 다음에 배울 for 구문은 위 두 반복문과는 다르게 반복의 범위를 명확히 지정하기 때문에 확정 반복문(definite loop)라고 함. 7.2.3 for 구문 가장 많이 사용되는 반복구문으로 일반적인 형태는 아래와 같음 for (반복변수 in sequence) { 표현식 1 ... } R에서 sequence는 특정 유형의 벡터이며, 반복변수에 sequence의 원소를 순차적으로 할당함 반복변수는 for 반복문 안의 표현식 1에서 사용됨 Figure 7.7: FOR 구문 flow-chart #for 문 예시 1 student &lt;- read.table(&quot;dataset/students.txt&quot;, sep = &quot;\\t&quot;, header = TRUE) student_name &lt;- student$name for (s in student_name) { cat(s, &quot;학생!! R을 배우면 통계가 쉬워져요!!^^\\n&quot;) } 송은철 학생!! R을 배우면 통계가 쉬워져요!!^^ 윤지호 학생!! R을 배우면 통계가 쉬워져요!!^^ 노자홍 학생!! R을 배우면 통계가 쉬워져요!!^^ 박경민 학생!! R을 배우면 통계가 쉬워져요!!^^ 윤지우 학생!! R을 배우면 통계가 쉬워져요!!^^ 장민영 학생!! R을 배우면 통계가 쉬워져요!!^^ 권혁제 학생!! R을 배우면 통계가 쉬워져요!!^^ 김요한 학생!! R을 배우면 통계가 쉬워져요!!^^ 김진현 학생!! R을 배우면 통계가 쉬워져요!!^^ 박종현 학생!! R을 배우면 통계가 쉬워져요!!^^ 신지성 학생!! R을 배우면 통계가 쉬워져요!!^^ 오정우 학생!! R을 배우면 통계가 쉬워져요!!^^ 이명헌 학생!! R을 배우면 통계가 쉬워져요!!^^ 전지원 학생!! R을 배우면 통계가 쉬워져요!!^^ 조현모 학생!! R을 배우면 통계가 쉬워져요!!^^ 최소미 학생!! R을 배우면 통계가 쉬워져요!!^^ 김선재 학생!! R을 배우면 통계가 쉬워져요!!^^ 김지윤 학생!! R을 배우면 통계가 쉬워져요!!^^ 장유진 학생!! R을 배우면 통계가 쉬워져요!!^^ 김하진 학생!! R을 배우면 통계가 쉬워져요!!^^ 김민서 학생!! R을 배우면 통계가 쉬워져요!!^^ 김준섭 학생!! R을 배우면 통계가 쉬워져요!!^^ 남현준 학생!! R을 배우면 통계가 쉬워져요!!^^ 채승훈 학생!! R을 배우면 통계가 쉬워져요!!^^ 강현지 학생!! R을 배우면 통계가 쉬워져요!!^^ 권사랑 학생!! R을 배우면 통계가 쉬워져요!!^^ 김민선 학생!! R을 배우면 통계가 쉬워져요!!^^ 김민영 학생!! R을 배우면 통계가 쉬워져요!!^^ 박승원 학생!! R을 배우면 통계가 쉬워져요!!^^ 박우담 학생!! R을 배우면 통계가 쉬워져요!!^^ 소아영 학생!! R을 배우면 통계가 쉬워져요!!^^ 안성재 학생!! R을 배우면 통계가 쉬워져요!!^^ 이다빈 학생!! R을 배우면 통계가 쉬워져요!!^^ 이연하 학생!! R을 배우면 통계가 쉬워져요!!^^ 정진경 학생!! R을 배우면 통계가 쉬워져요!!^^ 조은아 학생!! R을 배우면 통계가 쉬워져요!!^^ 최보경 학생!! R을 배우면 통계가 쉬워져요!!^^ 한민형 학생!! R을 배우면 통계가 쉬워져요!!^^ 황연지 학생!! R을 배우면 통계가 쉬워져요!!^^ student_name의 첫 번째 원소를 s에 할당 for 구문 안에 표현 실행 student_name의 마지막 원소까지 반복 # 위 예시와 동일한 표현 ## 인덱싱을 사용 for (i in 1:length(student_name)) { cat(student_name[i], &quot;학생!! R을 배우면 통계가 쉬워져요!!^^\\n&quot;) } ## sequence를 만드는 함수 seq_along() 사용 for (i in seq_along(student_name)) { cat(student_name[i], &quot;학생!! R을 배우면 통계가 쉬워져요!!^^\\n&quot;) } for 구문 안에 for 문을 1개 이상 중첩 가능 ## 2중 for 문 예시 set.seed(12345) id &lt;- sample(1:length(student_name), 5) sel_student &lt;- student_name[id] for (i in seq_along(student_name)) { for (j in seq_along(sel_student)) { if (student_name[i] == sel_student[j]) { cat(sel_student[j], &quot;님!! 당첨 축하 드립니다!!\\n&quot;) } } } 전지원 님!! 당첨 축하 드립니다!! 최소미 님!! 당첨 축하 드립니다!! 채승훈 님!! 당첨 축하 드립니다!! 권사랑 님!! 당첨 축하 드립니다!! 김민영 님!! 당첨 축하 드립니다!! 불확정 반복문 학습 시 무한루프로부터 break를 통해 루프에서 탈출 루프를 완전히 탈출하지 않고 현재 반복을 중지하고 그 다음 반복을 진행하고 싶을 경우 next 예약어를 사용 # 알파벳 e와 일치하는 경우에만 텍스트 메세지 출력 vec &lt;- c(&quot;a&quot;,&quot;e&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;e&quot;, &quot;z&quot;) word &lt;- &quot;e&quot; for (i in 1:length(vec)) { if (vec[i] != word) next cat(word, &quot;가&quot;, i, &quot;번 째 인덱스에 있네요!!\\n&quot;) } e 가 2 번 째 인덱스에 있네요!! e 가 3 번 째 인덱스에 있네요!! e 가 7 번 째 인덱스에 있네요!! "],["function.html", "7.3 함수 (function)", " 7.3 함수 (function) Figure 7.8: 함수 함수: 특정한 목적을 위한 연산을 수행하기 위해 명명된 일련의 문장(추상화) 예: sum(x) \\(\\rightarrow\\) 벡터 x의 값을 모두 합산하는 함수로 “sum” 이라고 명명된 내장 함수 R 콘솔에서 함수 명칭(예: sum)을 입력 후 실행하면 함수 내부 확인 가능 sum function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) 함수의 명칭(위의 예에서 sum)으로 특정 합수를 호출(call) R의 스크립트는 내장된 혹은 사용자가 정의한 함수들을 호출함으로써 작성됨 함수를 사용해야만 하는 이유 매우 큰 프로그램 작업을 해야할 경우 함수를 통해 작업 단위 별로 분할 가능 한 번 작성한 함수는 재사용 가능 프로그램의 체계적 관리가 가능하기 때문에 유지 및 보수가 용이 프로그램 코드의 간결화 7.3.1 함수의 정의 function 이라는 R의 예약어를 통해 사용자 함수 정의 함수 정의 시 함수의 명칭을 반드시 부여해야 함 함수 이름 &lt;- function() 함수는 일반적으로 인수(argument)로 입력값을 전달 받으면 그 결과값을 반환(return) 함수의 인수와 반환에 따라 다음과 같이 4 가지 유형의 함수 정의 가능 인수를 갖는 함수 인수를 갖지 않는 함수 값을 반환하는 함수 값을 반환하지 않는 함수 # (1) 인수를 갖는 함수 ## (모)분산을 계산하는 함수 var_pop &lt;- function(x) { n &lt;- length(x) if (n &lt; 2) { stop(&quot;적어도 두 개 이상의 관찰값이 존재해야 합니다&quot;) } mx &lt;- mean(x) v &lt;- sum((x - mx)^2)/n return(v) # 결과를 반환하는 함수: v를 함수의 출력값으로 설정 } ## test set.seed(1) # 동일한 난수 생성을 위해 seed 번호 부여 x &lt;- rnorm(1) var_pop(x) Error in var_pop(x): 적어도 두 개 이상의 관찰값이 존재해야 합니다 set.seed(1000) x &lt;- rnorm(1000, 2, 4) # 평균이 2이고 표준편차가 4인 정규분포로부터 1000개 난수 추출 var_pop(x) [1] 15.40581 # (2) 인수를 갖지 않는 함수 print_lyrics_let_it_be &lt;- function() { print(&quot;When I find myself in times of trouble, &quot;) print(&quot;Mother Mary comes to me.&quot;) print(&quot;Speaking words of wisdom &#39;let it be&#39;.&quot;) } print_lyrics_let_it_be() [1] &quot;When I find myself in times of trouble, &quot; [1] &quot;Mother Mary comes to me.&quot; [1] &quot;Speaking words of wisdom &#39;let it be&#39;.&quot; print_lyrics_let_it_be(beatles) Error in print_lyrics_let_it_be(beatles): 사용되지 않은 인자 (beatles) ## 주사위를 돌리는 함수 rolling_dice &lt;- function() { sample(1:6, 1, replace = TRUE) } rolling_dice(); rolling_dice(); rolling_dice(); [1] 4 [1] 4 [1] 4 # (3) 값을 반환하는 함수 manual_mean &lt;- function(x) { n &lt;- length(x) sumi &lt;- 0 for (i in 1:n) { sumi &lt;- sumi + x[i] } return(sumi/n) } set.seed(20) x &lt;- sample(1:200, 20, replace = FALSE) # 1 ~ 200 중 랜덤하게 20개 추출(비복원) manual_mean(x) [1] 107 # 미리 정의하지 않은 인수를 입력한 경우 set.seed(4) na_idx &lt;- sample(1:length(x), 4) x[na_idx] &lt;- NA manual_mean(x, na.rm = TRUE) Error in manual_mean(x, na.rm = TRUE): 사용되지 않은 인자 (na.rm = TRUE) # (4) 값을 반환하지 않는 함수(void function) summary_mean &lt;- function(x, ...) { n &lt;- sum(!is.na(x)) mx &lt;- sum(x, ...)/n cat(&quot;Data: &quot;, sprintf(&quot;%.2f&quot;, x), &quot;\\n&quot;) # 소숫점 2째 짜리 까지 출력 cat(&quot;전체 관찰값 개수(결측 제외) = &quot;, n, &quot;\\n&quot;) cat(&quot;산술평균 = &quot;, mx, &quot;\\n&quot;) } set.seed(20) x &lt;- rnorm(20) summary_mean(x) Data: 1.16 -0.59 1.79 -1.33 -0.45 0.57 -2.89 -0.87 -0.46 -0.56 -0.02 -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 -0.09 0.39 전체 관찰값 개수(결측 제외) = 20 산술평균 = -0.1877639 result &lt;- summary_mean(x) Data: 1.16 -0.59 1.79 -1.33 -0.45 0.57 -2.89 -0.87 -0.46 -0.56 -0.02 -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 -0.09 0.39 전체 관찰값 개수(결측 제외) = 20 산술평균 = -0.1877639 result NULL x[na_idx] &lt;- NA # ...를 통해 미리 정하지 않은 인수를 # 함수 내부에서 호출한 다른 함수로 전달 가능 summary_mean(x, na.rm = TRUE) Data: 1.16 -0.59 NA -1.33 -0.45 0.57 NA -0.87 -0.46 -0.56 NA -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 NA 0.39 전체 관찰값 개수(결측 제외) = 16 산술평균 = -0.1590692 x &lt;- summary_mean(x, na.rm = TRUE) Data: 1.16 -0.59 NA -1.33 -0.45 0.57 NA -0.87 -0.46 -0.56 NA -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 NA 0.39 전체 관찰값 개수(결측 제외) = 16 산술평균 = -0.1590692 7.3.2 함수의 인수 전달 방법 함수는 입력값(input) 을 가지며, 이러한 입력값은 함수의 인수(argument)에 해당 값을 할당함으로써 입력값이 함수로 전달됨 함수의 인수 정의는 내 마음대로 가능(개수 무관) R에서 함수 호출 시 인수 전달은 “값”을 호출 하는 방식(call by value) call by value와 상반되는 개념으로 참조에 의한 호출(call by reference)로 값이 아니라 값이 저장되어 있는 메모리의 주소 값을 전달하는 방식(대표적인 예: C 언어의 포인터)임. 계산 효율은 참조에 의한 호출이 월등히 뛰어나지만, 프로그램의 구조가 복잡하다는 단점을 가짐. R은 데이터 분석에 특화된 프로그램이기 때문에 직관적인 call by value 방식을 택함. 예시 # 두 변수의 값을 바꾸는 함수: swap swap &lt;- function(x, y) { temp &lt;- x x &lt;- y y &lt;- temp cat(&quot;두 값이 바뀌었습니다.&quot;, sprintf(&quot;x = %d, y = %d&quot;, x, y) ,&quot;\\n&quot;) } x &lt;- 3; y &lt;- 10 swap(x, y) 두 값이 바뀌었습니다. x = 10, y = 3 x; y # x, y 두 값이 바뀌지 않음 [1] 3 [1] 10 인수를 전달하는 방법은 다음 두 가지임 인수의 위치 순서에 의한 전달: 정의한 인수의 순서대로 각 인수에 대응하는 값을 전달 인수의 이름에 의한 전달: 위치와 관계 없이 정의한 인수의 이름을 지정하여 값을 전달 # 표준편차 계산 함수: stdev stdev &lt;- function(x, na.rm = TRUE) { if (is.matrix(x)) apply(x, 2, sd, na.rm = na.rm) else if (is.vector(x)) sqrt(var(x, na.rm = na.rm)) else if (is.data.frame(x)) sapply(x, sd, na.rm = na.rm) else sqrt(var(as.vector(x), na.rm = na.rm)) } set.seed(1000) X &lt;- matrix(rnorm(1000), 100, 10) x &lt;- rpois(50, lambda = 10) # 포아송 분포(lambda = 10)에서 50개 난수 추출 dat &lt;- mtcars # R 내장 데이터를 dat 에 저장 # (1) 순서에 의한 전달 stdev(X, T); stdev(X) # 동일한 결과 [1] 1.0065940 0.9033927 0.9727257 0.9905631 0.8202803 1.0114516 0.9855547 [8] 1.0211373 1.0716219 1.0426811 [1] 1.0065940 0.9033927 0.9727257 0.9905631 0.8202803 1.0114516 0.9855547 [8] 1.0211373 1.0716219 1.0426811 stdev(x) [1] 3.41569 stdev(dat) mpg cyl disp hp drat wt 6.0269481 1.7859216 123.9386938 68.5628685 0.5346787 0.9784574 qsec vs am gear carb 1.7869432 0.5040161 0.4989909 0.7378041 1.6152000 stdev(TRUE, dat) # 오류 why?? Warning in if (na.rm) &quot;na.or.complete&quot; else &quot;everything&quot;: length &gt; 1 이라는 조건 이 있고, 첫번째 요소만이 사용될 것입니다 Error in if (na.rm) &quot;na.or.complete&quot; else &quot;everything&quot;: argument is not interpretable as logical # (2) 이름에 의한 전달 set.seed(5) na_idx &lt;- sample(1:50, 5) x[na_idx] &lt;- NA stdev(na.rm = T, x = x) [1] 3.411211 stdev(dat = dat, na.rm = TRUE) # 오류 why??? Error in stdev(dat = dat, na.rm = TRUE): 사용되지 않은 인자 (dat = dat) 7.3.3 함수의 기본 구성 요소 Figure 7.9: 함수의 기본 구조 function()에서 () 안의 부분(일반적으로 첫 번째 줄)을 머리(header) 부분 함수의 초기 형태(매개변수 또는 인수의 형태)를 지정 연산 또는 명령이 수행되는 부분은 함수의 몸통(body) 부분({} 로 표시) 함수 내부에서 실행되는 연산 명령어들의 집합으로 구성 인수(argument): 함수의 기능을 선택적으로 조정하는 parameter로 함수 안에서 작동하는 매개변수들을 통칭 인수는 argument 또는 argument = default value로 설정 복수의 인수는 콤마(,)로 구분 \\(\\rightarrow\\) fun_name &lt;- function(arg1, arg2, arg3) 특수 인수 ...: 어떠한 개수의 인수를 함수로 전달할 수 있음 일반적으로 인수의 개수가 불특정하거나 함수 안에서 다른 함수를 호출할 때 특정 인수를 다른 함수로 전달시킬 때 유용(위 예시 참고) # (1) 인수에 default 값을 주지 않은 함수 fun_without_arg_default &lt;- function(x, y) { x*y } set.seed(10) a &lt;- sample(1:20, 10, replace = TRUE) # 복원 추출 a[7] &lt;- NA b &lt;- 5 fun_without_arg_default(a, b) [1] 55 45 50 80 60 40 NA 95 75 75 # (2) 인수에 default 값을 부여한 함수 fun_with_arg_default &lt;- function(x = 5, y = 8) { x*y } fun_with_arg_default() [1] 40 trim_mean &lt;- function(x, trim = 0, na.rm = F) { mean(x, trim = trim, na.rm = na.rm) } trim_mean(a) [1] NA trim_mean(x = a, trim = 0.2, na.rm = TRUE) # 인수 이름으로 값 전달 [1] 12.57143 trim_mean(a, 0.3, TRUE) # 인수 순서대로 값 전달 [1] 12.6 # (3) ... 인수 사용 예제 # list() 함수를 이용해 `...`에 해당하는 인수들을 리스트 객체로 만든 후 # 이를 함수에서 사용 dot_example &lt;- function(x, ...) { # browser() trim &lt;- 0 na.rm &lt;- FALSE dots &lt;- list(...) # ...에 해당하는 인수 추출 for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } mean(x, trim = trim, na.rm = na.rm) } dot_example(a) [1] NA set.seed(30) a &lt;- sample(1:30, 15, replace = TRUE) # 복원 추출 dot_example(a) [1] 17.06667 a[9] &lt;- NA dot_example(a) [1] NA dot_example(a, trim = 0.1, na.rm = TRUE) [1] 17.75 # (4) `...` 인수가 함수 내 사용(호출)된 # 다른 함수의 인수로 전달하는 경우 # summary_mean() 함수 예제와 유사 mean_manual &lt;- function(x, ...) { mean(x, ...) } set.seed(30) x &lt;- rnorm(30, mean = 10, sd = 5) na_idx &lt;- sample(1:30, 3, replace = TRUE) xna &lt;- x; xna[na_idx] &lt;- NA mean_manual(x) [1] 8.347683 mean_manual(xna) [1] NA mean_manual(xna, na.rm = TRUE) [1] 8.127862 mean_manual(x = xna, trim = 0.2, na.rm = TRUE) [1] 7.534424 함수 몸체 안에 browser()을 입력하면, browser() 전 까지 함수 몸체 안 명령들이 수행되고, 이후 명령들이 어떻게 실행되는지 확인할 수 있음. 함수 작성 시 함수 로직을 세우고 디버깅 할 때 매우 유용하게 사용 인수 관련 몇 가지 유용한 함수들 args(): 특정 함수에서 사용되는 인수 확인 args(fun_without_arg_default) function (x, y) NULL args(rnorm) function (n, mean = 0, sd = 1) NULL body(): 함수의 몸체 조회 body(var_pop) { n &lt;- length(x) if (n &lt; 2) { stop(&quot;적어도 두 개 이상의 관찰값이 존재해야 합니다&quot;) } mx &lt;- mean(x) v &lt;- sum((x - mx)^2)/n return(v) } body(dot_example) { trim &lt;- 0 na.rm &lt;- FALSE dots &lt;- list(...) for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } mean(x, trim = trim, na.rm = na.rm) } match.arg(): 인수를 매치하는 함수로 매치할 대상의 인수를 지정 arg: 매치할 대상 인수 지정 choice: 매치될 인수값 목록 several.ok: 복수 선택 여부(TRUE/FALSE) # 인수의 매치 match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;maximum&quot;, &quot;range&quot;), several.ok = TRUE) [1] &quot;median&quot; &quot;maximum&quot; match.arg(arg = c(&quot;median&quot;, &quot;maximuum&quot;), choices = c(&quot;mean&quot;, &quot;med&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;max&quot;, &quot;range&quot;), several.ok = TRUE) # 오류 why?? Error in match.arg(arg = c(&quot;median&quot;, &quot;maximuum&quot;), choices = c(&quot;mean&quot;, : &#39;arg&#39;은 반드시 &quot;mean&quot;, &quot;med&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;max&quot;, &quot;range&quot; 중 하나이어야 합니다 match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;maximum&quot;, &quot;range&quot;), several.ok = FALSE) Error in match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, : &#39;arg&#39;는 반드시 길이가 1이어야 합니다 # match.arg() 함수 응용 # 중심값 관련 통계량 계산 함수 # 평균(mean), 절삭평균(trimmed mean), 중앙값(median), 최빈수(mode) 계산 # pkg_list &lt;- rownames(installed.packages()) # 설치된 패키지 목록 # if (!(&quot;DescTools&quot; %in% pkg_list)) # install.packages(&quot;DescTools&quot;) # 최빈수를 구하기 위한 패키지 설치 center &lt;- function(x, type = c(&quot;mean&quot;, &quot;trimmed&quot;, &quot;median&quot;, &quot;mode&quot;), ... ) { # browser() trim = 0; na.rm = FALSE # dot 인수 초기값 type &lt;- match.arg(type) dots &lt;- list(...) for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } switch(type, mean = mean(x, na.rm = na.rm), trimmed = mean(x, trim = trim, na.rm = na.rm), median = median(x, na.rm = na.rm), mode = DescTools::Mode(round(x, 1), na.rm = na.rm) # DescTools 패키지 내 Mode 함수를 # workspace에 불러오지 않고 사용 ) } set.seed(100) x &lt;- rchisq(100, df = 3) # 자유도가 3인 카이제곱분포에서 난수 추출 xna &lt;- x; xna[na_idx] &lt;- NA center(x, &quot;mean&quot;); center(x, &quot;me&quot;) [1] 2.929673 Error in match.arg(type): &#39;arg&#39;은 반드시 &quot;mean&quot;, &quot;trimmed&quot;, &quot;median&quot;, &quot;mode&quot; 중 하나이어야 합니다 [1] 2.929673 center(x, &quot;trimmed&quot;, trim = 0.1) [1] 2.565866 center(x, &quot;median&quot;) [1] 2.45614 center(x, &quot;mode&quot;) [1] 1.7 attr(,&quot;freq&quot;) [1] 6 center(xna, &quot;median&quot;) [1] NA center(xna, &quot;median&quot;, na.rm = TRUE) [1] 2.423723 switch() 함수는 ifelse() 함수의 확장 버전으로 \\(n\\) 개의 조건에 대한 분기 가능 함수 제어 관련 주요 함수 return(): 계산된 결과를 반환하는 함수로 함수의 흐름에서 return()이 나타나면 결과값을 반환하고 함수 종료 강제 종료가 필요한 경우 응용 가능 # (1) 객체 반환 set.seed(100) x &lt;- rnorm(100, mean = 24, sd = 2.2) value_return1 &lt;- function(x) { tot &lt;- sum(x) n &lt;- length(x) result &lt;- list(size = n, total = tot, average = mean(x), stdev = sd(x)) return(result) } value_return1(x) $size [1] 100 $total [1] 2400.641 $average [1] 24.00641 $stdev [1] 2.245563 desc &lt;- value_return1(x) desc$stdev [1] 2.245563 value_return2 &lt;- function(x) { return(sum(x)/length(x)) } value_return2(x) [1] 24.00641 # (2) 강제 종료 시 활용 value_return3 &lt;- function(x) { if (anyNA(x)) return return(sum(x)/length(x)) } xna &lt;- x; xna[na_idx] &lt;- NA value_return3(xna) [1] NA value_return3(x) [1] 24.00641 stop(): 예외처리 함수의 일종으로 특정 조건일 경우 (오류) 메세지를 출력하고 함수 종료 인수로 문자열을 가짐 # (1) stop() 함수 사용 # 복소수 값을 실수와 허수로 분할 split_complex &lt;- function(z) { if(!is.complex(z)) stop(&quot;입력값이 복소수가 아닙니다&quot;) re &lt;- Re(z) im &lt;- Im(z) return(list(real = re, imaginary = im)) } split_complex(pi) Error in split_complex(pi): 입력값이 복소수가 아닙니다 split_complex(23 + 7i) $real [1] 23 $imaginary [1] 7 7.3.4 함수의 적용 범위(scoping rule) Scoping rule: 변수 또는 객체가 어디에서 사용 가능한지를 결정하는 규칙 매개변수(parameter): 함수를 적용할 때 사용되는 변수로 인수로부터 발생함 함수의 인수 리스트에서 인수값이 매개변수로 할당 지역변수(local variable): 함수의 몸체 부분에서 정의된 변수들을 지칭하며 함수의 종료와 동시에 재사용 불가 전역변수(global variable): 함수의 외부(workspace)에서 정의된 변수로 함수 내부에서 값을 할당하지 않더라도 사용 가능 # (1) 매개변수, 지역변수, 전역변수 구분 x &lt;- 10 # 전역변수 y &lt;- 5 # 전역변수 scope1 &lt;- function(x) { y &lt;- x^2 print(x) # 매개변수 print(y) # 지역변수 } x; y # 전역변수가 출력 [1] 10 [1] 5 scope1(x = 10) [1] 10 [1] 100 작업공간에서 x와 y는 각각 10, 5 값이 할당 작업공간 상에서 x y 값은 변하지 않음 지역변수 y의 사용 범위는 함수 몸체이기 때문에 함수 밖에 있는 y는 값이 변하지 않음 x &lt;- 10 # 전역변수 y &lt;- 5 # 전역변수 rm(z) scope2 &lt;- function(x) { y &lt;- x^2 print(x) # 매개변수 print(y) # 지역변수 print(z) } scope2(x = 5) [1] 5 [1] 25 Error in print(z): 객체 &#39;z&#39;를 찾을 수 없습니다 z &lt;- 13 # 전역변수로 z 할당 scope2(x = 5) [1] 5 [1] 25 [1] 13 함수 외부와 내부 모두에서 z가 정의되지 않았기 때문에 에러 출력 작업공간 상에 z를 정의한 경우 함수 내부에서 workspace에서 정의한 z를 그대로 사용 \\(\\rightarrow\\) 함수 외부와 내부 자유로이 사용 가능한 변수를 자유변수(free variable)이라고 지칭함. 지역변수의 사용 범위는 함수 몸체 안이지만 그 범위를 밖으로 확장할 수 있음 \\(\\rightarrow\\) &lt;&lt;- 또는 -&gt;&gt; 사용 # 지경변수의 확장 예제 x &lt;- 1; y &lt;- 2; z &lt;- 3; k &lt;- 10 scope3 &lt;- function(x) { y &lt;&lt;- x + 10 y * 3 -&gt;&gt; z print(x) # 매개변수 print(y) # 지역변수 print(z) # 지역변수 print(k) # 자유변수 } x;y;z;k [1] 1 [1] 2 [1] 3 [1] 10 scope3(x = 2) [1] 2 [1] 12 [1] 36 [1] 10 x;y;z;k [1] 1 [1] 12 [1] 36 [1] 10 하나의 함수 내부에 또 다른 함수 생성 가능 mean_manual2 &lt;- function(x) { tot &lt;- sum(x) size &lt;- function(x) { return(length(x)) } return(tot/size(x)) } mean_manual2(1:10) [1] 5.5 "],["알고리즘의-기초.html", "8 알고리즘의 기초", " 8 알고리즘의 기초 Sketch 알고리즘으로 무엇을 할 수 있을까? 지금까지 배운 여러 구문을 이용해 간단한 알고리즘을 구현해 보기 "],["알고리즘algorithm.html", "8.1 알고리즘(Algorithm)", " 8.1 알고리즘(Algorithm) 어떤 주어진 문제를 해결하기 위해 정해진 일련의 절차 또는 방법을 절차화한 형태로 표현한 것으로 계산을 실행하기 위한 단계적 절차를 의미. 즉, 문제 해결에 필요한 계산 절차 또는 처리 과정의 순서를 의미함. — Wikipedia 발췌 — 좋은 알고리즘의 특징 정밀성: 변하지 않는 명확한 작업 단계로 구성 유일성: 각 단계마다 명확한 다음 단계를 가져야 함 타당성: 구현할 수 있고 실용적 입력: 정의된 입력을 받을 수 있어야 함 출력: 답으로 출력을 내보낼 수 있어야 함 유한성: 특정 수의 작업 이후에 정지 일반성: 정의된 입력들에 대해 일반적으로 적용할 수 있어야 함 구현 자연어(natural language), 의사코드(pseudocode), 순서도(flow-chart), 프로그래밍 언어 등으로 표현할 수 있고, 정형적 단계는 다음과 같음 문제정의 \\(\\rightarrow\\) 모델고안 \\(\\rightarrow\\) 명세 작성 \\(\\rightarrow\\) 설계 \\(\\rightarrow\\) 검증 \\(\\rightarrow\\) 분석 \\(\\rightarrow\\) 구현 \\(\\rightarrow\\) 테스트 \\(\\rightarrow\\) 문서화 알고리즘의 성능 “알고리즘 성능”과 관련한 내용은 https://makemethink.tistory.com/105 에서 관련 내용을 참고해 재구성함 성능(performance/efficiency) 동일한 결과를 산출하는 알고리즘에도 차이가 존재 보통 그 차이는 알고리즘의 수행시간(자원, resource)과 밀접한 연관이 있음 예: 특정 학생의 전화번호 탐색 알고리즘(정답을 출력한다고 가정) A 알고리즘 수행 시간: 0.1초 B 알고리즘 수행 시간: 1.0초 \\(\\rightarrow\\) A 알고리즘이 더 효율적임 즉 성능은 동일한 결과를 도출하기 위해 필요한 자원(시간과 공간)의 크기 \\[ \\mathrm{performance} = \\mathrm{\\frac{solution}{resource}} \\] 성능은 다음과 같은 측면으로 고려해볼 수 있음 최선(best)의 경우 \\(\\rightarrow\\) 빠르면 1초 내에 전화번호 탐색 평균(average)의 경우 \\(\\rightarrow\\) 평균 10 초 이내에 전화번호 탐색 최악(worst)의 경우 \\(\\rightarrow\\) 아무리 늦어도 1분 이내 번호 탐색 일반적으로 성능은 최악의 경우를 상정함 \\(\\rightarrow\\) 위의 예시에서 최악은 적어도 기대 시간이 1분 보다는 빠르기 때문에 위 두 가지를 모두 포괄 자원(resource)을 결정 짓는 요소 시간 복잡도(time complexity): 알고리즘 실행 완료 시 까지 걸린 시간 사칙연산(+, -, *, \\) 비교연산(&gt;, &lt;, ==) 반복(for, while, repeat) 함수호출 공간 복잡도(space complexity): 알고리즘 실행 완료를 위해 필요한 메모리(공간) 크기 변수 개수 데이터 구조 함수 호출 알고리즘 내 자료 재햘당 여부 일반적으로 시간이 공간보다 더 소중한 자원임 시간 복잡도 및 공간 복잡도 예 # 프로그램 1 x &lt;- numeric(100) for (i in seq_along(x)) { x[i] &lt;- i } # 프로그램 2 x &lt;- NULL for (i in 1:100) { x &lt;- c(x, i) } 프로그램 1의 for 반복의 시간복잡도는 \\(\\mathcal{O}(n)\\) 이고, 공간 복잡도의 경우 반복문 내에세 미리 정의한 x 벡터에 값을 할당하는 것이기 때문에 \\(\\mathcal{O}(1)\\) 프로그램 2의 경우에는 반복문 내에서 x의 저장공간이 반복에 따라 추가적으로 \\(n\\) 까지 증가하기 때문에 공간 복잡도는 \\(\\mathcal{O}(n)\\) 알고리즘 성능의 점근적 분석 성능은 입력의 크기에 따라 결정됨 \\(n\\)을 입력의 크기라고 할 때 시간 복잡도를 \\(n\\)에 대한 함수로 표현 \\(\\rightarrow\\) \\(f(n)\\) f(n) 은 다음과 같은 형태를 가질 수 있음 시간 복잡도는 매우 큰 입력에 대해 측정하는데, 입력에 대한 함수 \\(f(n)\\) 보다 성능이 특정 입력보다 커지면 항상 나쁜 \\(g(n)\\)을 이용해 \\(f(n)\\)의 성능을 표현 \\(g(n)\\)은 \\(f(n)\\) 보다 상상 성능이 나쁘다 \\(\\rightarrow\\) \\(f(n)\\)의 최악 최악의 경우에도 \\(f(n)\\)은 \\(g(n)\\)보다 성능이 좋음 \\(f(n)\\)의 상한은 \\(g(n)\\)임 \\(f(n) \\leq g(n)\\) 많이 사용되는 표준 함수 사용(예: 1, \\(n\\), \\(\\log n\\), \\(n^2\\), \\(n\\log n\\), \\(2^n\\)) 예: \\(g(n) = n^2\\) \\(f(n)\\)은 어떤 경우에도 \\(n^2\\) 보다는 빠름 \\(f(n)\\)의 최악의 경우가 \\(n^2\\) 임 \\(f(n)\\)의 상한은 \\(n^2\\) Big O notation (빅오 표기법) 어떤 함수의 증가 양상을 다른 함수와 비교하기 위한 점근 표기법(asymptotic notation) 중 하나 예: Big \\(\\Omega\\) (하한), Big \\(\\Theta\\) notation (평균) Big O는 점근적 상한에 대한 표기법 알고리즘의 복잡도를 단순화 하거나 무한급수의 뒷부분 간소화 할 때 사용 알고리즘의 효율성을 나타내기 위한 방법으로 시간 복잡도(실행시간)와 공간 복잡도(실행공간, 메모리)로 이루어짐. 수학적 정의 모든 정수 또는 실수 집합에서 정의한 \\(n\\)에 대한 실수 집합의 함수를 \\(f\\) 와 \\(g\\) 라고 하자. \\(|f(x)| \\leq C |g(x)|\\)를 만족하는 상수 \\(k~(x \\geq k)\\)와 \\(C\\) 가 존재할 때 \\(f(x)\\)은 \\(\\mathcal{O}(g(x))\\) 이라고 나타낸다. 이 때, \\(f(x)\\)은 \\(g(x)\\)의 big-oh” 라고 읽는다. Figure 8.1: https://johngrib.github.io/wiki/big-O-notation/ 에서 발췌 여기서 \\(k\\)와 \\(C\\)를 \\(f(x)\\)가 \\(\\mathcal{O}(g(x))\\) 관계에 대한 증인(witness)라 부름 즉 \\(f(x)\\)가 \\(\\mathcal{O}(g(x))\\) 라는 것을 증명하기 위해서는 위 정의를 만족하는 \\(k\\)와 \\(C\\)를 찾으면 됨 만약 \\(k\\), \\(C\\) 한 쌍이 존재하면 무수히 많은 \\(k\\)와 \\(C\\)가 존재함 \\(\\mathcal{O}(g(n))\\)은 \\(g(n)\\)의 증가율보다 작거나 같은 함수들의 집합임 \\(\\mathcal{O}(n^2)\\)은 \\(\\mathcal{O}(1)\\), \\(\\mathcal{O}(n)\\), \\(\\mathcal{O}(n\\log n)\\) 을 포함 \\(k\\)의 최솟값은 \\(Cg(x) \\geq f(x)\\) 인 지점 \\(C\\)의 후보는 모든 실수이기 때문에 \\(Cg(x)\\)의 최고차항 차수가 \\(f(x)\\)의 최고차항의 차수보다 크거나 같다면 \\(f(x)\\)의 최고차항 계수는 그 값과 상관없이 \\(Cg(x)\\)의 증가율보다 클수 없음. Big O 복잡도 도표 출처: https://amitshahi.dev/blog/2019-06-23-big-o-notation/ 기울기가 높아질수록 성능이 시간이 오래 걸림 \\(\\rightarrow\\) 효율이 떨어지므로 성능 또한 좋지 않음 Big O의 차이에 따른 알고리즘 성능 비교 Table 8.1: Big-O 복잡도 비교 N \\(\\mathcal{O}(1)\\) \\(\\mathcal{O}(\\log n)\\) \\(\\mathcal{O}(n)\\) \\(\\mathcal{O}(n\\log n)\\) \\(\\mathcal{O}(n^2)\\) \\(\\mathcal{O}(2^n)\\) \\(\\mathcal{O}(n!)\\) 1 1 1 1 1 1 1 1 10 1 2 10 23 100 1024 3.63E+06 100 1 5 100 461 10000 1.27E10+30 9.33E10+157 Big O 표기법 규칙 극한의 성질 합의 법칙: \\(\\lim\\limits_{x \\to a} [f(x) + g(x)] = \\lim\\limits_{x \\to a} f(x) + \\lim\\limits_{x \\to a} g(x)\\) 차의 법칙: \\(\\lim\\limits_{x \\to a} [f(x) - g(x)] = \\lim\\limits_{x \\to a} f(x) - \\lim\\limits_{x \\to a} g(x)\\) 상수 곱의 법칙: \\(\\lim\\limits_{x \\to a} [cf(x)] = c\\lim\\limits_{x \\to a} f(x)\\) 곱의 법칙: \\(\\lim\\limits_{x \\to a} [f(x) \\cdot g(x)] = \\lim\\limits_{x \\to a} f(x) \\cdot \\lim\\limits_{x \\to a} g(x)\\) 1. 계수 법칙 상수 \\(C &gt; 0\\) 일 때, \\(f(x) = \\mathcal{O}(g(x))\\) 이면 \\(Cf(x) = \\mathcal{O}(g(x))\\) 입력의 크기 \\(x\\)가 무한대에 가까워 지는 경우 양수 \\(C\\)의 크기는 의미가 없음 \\(100 \\infty = \\infty\\) Big O 표기는 정확한 수치를 나타내는 것이 아니기 때문에 중요하지 않은 항과 상수, 계수를 제거한 점근적 표기법(asymptotic notation) 임(drop non-dominants) 예제 1: \\(f(x) = 6x^4 -2x^3 - 2x^2 + 5\\)의 Big O를 구하시오. \\(k = 1\\), \\(C = 15\\) 일 때, \\[ \\begin{aligned} |6x^4 -2x^3 - 2x^2 + 5| &amp;\\leq 6x^4 +2|x^3| + 2x^2 + 5 \\\\ &amp;\\leq 6x^4 + 2x^4 + 2x^4 + 5x^4 \\\\ &amp;= 15x^4 \\end{aligned} \\] 따라서 \\(|6x^4 -2x^3 - 2x^2 + 5| \\leq 15x^4\\) 이기 때문에 \\(f(x) = \\mathcal{O}(x^4)\\) 임. 직관적 풀이: 위 함수의 \\(x\\)에 매우 큰 값을 대입한 경우, 4차항 이하의 값은 점점 의미가 없어지기 때문에 중요한 것은 \\(6x^4\\) 임(). 따라서 \\(\\mathcal{O}(6x^4) = 6\\mathcal{O}(x^4) = \\mathcal{O}(x^4)\\) 임. 예제 2: 아래 두 코드의 복잡도를 Big-O로 표시하시오. # case 1 bigo_case1 &lt;- function(n) { sum &lt;- 0 for (i in 1:n) { sum &lt;- sum + i } return(sum) } # case 2 bigo_case2 &lt;- function(n) { sum &lt;- 0 for (i in 1:5*n) { sum &lt;- sum + i } return(sum) } case 1: \\(\\mathcal{O}(n)\\) case 2: \\(\\mathcal{O}(5n) = 5\\mathcal{O}(n) = \\mathcal{O}(n)\\) 2. 합의 법칙 \\(f(x) = \\mathcal{O}(h(x))\\) 이고, \\(g(y) = \\mathcal{O}(p(x))\\) 이면, \\(f(x) + g(x) = O(h(x) + p(x))\\) 이다. 두 함수의 입력항이 동일한지를 파악하는 것이 중요: 두 함수의 입력항이 같다면 1의 규칙에 따라 단순화가 가능하지만, 다른 경우 따로 표시를 해줘야만 함 예제 1: \\(f(x) = 3x^2 + 5x + 3\\), \\(g(x) = 6x^2 + 20x + 45\\) 일때 \\(f(x) +g(x)\\)의 Big O를 구하시오. \\(f(x) + g(x) = \\mathcal{O}(3x^2 + 6x^2) = \\mathcal{O}(9x^2) = \\mathcal{O}(x^2)\\) 예제 2: \\(f(x) = 7x^4\\), \\(g(y) = 9y^2 + 6y + 1\\) 일때 \\(f(x) +g(y)\\)의 Big O를 구하시오. \\(f(x) + g(y) = \\mathcal{O}(7x^4) + \\mathcal{O}(6y^2) = 7\\mathcal{O}(x^4) + 6\\mathcal{O}(y^2) = \\mathcal{O}(x^4) + \\mathcal{O}(y^2) = \\mathcal{O}(x^4 + y^2)\\) 예제 3 다음 함수의 시간 복잡도를 구하시오. # case 3 bigo_case3 &lt;- function(n) { sum &lt;- 0 for (i in 1:n) { sum &lt;- sum + i } for (i in 1:5*n) { sum &lt;- sum + i } return(sum) } #case 4 bigo_case4 &lt;- function(n, m) { sum &lt;- 0 for (i in 1:n) { sum &lt;- sum + i } for (j in 1:m) { sum &lt;- sum + m } } case 3: \\(\\mathcal{O}(n) + \\mathcal{O}(5n) = \\mathcal{O}(6n) = \\mathcal{O}(n)\\) case 4: \\(\\mathcal{O}(n) + \\mathcal{O}(m) = \\mathcal{O}(n + m)\\) 3. 곱의 법칙 \\(f(x) = \\mathcal{O}(h(x))\\)이고 \\(g(x) = \\mathcal{O}(p(x))\\) 이면, \\(f(x)\\cdot g(x) = \\mathcal{O}(h(x)\\cdot p(x))\\) 이다. 이중 for 반복문이 대표적인 경우 bigo_case5 &lt;- function(n) { sum &lt;- 0 for (i in 1:n) { sum &lt;- sum + i for (j in 1:5*n) { sum &lt;- sum + j } } return(sum) } case 5: \\(\\mathcal{O}(n \\times 5n) = 5\\mathcal{O}(n^2) = \\mathcal{O}(n^2)\\) 4. 다항 법칙 \\(f(x)\\)가 \\(k\\)차 다항식이면 \\(f(x) = \\mathcal{O}(x^k)\\) 이다. 5. 전이 법칙 \\(f(x)\\)가 \\(\\mathcal{O}(g(x))\\) 이고 \\(g(x)\\) 가 \\(\\mathcal{O}(h(x))\\)이면, \\(f(x) = \\mathcal{O}(h(x))\\) 이다. "],["재귀함수recursive-function.html", "8.2 재귀함수(Recursive function)", " 8.2 재귀함수(Recursive function) 함수 자신을 다시 호출하는 함수로 직관적으로 이해하기 쉽고 간결함 재귀함수 작성 시 재귀호출을 탈출하는 조건을 명확히 하는 것이 관건 일반적 함수의 호출 및 리턴 과정 http://10bun.tv/beginner/episode-4/ 에서 발췌 main() 함수 안에서 함수 A가 호출되면, 코드 진행은 함수 A의 처음으로 옮겨짐. 마찬가지로 함수 A 내부에서 함수 B가 호출되면서 코드 진행은 함수 B의 처음으로 옮겨짐. 함수 B가 진행되면 중간에 함수 C가 호출되면서 함수 C의 처음으로 진행이 옮겨짐 함수 C가 모든 실행을 마치면 함수 B에서 C를 호출했던 다음 줄로 돌아감(return) 함수 B의 모든 실행을 마치면 함수 A에서 B를 호출했던 다음 줄로 돌아감(return) 함수 A의 모든 실행을 마치면 main() 함수에서 A를 호출했던 다음 줄로 돌아감(return) 재귀 함수의 호출 및 리턴 과정 http://10bun.tv/beginner/episode-4/ 에서 발췌 모든 재귀함수의 호출 시 새로운 작업공간(메모리)을 확보해 진행 동일한 코드가 작업공간만 옮겨 다니며 무한히 반복되는 구조이기 때문에 탈출조건이 필요 예제1: 재귀함수를 이용한 1부터 n 까지 합을 구하는 함수 recursive_sum &lt;- function(n) { if (n == 1) return(n) # 종료 조건 return(n + recursive_sum(n-1)) } recursive_sum(3) [1] 6 http://10bun.tv/beginner/episode-4/ 에서 발췌 recursive_sum(3) 실행 시 n이 1이 아니기 때문에 recursive_sum(2) 호출 recursive_sum(2) 실행 시 n이 1이 아니기 때문에 recursive_sum(1) 호출 recursive_sum(1) 이면 n == 1 을 만족하기 때문에 1 반환(return) recursive_sum(2)는 recursive_sum(1)에서 반환 받은 1과 n = 2을 더해서 3을 반환(return) recursive_sum(3)은 recursive_sum(2) 에서 반환 받은 3과 n = 3을 더해서 6을 반환 \\(\\rightarrow\\) 종료 예제2: 계승(factorial) 계산하기 \\[ n! = \\begin{cases} n \\times (n - 1)!, &amp; n=1, \\cdots \\\\ 1, &amp; n = 0 \\end{cases} \\] \\(f(n) = n!\\) 이라고 하면 \\(f(n)\\)은 아래와 같이 나타낼 수 있음. \\[ n! = \\begin{cases} n \\times f(n-1), &amp; n=1, \\cdots \\\\ 1, &amp; n = 0 \\end{cases} \\] 위 식을 이용해 \\(3!\\)을 구하는 과정: - \\(f(3) = 3\\times f(2) = 3\\times 2 \\times f(1) = 3 \\times 2\\times 1\\times f(0) = 3\\times 2\\times 1\\times 1 = 6\\) f(3) = 3*f(2) f(2) = 2 * f(1) f(1) = 1 위 과정을 함수로 구현 factorial_manual &lt;- function(n) { # browser() if (n == 0) return(1) return(n * factorial_manual(n-1)) } # test factorial_manual(3) [1] 6 factorial_manual(10) [1] 3628800 # R 내장함수로 검증 factorial(10) [1] 3628800 확장예제: 하노이 탑(tower of Hanoi) “인도 바라나시에 있는 한 사원에는 세상의 중심을 나타내는 큰 돔이 있고 그 안에 세 개의 다이아몬드 바늘이 동판 위에 세워져 있습니다. 바늘의 높이는 1 큐빗이고 굵기는 벌의 몸통만 합니다. 바늘 가운데 하나에는 신이 64개의 순금 원판을 끼워 놓았습니다. 가장 큰 원판이 바닥에 놓여 있고, 나머지 원판들이 점점 작아지며 꼭대기까지 쌓아 있습니다. 이것은 신성한 브라흐마의 탑입니다. 브라흐마의 지시에 따라 승려들은 모든 원판을 다른 바늘로 옮기기 위해 밤낮 없이 차례로 제단에 올라 규칙에 따라 원판을 하나씩 옮깁니다. 이 일이 끝날 때, 탑은 무너지고 세상은 종말을 맞이하게 됩니다.” Wikipedia 발췌 문제: 3개의 기둥 A, B, C가 있고, 기둥 A에 \\(N\\) 개의 원판이 크기 순서대로 쌓여져 있을 때(제일 밑에 원판이 가장 큼), 모든 원판을 기둥 C로 옮기기 조건 한 번에 하나의 원판만 옮길 수 있음 큰 원판이 작은 원판 위에 있으면 안됨 Figure 8.2: 하노이 탑 문제 Solution 원판의 크기가 제일 작은 것 부터 큰 것 까지 각각 1, 2, 3 번을 부여 했을 때 1 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 2 번 원판을 봉 A에서 B로 옮김 (A \\(\\rightarrow\\) B) 1 번 원판을 봉 C에서 B로 옮김 (C \\(\\rightarrow\\) B) 3 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 1 번 원판을 봉 B에서 A로 옮김 (B \\(\\rightarrow\\) A) 2 번 원판을 봉 B에서 C로 옮김 (B \\(\\rightarrow\\) C) 1 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 원판이 3개인 경우 총 7번의 이동이 필요 \\(\\rightarrow\\) \\(n\\)개의 원판이 있을 경우 \\(2^n - 1\\) 번의 이동이 필요 Figure 8.3: 하노이 탑 문제 알고리즘 구현 move_hanoi &lt;- function(k, from, to, via) { # browser() if (k == 1) { print(sprintf(&quot;%d 번 원판을 %s 에서 %s 로 이동&quot;, 1, from, to)) } else { move_hanoi(k - 1, from = from, to = via, via = to) print(sprintf(&quot;%d 번 원판을 %s 에서 %s 로 이동&quot;, from = k, to = from, via = to)) move_hanoi(k - 1, from = via, to = to, via = from) } } move_hanoi(3, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;) [1] &quot;1 번 원판을 A 에서 C 로 이동&quot; [1] &quot;2 번 원판을 A 에서 B 로 이동&quot; [1] &quot;1 번 원판을 C 에서 B 로 이동&quot; [1] &quot;3 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 A 로 이동&quot; [1] &quot;2 번 원판을 B 에서 C 로 이동&quot; [1] &quot;1 번 원판을 A 에서 C 로 이동&quot; move_hanoi(4, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;) [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;2 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; [1] &quot;3 번 원판을 A 에서 B 로 이동&quot; [1] &quot;1 번 원판을 C 에서 A 로 이동&quot; [1] &quot;2 번 원판을 C 에서 B 로 이동&quot; [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;4 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; [1] &quot;2 번 원판을 B 에서 A 로 이동&quot; [1] &quot;1 번 원판을 C 에서 A 로 이동&quot; [1] &quot;3 번 원판을 B 에서 C 로 이동&quot; [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;2 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; "],["선형이진-탐색linearbinary-search.html", "8.3 선형/이진 탐색(Linear/Binary search)", " 8.3 선형/이진 탐색(Linear/Binary search) 8.3.1 선형 탐색(Linear Search) 특정 값을 주어진 벡터 공간에서 찾기 위해 저장 공간을 순차적으로 비교하면서 찾는 방식 가장 단순하고 직관적인 검색 방법 Sequential search 선형탐색: https://chercher.tech/kotlin/linear-search-kotlin 에서 발췌 Pseudocode 찾고자 하는 값을 k 라고 할 때, for i 1 to n   if x[i] == k then return i 구현 # Linear search linear_search &lt;- function(target, vec) { for (i in seq_along(vec)) { if (vec[i] == target) return(i) } return(NULL) } set.seed(1) x &lt;- sample(1:30, 30) k &lt;- sample(1:30, 1) linear_search(target = k, vec = x) [1] 28 8.3.2 이진 탐색(Binary Search) 정렬된 벡터에서 특정 값을 탐색하기 위한 알고리즘 전체 탐색범위를 반으로 나눈 후 찾고자 하는 값이 없는 쪽을 버린 후 나머지 부분에서 값을 검색하는 과정을 반복 선형 탐색보다 대부분의 경우에서 효율적임(빠름). 이진탐색: https://mohtashims.wordpress.com/2010/07/02/searching/ 에서 발췌 Pseudocode: 자연어 주어진 배열의 가운데(중앙)에서 시작 찾고자 하는 목표값과 배열의 중앙 위치 값과 비교 만약 목표값과 중앙 위치값이 같다면 반복을 멈춤 목표값이 배열의 중앙 위치값 보다 작다면 가장 작은 인덱스에서 중앙 인덱스 보다 하나 작은 인덱스 까지 값(새로운 최대 인덱스)으로 범위를 측소 후 비교 목표값이 배열의 중앙 위치값 보다 크다면 중앙 인덱스에 1을 더한 인덱스 (새로운 최소 인덱스)부터 최대 인덱스 범위로 축소 후 비교 Pseudocode 배열 인덱스에 대한 중앙 인덱스(mid = (min + max)/2) 계산 while min &lt;= max     mid = floor((min + max)/2)     if vec[mid] == target then return(mid)     else if vec[mid] &gt; target     then update max &lt;- mid - 1     else update min &lt;- mid + 1 구현 # Binary search binary_search &lt;- function(target, ovec) { maxL &lt;- length(ovec) # 벡터의 길이 minL &lt;- 1L # 시작 while (minL &lt;= maxL) { midL &lt;- floor((minL + maxL)/2) if (ovec[midL] == target) { return(midL) } else if (ovec[midL] &gt; target) { maxL &lt;- midL - 1 } else { minL &lt;- midL + 1 } } return(NULL) } x &lt;- seq(1, 40000000, by = 3) set.seed(2) k &lt;- sample(x, 1) binary_search(target = k, ovec = x) [1] 5551055 재귀함수를 이용한 구현 # 재귀함수를 활용한 binary search rbinary_search &lt;- function(target, ovec, minL, maxL) { if (maxL &lt;= minL) return(NULL) midL &lt;- floor((minL + maxL)/2) if (ovec[midL] &gt; target) { rbinary_search(target, ovec, minL = minL, maxL = midL - 1) } else if (ovec[midL] &lt; target) { rbinary_search(target, ovec, minL = midL + 1, maxL = maxL) } else return(midL) } x &lt;- seq(1, 40, by = 3) set.seed(2) k &lt;- sample(x, 1) rbinary_search(target = k, ovec = x, minL = 1, maxL = length(x)) [1] 5 8.3.3 선형탐색과 이진탐색 비교 일반적인 경우: https://blog.penjee.com/binary-vs-linear-search-animated-gifs/ 에서 발췌 이진탐색이 안좋은 경우: https://blog.penjee.com/binary-vs-linear-search-animated-gifs/ 에서 발췌 이진탐색 성능이 가장 좋은 경우: https://blog.penjee.com/binary-vs-linear-search-animated-gifs/ 에서 발췌 두 탐색 알고리즘의 시간 복잡도 비교 선형 탐색: \\(\\mathcal{O}(n)\\) 이진 탐색 반복 1: \\(n\\) 반복 2: \\(n/2\\) 반복 3: \\(n/2^2\\) … 반복 k: \\(n/2^k\\) \\(\\rightarrow\\) \\(k\\) 번 까지 반복(나눔) 시 검색해야할 배열(벡터) 의 길이는 1임. 즉 최악의 경우 \\(n/2^k = 1\\) 이므로 양변에 밑이 2인 로그를 취하면 \\(\\log_2n = k\\log_2 2 = k\\) 이므로 이진 탐색의 시간 복잡도는 \\(\\mathcal{O}(\\log_2n)\\) 임. "],["정렬-알고리즘sorting-algorithms.html", "8.4 정렬 알고리즘(Sorting Algorithms)", " 8.4 정렬 알고리즘(Sorting Algorithms) 정렬 알고리즘은 특성에 따라 안정 정렬(stable sort)과 불안정 정렬(unstable sort) 로 구분 정렬의 안정적 특성: 정렬되지 않은 상태에서 중복값이 존재하는 경우 정렬 후에도 그 순서가 그대로 유지 안정 정렬(stable sort): 임의 배열(벡터)에 중복된 값이 존재하는 경우 정렬 후에도 입력 순서와 동일하게 정렬 불안정 정렬(unstable sort): 처음 입력된 중복된 값의 순서가 정렬 후에도 유지된다는 보장이 없음 다음부터 소개할 정렬 알고리즘은 모두 오름차순 정렬을 기준으로 설명 8.4.1 버블 정렬(Bubble Sort) 서로 인접한 두 원소를 비교해 정렬하는 알고리즘 인접한 두 개의 값을 비교해 크기가 순서대로 입력되어 있지 않다면 서로 교환 버블정렬 원리: 위키피디아에서 발췌 첫 번째 자료와 두 번째 자료, 두 번째 자료와 세 번째 자료, … 형태로 마지막 (n-1) 번째 자료와 마지막 자료를 비교해 교환하면서 자료 정렬 첫번 째 순회가 끝난 후 가장 큰 값은 맨 뒤로 이동 순회가 거듭될 때마다 정렬에서 제외되는 원소가 하나씩 증가 \\(\\rightarrow\\) 순회가 거듭될 때 마다 비교 횟수가 줄어듬 \\(\\rightarrow\\) 모든 원소를 방문할 필요가 없음 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 bubble sort라 명칭 버블정렬 애니메이션: 위키피디아 발췌 Pseudocode 데이터(벡터) 입력 주어진 벡터의 인덱스가 i=1부터 i + 1 번째 원소와 비교 i 번째 인덱스의 원소가 i+1 번째 인덱스 원소보다 크다면 서로 교환 (반대의 경우 서로 교환하지 않음) i를 증가하고 마지막 비교까지 2-3 단계 수행 이미 정렬된 마지막 인덱스는 무시 다시 인덱스 i=1 로 설정 후 2-5 단계 수행 구현 bubble_sort &lt;- function(x) { n &lt;- length(x) for(i in 1:(n-1)) { for (j in 1:(n - i)) { if (x[j] &gt; x[j + 1]) { # x[j]가 x[j + 1] 보다 큰 경우 교환 temp &lt;- x[j] x[j] &lt;- x[j + 1] x[j + 1] &lt;- temp } } } return(x) } set.seed(1234) x &lt;- sample(1:100, 100) x_sort &lt;- bubble_sort(x) 시간 복잡도 비교 횟수 한 번 순회를 마칠 때 마다 비교 대상이 하나씩 줄어듬. 즉 전체 원소의 개수가 \\(n\\) 일 때 총 \\(n-1\\) 번의 순회하면 정렬이 종료됨. 총 원소의 개수가 10개이면, \\(9 + 8 + \\cdot + 1 = 45\\) 번 비교가 수행됨. 즉, \\[ (n - 1) + (n - 2) + \\cdots + 1 = \\frac{n(n-1)}{2} \\] 자리 교환 횟수 최선의 경우: 이미 정렬된 벡터인 경우 자리 교환이 한 번도 이루어지지 않기 때문에 \\(\\mathcal{O}(n)\\) 임. 최악의 경우: 역순으로 정렬된 경우 원소를 비교할 때 마다 자리 교환을 수행해야 하기 때문에 \\(\\mathcal{O}(n^2)\\) 임. 즉 버블 정렬의 시간복잡도는 \\(\\mathcal{O}(n^2)\\) 장점 구현이 쉽고 직관적 정렬하고자 하는 벡터 안에서 교환하는 방식이기 때문에 메모리 공간이 일정함 안정 정렬 단점 시간 복잡도가 비효율적 \\(\\rightarrow\\) 치명적임!! 8.4.2 삽입 정렬(Insertion Sort) 손 안의 카드를 정렬하는 방법과 유사 새로운 카드를 기존의 정렬된 카드 사이에 삽입 새로 삽입될 카드의 수만큼 반복 후 전체 카드가 정렬 자료의 모든 원소를 앞부터 차례대로 이미 정렬된 원소 부분과 비교 매 순서마다 해당 원소를 삽입할 수 있는 위치를 탐색 두 번째 원소부터 시작해 앞(왼쪽)의 원소와 비교하면서 삽입 위치 지정 후 자료를 뒤로 옮기고 지정 위치(인덱스)에 원소를 삽입하면서 정렬 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 원소와 비교 후 삽입 위치(인덱스) 탐색 원소가 삽입될 위치를 찾았다면 원소를 한 칸씩 뒤로 이동 삽입정렬 애니메이션: 위키피디아에서 발췌 예시: c(8, 5, 6, 2, 4) 오름차순 정렬 https://gmlwjd9405.github.io/ 에서 발췌 Pseudocode 벡터가 주어졌을 때, 두 번째 인덱스 i=2에 대응하는 원소를 키 값으로 저장 i 바로 앞 인덱스 j = i - 1 지정 j 가 0 보다 크고, j 번째 원소가 키 값보다 크다면 j + 1 번째 원소를 j 번째 원소와 교환 j를 1만큼 감소 4 ~ 6 반복 j + 1 번째 원소를 key 값으로 교환 2 - 8 반복 구현 insertion_sort &lt;- function(x) { n &lt;- length(x) for (i in 2:n) { key &lt;- x[i] j &lt;- i - 1 while(j &gt; 0 &amp;&amp; x[j] &gt; key) { x[j + 1] &lt;- x[j] j &lt;- j - 1 } x[j + 1] &lt;- key } return(x) } set.seed(12345) x &lt;- sample(1:100, 10) insertion_sort(x) [1] 14 24 51 58 75 80 88 90 92 93 시간복잡도 삽입 정렬을 이해하고 직접 구해보기!! 장점 알고리즘이 단순함 대부분 원소가 이미 정렬되어 있는 경우 매우 효율적임 안정 정렬 버블 정렬에 비해 효율적임 단점 대체로 비효율적(시간 복잡도 확인) 8.4.3 병합 정렬(Merge Sort) 분할 정복(Divide and Conquer) 크고 어려운 문제를 조금씩 쉽게 풀 수 있는 문제 단위로 나눠서 해결 후, 이를 병합해 문제를 해결하는 방식 가장 큰 특징 중 하나는 재귀적으로 호출을 통해 알고리즘 구현 알고리즘 기본설계 Divide (분할): 문제 분할이 가능한 경우 2개 이상의 문제로 나눔 Conquer (정복): 나누어진 문제가 여전히 분할 가능하면 다시 분할 수행. 그렇지 않은 경우 문제를 해결 Combine (결합): 정복한 문제들을 통합해 원래 문제의 답을 도출 분할 정복 알고리즘 구현 시 분할을 어떻게 하는지가 가장 중요함 재귀 호출로 인해 알고리즘의 효율성이 낮아질 수 있음 병합 정렬 주어진 벡터에서 가운데를 나누어 비슷한 크기의 벡터를 두 개로 만든 뒤 이를 재귀 호출을 이용해 각각 정렬 후 정렬된 배열을 하나로 합침. 병합 정렬 과정 벡터(배열)의 길이가 1 또는 2인 경우 이미 정렬이 된 것으로 간주. 그렇지 않은 경우 정렬되지 않은 벡터를 절반으로 나눈 후 비슷한 크기의 부분 벡터 생성 각 부분 벡터를 재귀적으로 병합 정렬 실시 두 개의 부분 벡터를 다시 하나의 벡터로 결합 추가적인 벡터가 필요 각 부분 벡터 정렬 시 합병 정렬을 재귀적으로 호출 합병 정렬 시 정렬이 이루어 지는 시점은 2개 리스트를 합병하는 단계임 구현 분할(merge_sort()) 벡터를 2개 부분으로 재귀적으로 나눔 \\(\\rightarrow\\) 벡터의 길이가 1이 될 때 까지 구현을 위해 필요한 요소 주어진 벡터의 첫 번째 인덱스 \\(\\rightarrow\\) 1 주어진 벡터의 마지막 인덱스 \\(\\rightarrow\\) n 주어진 벡터의 가운데 인덱스 \\(\\rightarrow\\) mid = ceiling(n/2) 나누어진 벡터의 왼쪽과 오른쪽 부분을 저장한 객체를 각각left, right로 정의 left: 주어진 벡터의 첫 번째 인덱스에서 mid 번째 인덱스에 해당하는 값을 저장 right: 주어진 벡터의 mid+1 번째 인덱스에서 n 번째 인덱스에 해당하는 값을 저장 이러한 구간을 분할 함수의 인자로 넘겨주는 작업을 재귀적으로 반복 Pseudocode 만약 벡터의 길이가 1보다 크다면, mid = ceiling(n/2) left = merge_sort(x[1:mid]) right = merge_sort(x[(mid + 1):n]) 병합(smerge()) 분할된 벡터를 정렬 후 병합하는 역할 수행 구현을 위해 필요한 요소 정렬한 벡터들을 임시로 저장할 공간(객체): temp 왼쪽과 오른쪽 부분 벡터의 길이 \\(\\rightarrow\\) n1, n2 왼쪽과 오른쪽 부분 벡터의 초기값 저장 \\(\\rightarrow\\) lstart = 1, rstart = 1 Pseudocode (자연어) 왼쪽 부분 벡터와 오른쪽 부분 벡터의 원소를 비교해 더 작은 값이 temp에 저장 만약 left 의 lstart 인덱스에 해당하는 값이 right의 rstart 인덱스에 해당하는 값보다 작다면 temp의 \\(i\\) 번째 인덱스에 left[lstart] 값 저장 후 lstart 값을 하나씩 증가 반대의 경우 temp의 \\(i\\) 번째 인덱스에 right[rstart] 값 저장 후 rstart 값을 하나씩 증가 Pseudocode temp &lt;- numeric(length(left) + length(right)) n1 &lt;- length(left) n2 &lt;- length(right) lstart &lt;- 1; rstart &lt;- 1 for (i in 1:length(temp))    if (left[lstart] &lt;= right[rstart])      temp[i] &lt;- left[lstart]      lstart = lstart + 1    else      temp[i] &lt;- right[rstart]      rstart = rstart + 1 합병 및 정렬 수행 예시: https://gmlwjd9405.github.io/ 에서 발췌 최종 코드 # 병합 정렬 ## 분할 merge_sort &lt;- function(x) { n &lt;- length(x) if (n &gt; 1) { mid &lt;- ceiling(n/2) left &lt;- merge_sort(x[1:mid]) right &lt;- merge_sort(x[(mid + 1):n]) smerge(left, right) } else { x } } ## 병합 및 정렬 smerge &lt;- function(left, right) { n1 &lt;- length(left) n2 &lt;- length(right) temp &lt;- numeric(n1 + n2) lstart &lt;- rstart &lt;- 1 for (i in 1:length(temp)) { if ((left[lstart] &lt;= right[rstart] &amp; lstart &lt;= length(left)) || rstart &gt; length(right)) { temp[i] &lt;- left[lstart] lstart &lt;- lstart + 1 } else { temp[i] &lt;- right[rstart] rstart &lt;- rstart + 1 } } temp } set.seed(12345) x &lt;- sample(1:100, 20) x_sort &lt;- merge_sort(x) 시간 복잡도 재귀함수의 깊이(\\(n = 2^k\\)로 가정): 단계 1: \\(n/2\\) 단계 2: \\(n/2^2\\) \\(\\ldots\\) 단계 k: \\(n/2^k \\rightarrow k\\) 번까지 반복 \\(\\rightarrow\\) 최악의 경우 \\(n/2^k = 1\\) 이므로 양변에 로그를 취하면 \\(\\log_2n\\) 임. 각 합병 단계에서 \\(n = 8\\)인 경우 크기가 1인 부분 벡터 2개를 병합 시 최대 2 번의 연산이 필요하고, 부분 배열의 쌍이 4개이기 때문에 최대 \\(2\\times 4= 8\\) 번의 비교 연산이 필요 다음 단계에서 병합 시 길이가 2인 부분 벡터 2 개 병합 시 4 번의 비교 연산이 필요하고 부분 벡터의 쌍이 2이기 때문에 최대 \\(4\\times 2= 8\\) 번의 비교 연산 필요 마지막 단계에서 길이가 4인 부분 벡터 2개 병합 시 8 번의 비교 연산이 필요하고, 부분 벡터의 쌍이 1이기 때문에 최대 \\(8\\times 1= 8\\) 번의 연산 필요 \\(\\rightarrow\\) 최대 \\(n\\) 번 \\(\\therefore\\) \\(n\\times \\log_2n = n\\log_2n\\) 이동횟수 재귀함수의 깊이: \\(\\log_2 n\\) 임시 벡터에 복사 후 다시 가져와야 하기 때문에 총 부분 배열에 들어 있는 원소의 개수가 \\(n\\)인 경우 원소의 이동이 총 \\(2n\\) 번 발생 \\(\\therefore\\) \\(2n\\log_2 n\\) 따라서 총 시간 복잡도는 \\(n\\log_2n + 2n\\log_2n = 3n\\log_2n \\rightarrow \\mathcal{O}(n\\log_2n)\\) 8.4.4 퀵 정렬(Quick Sort) 주어진 벡터(배열)을 단순히 균등하게 분할하는 대신 병합 과정 없이 한쪽 벡터에 포함된 원소가 다른 쪽 벡터에 포함된 원소보다 항상 작게 배열을 분할하는 방식으로 정렬을 수행함. 벡터에서 임의의 원소를 기준(pivot)으로 정한 후 기준보다 작거나 같은 원소는 왼쪽, 큰 원소는 오른쪽으로 보내는 과정을 수행 불안정 정렬 분할 정복 알고리즘 중 하나로 매우 좋은 효율을 보임 다른 원소와 비교를 재귀적으로 수행 \\(\\rightarrow\\) 비교 정렬 병합 정렬과 달리 주어진 벡터(배열)을 비균등하게 분할 Quick 정렬 애니메이션: 위키피디아 발췌 퀵 정렬 과정 벡터 내 한 원소를 임의로 선택 \\(\\rightarrow\\) 피벗(pivot) 피벗을 기준으로 피벗보다 작은 원소는 모두 피벗의 왼쪽으로 옮기고, 피벗보다 끈 원소들은 모두 오른쪽으로 옮김 \\(\\rightarrow\\) 분할 피벗을 제외한 왼쪽과 오른쪽 부분 벡터를 정렬 \\(\\rightarrow\\) 정복 분할된 부분 벡터에 대해 재귀호출을 통해 정렬 반복 부분 벡터에 대해서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 벡터로 나누는 과정 반복 부분 벡터들이 더 이상 분할할 수 없을 때 까지 반복 벡터의 크기가 1이 될 때 까지 반복 정렬한 부분 벡터를 하나의 벡터로 병합 \\(\\rightarrow\\) 결합 Quick 정렬 알고리즘 과정: https://gmlwjd9405.github.io/ 에서 발췌 특징 장점 속도가 빠름 추가 메모리 공간을 필요로 하지 않음 \\(\\mathcal{O}(\\log_2 n)\\) 만큼의 메모리 필요 단점 정렬된 벡터(배열)에 대해서는 불균형 분할로 인해 수행시간이 더 오래 걸림 구현 재귀함수를 이용한 퀵 정렬 알고리즘 구현 Pseudocode quicksort(x) pivot 선택 left = x[x &lt;= pivot]; right = x[x &gt; pivot] if (l &lt; 1) then quicksort(left) if (r &lt; 1) then quicksort(right) merge (left, pivot, right) # Quick 정렬 quick_sort &lt;- function(x) { n &lt;- length(x) randi &lt;- sample(1:n, 1) pivot &lt;- x[randi] x &lt;- x[-randi] # 피벗을 기준으로 작은 값들은 left, # 큰 값은 right 로 분할 left &lt;- x[which(x &lt;= pivot)] right &lt;- x[which(x &gt; pivot)] # left에 대해 재귀적으로 분할 if (length(left) &gt; 1) left &lt;- quick_sort(left) if (length(right) &gt; 1) right &lt;- quick_sort(right) out &lt;- c(left, pivot, right) out } x &lt;- sample(1:100, 20) quick_sort(x) [1] 1 3 9 12 13 14 16 20 25 30 32 36 60 62 64 72 75 76 80 84 시간 복잡도 최선의 경우 pivot 좌우로 분할된 벡터의 크기가 각 재귀 단계마다 동등한 경우, 재귀 단계에 대한 깊이는 병합 정렬과 동일하게 \\(\\log_2 n\\) 임. 각 재귀 단계에서 비교 연산은 전체 \\(n\\) 번의 비교가 필요 \\(\\therefore\\) \\(\\mathcal{O}(n\\log_2 n)\\) 최악의 경우 정렬된 벡터에서 계속해서 불균형하게 분할이 이루어지는 경우, 재귀 단계의 깊이는 최대 \\(n\\) 임 각 재귀 단계에서 비교는 전체 \\(n - 1\\) 만큼 이루어짐 \\(\\therefore\\) \\(\\mathcal{O}(n^2)\\) Big-O 표기법에 따르면 퀵 정렬의 시간 복잡도는 \\(\\mathcal{O}(n^2)\\) 인데, 왜 빠르다고 할까?? "],["뉴튼-랩슨-알고리즘newton-rhapson-algorithm.html", "8.5 뉴튼-랩슨 알고리즘(Newton-Rhapson Algorithm)", " 8.5 뉴튼-랩슨 알고리즘(Newton-Rhapson Algorithm) 임의의 함수 \\(f(x)\\)가 주어졌을 때 \\(f(x) = 0\\) (\\(f(x)\\)의 해)를 만족하는 \\(x\\)를 반복적인 수치계산을 통해 찾는 방법 Newton-Raphson (N-R) 방법 적용 시 \\(f(x)\\)의 만족 조건 \\(x\\)의 특정 범위 내에서 \\(f(x) = 0\\)를 만족하는 유일한 실수값 존재 \\(f(x)\\)는 미분 가능한 함수 Newton-Raphson 알고리즘 예시 N-R 알고리즘(스케치) step 1: 초기치 \\(x_{old}\\)를 설정 step 2: \\(x_{old}\\)에서 \\(f(x_{old})\\) 값 계산 step 3: \\(x_{old}\\)에서 접선의 기울기(미분계수) \\(f&#39;(x_{old})\\) 계산 step 4: \\(f&#39;(x_{old})\\)의 접선이 \\(x\\)축과 만나는 점을 새로운 값 \\(x_{new}\\)로 업데이트 \\[ x_{new} = x_{old} - \\frac{f(x_{old})}{f&#39;(x_{old})} \\] step 5: 일정 조건을 만족할 때 까지 step 1 ~ step 4 반복 step 4에서 초기값 \\(x_0\\)이 주어졌을 때 \\(f(x_0)\\)의 접선은 \\(f&#39;(x_0)\\) 이고 \\((x_0, f(x_0))\\)를 통과하므로 접선의 식은 아래와 같음 \\[ f(x) = f&#39;(x_0)(x - x_0) + f(x_0) \\] \\(f(x) = 0\\) 일때 \\(x\\)의 값은 \\[ x = x_0 -\\frac{f(x_0)}{f&#39;(x_0)} \\] - 따라서 다음 단계에서 해의 근사치 \\(x_{1} = x_0 - f(x_0)/f&#39;(x_0)\\) 이고, 이를 조금 더 일반화 하면, \\[ x_{n+1} = x_n - \\frac{f(x_n)}{f&#39;(x_n)} \\] 위 식은 테일러 전개(Taylor expansion)를 통해 도출 가능(한 번 생각해 볼 것!!) N-R 알고리즘의 특징 현재 \\(x_{old}\\) 또는 \\(x_{n}\\)이 0을 만족할 경우, 더 이상 다음 단계로 가지 않음. 현재 함수값이 0에서 멀리 떨어져 있을수록 다음 스텝이 커지고, 미분계수의 절대값이 클수록 다음 스텝이 작아짐 미분계수의 절대값이 크다 \\(\\rightarrow\\) \\(x_n\\)을 조금만 움직여도 함수값이 크게 변한다는 의미 따라서 미분계수의 값을 다음 스텝에 반영해야 함. 다음 \\(x_{new}\\)의 방향은 \\(f(x_{old})/f&#39;(x_{old})\\) 부호와 반대방향으로 결정 수렴속도가 빠르지만 초기값에 따라 알고리즘의 성능이 달라짐 \\(f&#39;(x)\\)를 반복적으로 계산해야 하고, 경우에 따라 \\(f&#39;(x) = 0\\)이면 반복식 계산이 불가 반복 종료 조건 처음 설정한 최대 반복 횟수를 넘었을 때 더 이상 \\(x\\)의 값이 움직이지 않는다고 판단되었을 경우 함수의 값이 충분히 0에 가까워 졌을 경우 N-R 알고리즘 구현 알고리즘에 입력되어야 할 변수 초기값과 해를 찾을 범위 지정 \\(\\rightarrow\\) 만약 초기값이 해당 범위를 벗어난 값이 입력되었다면 함수 종료 함수 반복횟수 0과 충분히 가까운 상수(종료 시 필요) \\(\\rightarrow\\) tol 함수 내부 또는 함수 외부에서 1차 미분 함수가 요구 함수 인수로 입력 vs. 함수 내부에서 도함수 계산? 도함수 계산 시 위 예제에서 사용한 R 내장 함수 사용 vs. 미분식 사용? \\[ \\lim_{d \\rightarrow 0} \\frac{f(x + d) - f(x)}{d} \\] 반복 종료조건에 도달할 때 까지 반복이 필요 \\(\\rightarrow\\) while 문 사용 반복 조건: 반복이 최대 반복수보다 작고 \\(|f(x_{new})|\\) 값이 tol 값보다 클 때 까지 newton_raphson &lt;- function(FUN, # 함수 x0 = 1, # 초기값 max_iters = 5000, # 최대 반복 횟수 tol = 1.0e-9, range = c(-Inf, Inf), ...) { iters &lt;- 1; grads &lt;- deriv(as.expression(body(FUN)), &quot;x&quot;, function.arg = TRUE) # grads 반환값 중 &quot;gradient&quot; 값 = f&#39;(x0) gap &lt;- x0 - FUN(x0)/attr(grads(x0), &quot;gradient&quot;) while(iters &lt; max_iters &amp; abs(gap) &gt; tol) { # x_new 계산 x_new &lt;- x0 - FUN(x0)/attr(grads(x0), &quot;gradient&quot;) gap &lt;- FUN(x_new) # x_new 가 범위를 벗어난 경우 처리 if (x_new &lt;= range[1]) x_new &lt;- range[1] if (x_new &gt;= range[2]) x_new &lt;- range[2] iters &lt;- iters + 1 x0 &lt;- x_new # 초기값 업데이트 } if (x_new == range[1] | x_new == range[2]) warning(&quot;마지막 점이 x 범위의 경계선 상에 있습니다.&quot;) if (iters &gt; max_iters) warning(&quot;최대 반복 때 까지 해를 찾지 못했습니다.&quot;) cat(&quot;x 가&quot;, x_new, &quot;일 때 함수값:&quot;, FUN(x_new), &quot;\\n&quot;) return(list(solution = x_new, iteration = iters)) } ## test: 위 동영상과 동일한 해를 갖는지 확인 f &lt;- function(x) 5 * x^3 - 7 * x^2 - 40 * x + 100 newton_raphson(FUN = f, x0 = 1, range = c(-10, 10)) -&gt; sols x 가 -3.151719 일 때 함수값: -3.547029e-11 "],["기말고사-참고자료-리스트.html", "9 2021-01 기말고사 참고자료 리스트", " 9 2021-01 기말고사 참고자료 리스트 과제 답안: https://zorba78.github.io/quiz-repository/ LaTeX 수식입력 참고: https://www.latex4technics.com/ 6번 문제 관련 자료: https://raw.githubusercontent.com/e9t/nsmc/master/ratings_train.txt "],["overview02.html", "Course Overview: 통계패키지활용", " Course Overview: 통계패키지활용 R을 이용한 데이터 분석 시 CRAN에 등록된 패키지를 활용한다. 적절한 패키지의 활용은 데이터 분석의 효율을 증대할 뿐 아니라 분석의 재현성을 향상할 수 있다. 본 강의는 지난학기에 학습한 통계프로그래밍언어 강의 내용의 연속선 상에서 진행할 예정이며, R을 이용한 시뮬레이션에 대한 이해, 실제 데이터의 전처리 및 핸들링 방법, R에서 제공하는 그래픽 기능 활용, 그리고 Shiny를 이용한 웹 어플리케이션 개발 방법에 대해 학습할 예정이다. 교과 목표 R 시뮬레이션을 통한 통계학 기초 이론 확인 R package를 활용한 데이터 핸들링 및 자료 시각화 R을 이용한 데이터 분석 및 테이블 작성 Shiny, plotly 를 활용한 동적 문서 및 시각화 이해 선수과목 통계학 개론 통계 프로그래밍 언어 수업 방법 강의: 50 % 실험/실습: 50 % 평가방법 프로젝트: 20 % 기말고사: 50 % 출석: 10 % 과제: 10 % 퀴즈: 10 % 교재 별도의 교재 없이 본 강의 노트로 수업을 진행할 예정이며, 수업의 이해도 향상을 위해 아래 소개할 도서 및 웹 문서 등을 참고할 것을 권장함. 참고문헌 R Markdown Cookbook (Xie, Dervieux, and Riederer 2020) R for data science (Wickham and Grolemund 2016) Statistical Computing with R (Rizzo 2019) R programming for data science (Peng 2016) Interactive web-based data visualization with R, plotly, and shiny (Sievert 2020) References "],["Simulation.html", "10 시뮬레이션", " 10 시뮬레이션 Sketch 시뮬레이션이 뭐지? 통계학에서 시뮬레이션이 왜 필요할까? 중요한 기초통계 이론을 눈으로 확인할 수 있을까? "],["prerequisites-1.html", "10.1 Prerequisites", " 10.1 Prerequisites 10.1.1 확률과 확률변수 필수 개념 확률(probability) 확률변수(random variable) 기댓값(expectation) 확률(probability): 어떤 사건을 \\(E\\) 라고 명명할 때, \\(E\\)가 발생할 확률은 만약 무작위적 과정을 매우 많이 반복 했을 때 사건 \\(E\\)가 발생한 비율을 의미함 예1: 한화 이글스가 플레이오프에서 승리 후 리그 1위 팀과 한국 시리즈에서 경기를 할 확률? 예2: 동전/주사위 던지기 확률변수(random variable): 우연한 사건의 결과에 값을 핟당 예: 카지노 게임의 배당금 기댓값(expectation): 사건이 벌어졌을 때의 이득과 그 사건이 벌어질 확률을 곱한 것을 전체 사건에 대해 합한 값 확률변수의 기댓값은 평균으로 수렴 확률변수의 기댓값은 무작위 과정을 여러 번 반복했을 때 장기적인 측면에서 평균적으로 얻어질 것으로 기대되는 값 "],["시뮬레이션모의실험의-의미.html", "10.2 시뮬레이션(모의실험)의 의미", " 10.2 시뮬레이션(모의실험)의 의미 알반적 의미 현실 세계에서는 시간 및 비용 등의 문제로 실현하기 어렵거나 불가능한 시스템을 모형(혹은 가상 데이터 생성) 을 통해 실제 시스템을 모사함으로써 현상에 대한 문제를 이해하고자 하는 목적으로 고안한 일련의 방법 시뮬레이션의 활용 사례 군사 모의실험 비행 모의실험 선거 모의실험 민방위 훈련 … 통계적 모의실험(statistical or stochastic simulation) 통계학의 표본 이론과 확률론을 근간으로 확률모형으로부터 난수(random number)와 임의 표본(random sample) 으로 가상의 데이터를 생성한 후 어떤 결과나 문제의 해를 근사해 실제 이론으로 도출한 결과와 비교하기 위한 방법론임. 이러한 형태의 모의실험 방법을 몬테칼로 시뮬레이션(Monte Carlo simulation)이라고 함. 확률 모형(stochastic model)은 데이터가 어떻게 생성되었는지를 수학적으로 표현. “모형을 시뮬레이션 한다” = 단계적으로 “데이터처럼 보이는 것”, 생성하는 과정을 의미함 확률모형(분포)로 부터 도출한 합성 데이터(synthetic data), 대리 데이터(surrogate data) 생성 각 시뮬레이션 결과는 동일한 초기값에서 랜덤 요소를 수반하기 때문에 동일한 결과를 보장하지 않음 예시: \\(X_1 \\sim \\mathcal{N}(3, 2^2)\\), \\(X_2 \\sim \\mathcal{N}(5, 3^2)\\) 이고, \\(X \\perp \\!\\!\\! \\perp Y\\) 일 때 \\(X_3 = X_1 + 2X_2\\) 의 분포는? \\(X3 \\sim \\mathcal{N}(3 + 2\\times5, 2^2 + 4\\times 3^2) = \\mathcal{N}(13, 40)\\) set.seed(10000) x1 &lt;- rnorm(10000, 3, 2) x2 &lt;- rnorm(10000, 5, 3) x3 &lt;- x1 + 2*x2 mean(x3); var(x3) [1] 13.0817 [1] 39.87758 통계적 모의실험에 Monte carlo 라는 명칭이 붙게된 계기는 2차 세계대전 당시 미국의 원자폭탄 개발계획인 Manhattan 프로젝트에서 중성자의 특성을 연구하기 위한 모의실험의 명칭에 모나코의 유명한 도박 도시 Monte Carlo 이름을 붙힌 것에서 유래함. 통계적 모의실험의 특징 특정 분포를 따르는 확률 변수에 대응하는 관찰값이 필요 반복적으로 수많은 난수를 생성해야 하기 때문에 컴퓨터의 사용이 필수적 기본적으로 통계학의 가장 기본적 개념인 대수의 법칙(law of the large number)을 활용 통계적 모의실험을 하는 방법 통계적(확률) 모형은 보통 한 변수(\\(X\\))가 주어졌을 때 다른 변수(\\(Y\\))에 대한 조건부 분포임. 이러한 통계적 모형이 단순 선형회귀모형(simple linear regression model)임. \\[ \\begin{eqnarray} X &amp; \\sim &amp; \\mathcal{N}(\\mu_x, \\sigma_1^2) \\\\ Y|X &amp; \\sim &amp; \\mathcal{N}(\\beta_0 + \\beta_1X, \\sigma_2^2) \\end{eqnarray} \\] - 위 식에서 우변에 주어진 확률변수를 생성하는 방법을 알고 있다면 위 회귀모형에 대한 시뮬레이션 가능 \\(\\rightarrow\\) 모든 종류의 확률 모형에 대한 시뮬레이션의 일반적 전략임. 통계적 모의실험(시뮬레이션) = 확률변수의 생성문제 난수 생성의 방법 난수(random number): 어떤 방법으로도 예측될 수 없는 일련의 수열(숫자) 통계적 의미로 난수는 특정 범위(보통 0에서 1 사이)의 균일분포(uniform distribution)에서 추출된 표본들의 관찰값으로, 임의의 확률분포(예: 정규분포, 지수분포 등)를 따르는 확률 변수와는 구별됨. 특정 분포를 따르는 확률 변수는 균일 분포를 따르는 확률 변수로부터 적절한 변환을 통해 얻을 수 있음. 난수를 발생하려면 어떤 알고리즘이 필요하고 알고리즘은 일정한 규칙에 의해 구현되기 때문에 컴퓨터로 발생한 난수는 엄밀한 의미에서 난수가 아님. 이를 구별하기 위해 보통 컴퓨터로 생성한 난수를 유사난수(pseudo-random number)라 칭함 난수 생성을 위한 알고리즘으로 합동법(congruential method), 역변환법(inversion method) 등이 널리 활용 통계 시뮬레이션에서는 주로 변수변환방법(transformation)을 통해 확률변수를 생성 \\(Z \\sim \\mathcal{N}(0, 1)\\)일 때 \\(\\sigma Z + \\mu \\sim \\mathcal{N}(\\mu, \\sigma^2)\\) \\(Z^2 \\sim \\chi^2(1)\\) "],["몬테칼로-시뮬레이션.html", "10.3 몬테칼로 시뮬레이션", " 10.3 몬테칼로 시뮬레이션 본 절에서 사용한 동영상 및 모의실험 코드는 Yihui Xie와 Lijia Yu가 배포한 animation 패키지의 내용을 기반으로 재구성함. 우리가 알고 있는 확률과 기댓값의 정의는 모두 반복 횟수에 제한 없이 무한대로 확률실험(무작위 과정)을 반복 했을 때의 상황을 설정한 것임 즉 컴퓨터를 통해 수학적 확률 또는 기댓값을 정확히 계산할 수 없어도 무작위 실험을 매우 많이 반복해 특정 사건이 일어날 확률이나 기댓값 추정이 가능 \\(\\rightarrow\\) 몬테칼로 시뮬레이션의 기본 idea 10.3.1 동전 던지기 실제 정상적인 동전을 던졌을 때 앞/뒷면이 나올 확률이 1/2 일까? 정상적인 동전 던지기 실험 구현 sample() 함수를 통해 매우 간단히 구현 가능 함수 적용 시 가장 중요한 부분은 복원 추출을 한다는 점임 매번 시행이 독립시행이고 매회 시행 시 앞면과 뒷면이 나올 확률이 같도록 유지해야 함 # 동전 실험 coin_flip &lt;- function(faces, ntry = 100) { record &lt;- sample(faces, size = ntry, replace = TRUE) prob1 &lt;- sum(record == faces[1])/ntry prob2 &lt;- 1 - prob1 p &lt;- list(prob1, prob2) for (i in 1:length(faces)) cat(paste0(&quot;Proprotion &quot;, faces[i], &quot;:&quot;), p[[i]], &quot;\\n&quot;) } coin &lt;- c(&quot;H&quot;, &quot;T&quot;) set.seed(1000) coin_flip(coin, ntry = 10) # 10회 Proprotion H: 0.5 Proprotion T: 0.5 coin_flip(coin, ntry = 20) # 20회 Proprotion H: 0.4 Proprotion T: 0.6 coin_flip(coin, ntry = 100) # 100회 Proprotion H: 0.53 Proprotion T: 0.47 coin_flip(coin, ntry = 1000) # 1000회 Proprotion H: 0.516 Proprotion T: 0.484 coin_flip(coin, ntry = 10000) # 10000회 Proprotion H: 0.4988 Proprotion T: 0.5012 coin_flip(coin, ntry = 100000) # 100000회 Proprotion H: 0.49925 Proprotion T: 0.50075 10.3.2 주사위 던지기 주사위를 던지는 게임을 모사 주사위를 정의: 1 ~ 6 까지 숫자를 가짐 각 주사위 눈이 나올 확률: 모두 1/6 주사위 눈에 대한 기댓값 \\[ 1\\times\\frac{1}{6} + 2\\times\\frac{1}{6} + 3\\times\\frac{1}{6} + 4\\times\\frac{1}{6} + 5\\times\\frac{1}{6} + 6\\times\\frac{1}{6} = 3.5 \\] # 주사위 정의 die &lt;- c(1:6) probs &lt;- rep(1/6, 6) # 주사위 던지기 sample(die, 1, prob = probs) [1] 6 # 주사위 1000 번 던지기 draw_res &lt;- integer(length = 1000) for (i in 1:1000) draw_res[i] &lt;- sample(die, 1, prob = probs) mean(draw_res) [1] 3.51 # for문을 사용하지 않고 sample 함수만 사용 draw_res2 &lt;- sample(die, 1000, prob = probs, replace = TRUE) 10.3.3 카드 생성기 카드(트럼프) 게임을 위한 카드 생성 카드의 구성: Figure 7.3: 트럼프 구성(https://statkclee.github.io/r-algorithm/ 에서 발췌 shape &lt;- c(&quot;Spade&quot;, &quot;Diamond&quot;, &quot;Heart&quot;, &quot;Club&quot;) rank &lt;- c(&quot;Ace&quot;, as.character(2:10), &quot;Jack&quot;, &quot;Queen&quot;, &quot;King&quot;) deck &lt;- expand.grid(rank = rank, shape = shape) # 카드 섞기 # set.seed(12345) smpl_idx &lt;- sample(1:52, 52, replace = FALSE) # 비복원 추출 suffle_deck &lt;- deck[smpl_idx, ] # 5 Cards Poker suffle_deck[1:20, ] -&gt; chosen_cards chosen_cards$player &lt;- rep(1:4, times = 5) # 1번 참가자 chosen_cards[chosen_cards$player == 1, ] # 2번 참가자 chosen_cards[chosen_cards$player == 2, ] # 3번 참가자 chosen_cards[chosen_cards$player == 3, ] # 4번 참가자 chosen_cards[chosen_cards$player == 4, ] 10.3.4 동전 던지기 게임 정상적인 동전 두 번을 던졌을 때, 모두 뒷면이 나온 경우 1000 원을 잃음 둘 중 하나가 앞면이 나온 경우 비김 모두 앞면이 나온 경우 2000 원을 가짐 동전을 던져서 내가 딴 돈의 금액을 \\(X\\) 라고 하면 \\(X\\)는 -1000, 0, 2000 의 값을 갖는 확률변수이고 다음과 같은 표본공간을 가짐 \\[ S = \\{HH,~HT,~TH,~TT \\} \\] 위의 사건들은 다음과 같이 처음 정한 금액에 대응됨. HH \\(\\rightarrow\\) \\(X = 2000\\) HT \\(\\rightarrow\\) \\(X = 0\\) TH \\(\\rightarrow\\) \\(X = 0\\) TT \\(\\rightarrow\\) \\(X = -1000\\) 따라서, 각 금액에 대응한 확률은 x -1000 0 2000 p 1/4 2/4 1/4 게임에서 내가 얻을 금액에 대한 기댓값 \\[ E(X) = -0.25 \\times 1000 + 0 \\times 0.5 + 2000 \\times 0.25 = 250 \\] 구현 동전 던지기 시뮬레이션 코드에서 사용한 sample() 함수 사용 금액과 각 금액에 대응하는 확률값, 시행 횟수를 함수의 인수로 입력 simple_game &lt;- function(x, p, ntry = 10) { record &lt;- sample(x, size = ntry, replace = TRUE, prob = p) expect &lt;- mean(record) cat(&quot;당신이 이 게임을 무한히 반복한다면 평균적으로 &quot;, expect, &quot;원을 가져갈 것입니다.&quot;, &quot;\\n&quot;) } x &lt;- c(-1000, 0, 2000) p &lt;- c(1/4, 2/4, 1/4) set.seed(2371) simple_game(x = x, p = p, ntry = 10) # 10회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 900 원을 가져갈 것입니다. simple_game(x = x, p = p, ntry = 50) # 50회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 40 원을 가져갈 것입니다. simple_game(x = x, p = p, ntry = 100) # 100회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 170 원을 가져갈 것입니다. simple_game(x = x, p = p, ntry = 1000) # 1000회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 234 원을 가져갈 것입니다. simple_game(x = x, p = p, ntry = 10000) # 10000회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 241.2 원을 가져갈 것입니다. simple_game(x = x, p = p, ntry = 100000) # 100000회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 247.64 원을 가져갈 것입니다. sum(x*p) # 실제값 [1] 250 10.3.5 주사위 던지기 게임 주사위 두 개를 던졌을 때 두 주사위 눈이 모두 같을 경우 이기는 게임으로 이길 경우 상금 10,000원을 받고 질 경우 5000원을 잃는 게임 문제: 500 번 동일한 게임을 반복했을 때 승리할 확률 500 번 동일한 게밍을 반복한다면 나는 돈을 딸 수 있을까? set.seed(12345) dice &lt;- c(1:6); probs &lt;- rep(1/6, 6) # 주사위 1 번 던지기 draw1 &lt;- sample(dice, 1, prob = probs) # 주사위 2 번 던지기 draw2 &lt;- sample(dice, 1, prob = probs) ifelse(draw1 == draw2, &quot;승리&quot;, &quot;패배&quot;) [1] &quot;패배&quot; # 500 번 반복 dice_game &lt;- integer(500) for (i in 1:500) { draw1 &lt;- sample(dice, 1, prob = probs) draw2 &lt;- sample(dice, 1, prob = probs) dice_game[i] &lt;- ifelse(draw1 == draw2, 1, 0) } mean(dice_game) [1] 0.184 # 문제 2번 winning &lt;- integer(500) for (i in 1:500) { draw1 &lt;- sample(dice, 1, prob = probs) draw2 &lt;- sample(dice, 1, prob = probs) winning[i] &lt;- ifelse(draw1 == draw2, 10000, -5000) } mean(winning) [1] -2480 10.3.6 카드 게임 13 장의 카드를 잘 섞어서 한 장씩 패를 뒤집었을 때 카드의 번호와 뒤집은 순서가 적어도 한 번 이상 일치한 경우 지는 게임 thirteen_deck &lt;- seq(from=1, to=13, by=1) shuffled_deck &lt;- sample(thirteen_deck, 13, replace=FALSE) outcome &lt;- integer(13) for (i in 1:13) { outcome[i] &lt;- ifelse(shuffled_deck[i] == i, 1, 0) res &lt;- ifelse(sum(outcome) == 0, &quot;승리&quot;, &quot;패배&quot;) } cat(&quot;게임 결과:&quot;, res) 게임 결과: 승리 10,000 번 반복을 수행하기 위해 간단한 함수 생성 single_game &lt;- function() { shuffled_deck &lt;- sample(thirteen_deck, 13, replace=FALSE) outcome &lt;- integer(13) for (i in 1:13) { outcome[i] &lt;- ifelse(shuffled_deck[i] == i, 1, 0) res &lt;- ifelse(sum(outcome) == 0, &quot;승리&quot;, &quot;패배&quot;) } res } game_result &lt;- character(length = 10000) set.seed(12345) for (i in 1:10000) { game_result[i] &lt;- single_game() } 확률 및 기대값 추정 모두 시행횟수가 증가할 수록 실제 이론적 값에 근사하는 것을 눈으로 확인 가능함. 즉, 통계학의 근간이 되는 대수의 법칙(law of large number) 에 따른 자연스러운 결과임. 10.3.7 몬테칼로 적분법(sample-mean Monte-carlo integration) 컴퓨터를 이용해 적분값 계산 시, 적분하고자 하는 적절한 차수의 도함수가 존재하는 경우 일반적으로 수치적분법(직사각형, 사다리꼴, simpson 적분법 등)을 사용할 수 있으나, 도함수가 존재하지 않을 경우 또는 다중 적분을 해야하는 경우 수치적분법 적용이 어려움. 몬테칼로 적분법은 복잡한 적분식에 대한 해를 구하기(추정하기) 위해 고안되었으며 매우 간단하게 적분식의 해를 찾을 수 있는 장점이 있음. 대략적 원리는 다음과 같음. 함수의 적분값을 하나의 모수로 보고 임의표본추출을 통해 해당 모수를 추정 \\[ E[f(x)] = \\int f(x) p(x) dx \\approx \\frac{1}{N}\\sum_{i=1}^{N}f(x_i) \\] 적중법(Hit or miss) \\(f(x) = 2 + \\cos(x + \\sin(\\arctan(x) + 3)\\) 일 때, \\(a = 1\\) 에서 \\(b = 3\\) 아래 면적은 다음과 같음 \\[ I = \\int_{a = 1}^{b = 3} f(x)~dx \\] x &lt;- seq(0, pi, length = 500) y &lt;- 2 + cos(x + sin(atan(x)) + 3) plot(x, y, type = &quot;n&quot;, ylim = c(0, 4), xlim = c(0, 3.5)) idx &lt;- x &gt;= 1 &amp; x &lt;= 3 polygon(c(1, x[idx], 3), c(0, y[idx], 0), col = &quot;darkgray&quot;, border = &quot;darkgray&quot;) lines(x, y, lwd = 1.5) rect(1, 0, 3, 4, lty = 1) abline(h = 4, lty = 2) text(3, 0.1, &quot;Hit&quot;, cex = 2.5, adj = 1, pos = 2) text(1, 3.9, &quot;Miss&quot;, cex = 2.5, adj = 0) text(2.2, 2.8, &quot;f(x)&quot;, cex = 2.5) 위 그림에서 \\(x\\) 축과 평행한 \\(y = c\\)의 선을 그었을 때 \\(a\\), \\(b\\) 구간 상에 사각형 면적은 \\(c(b-a)\\) 임. 사각형에서 \\(I\\)가 차지하는 비율을 \\(p\\) 라고 할 때, \\(I = c(b - a)p\\) 임. 위 사각형 안에 랜덤하게 N개의 점을 x-y 좌표 상에 찍었을 때, \\(f(x)\\) 아래 놓인 점의 개수를 \\(X\\)라고 하면 \\(X\\)은 모수가 \\(N\\), \\(p\\)인 이항분포를 따름. 따라서 \\(\\hat{p} = X/N\\)이고 \\(f(x)\\) 아래 면적 \\(I\\)의 추정값은 아래와 같음. \\[ \\hat{I} = c(b - a)\\frac{X}{N} \\] 구현: \\(\\pi\\) 값 계산 Idea: 원의 면적은 \\(\\pi r^2\\)이므로 반지름이 1인 경우 \\(\\pi\\)랑 동일 \\(\\rightarrow\\) \\(x^2 + y^2 = 1\\)인 원을 고려 1사분면에 해당하는 영역에서 랜덤하게 점을 찍은 후 4분원의 면적을 추정한 다음 4를 곱하면 \\(\\pi\\) 값 추정 가능 hit_pi &lt;- function(ntry) { X &lt;- 0 for (i in 1:ntry) { xy &lt;- runif(2, 0, 1)^2 if (sum(xy) &lt; 1) X &lt;- X + 1 } cat(&quot;Estimated pi: &quot;, sprintf(&quot;%.6f&quot;, 4 * X/ntry), &quot;\\n&quot;) } set.seed(314) hit_pi(100) # 100 Estimated pi: 3.000000 hit_pi(1000) # 1,000 Estimated pi: 3.184000 hit_pi(10000) # 10,000 Estimated pi: 3.148000 hit_pi(100000) # 100,000 Estimated pi: 3.140080 hit_pi(1000000) # 1,000,000 Estimated pi: 3.137764 system.time(hit_pi(5000000)) # 5,000,000 Estimated pi: 3.141950 사용자 시스템 elapsed 10.864 0.029 10.908 pi [1] 3.141593 표본평균을 활용한 몬테칼로 적분 적중법의 비효율성 개선 적분을 어떤 확률변수의 기댓값으로 표현하여 적분값을 추정 확률변수 \\(X \\sim \\mathrm{Uniform(a, b)}\\) 일 때, \\[ E[f(x)] = \\int_a^{b} f(x)p(x)~dx = \\frac{1}{b - a}\\int_a^b f(x)~dx \\] - 적분값은 \\[ \\begin{aligned} I &amp;= \\int_a^b f(x)~d(x) = (b-a)E[f(x)] \\\\ E[f(x)] &amp;= \\frac{1}{N}\\sum_{i = 1}^N f(x_i),~~ x_i \\stackrel{iid}{\\sim} \\mathrm{Uniform}(a, b) \\end{aligned} \\] 구현: \\(\\pi\\) 계산시간 비교 mean_pi &lt;- function(ntry) { x &lt;- runif(ntry, -1, 1) I = 4*mean(sqrt(1 - x^2)) cat(&quot;Estimated pi: &quot;, sprintf(&quot;%.6f&quot;, I), &quot;\\n&quot;) } set.seed(314) mean_pi(100) # 100 Estimated pi: 3.251687 mean_pi(1000) # 1,000 Estimated pi: 3.155947 mean_pi(10000) # 10,000 Estimated pi: 3.140608 mean_pi(100000) # 100,000 Estimated pi: 3.143188 mean_pi(1000000) # 1,000,000 Estimated pi: 3.140865 system.time(mean_pi(5000000)) # 5,000,000 Estimated pi: 3.141221 사용자 시스템 elapsed 0.169 0.011 0.180 10.3.8 Buffon의 바늘 실험 간격이 \\(d\\)인 평행선들이 그려져 있는 책상 위에 길이가 \\(l\\) 인 바늘을 던졌을 때, 이 바늘이 책상 위에 그려진 선에 걸쳐질 확률 원문: 떨어진 거리가 같은 평행선들이 그어진 마룻바닥에 바늘을 떨어뜨렸다. 바늘이 금에 닿을 확률은 얼마인가? Georges-Louis Leclerc, Comte de Buffon (1777) 조건 바늘의 길이는 선 사이 간격보다 작다(\\(l &lt; d\\)) Figure 10.1: Buffon의 바늘실험: 바늘이 선에 걸쳐진 경우 Figure 10.2: Buffon의 바늘실험: 바늘이 선에 걸쳐지지 않은 경우 \\(m\\): 바늘의 중앙점 \\(a\\): 두 평행선 중 \\(m\\)과 가까운 평행선에서 \\(m\\) 까지의 직선거리 \\(\\theta\\): 바늘과 평행선이 이루는 각도 Fact \\(d &gt; l\\) 조건 하에서 \\(a\\)는 가장 가까운 선과의 직선거리이기 때문에 \\(d/2\\)보다 클 수 없음 \\(\\rightarrow\\) \\(0 \\leq a \\leq d/2\\) \\(\\rightarrow\\) \\(a \\sim \\mathrm{Uniform}(0, d/2)\\) 선을 벗어난 바늘 끝을 지나는 가상의 평행선과 \\(m\\) 사이의 수직 거리는 \\(l/2\\sin \\theta\\) 바늘이 선에 걸치는 경우는 \\(l/2\\sin \\theta\\) 가 \\(a\\) 보다 긴 경우임 \\(\\rightarrow\\) \\(0 \\leq a \\leq l/2\\sin \\theta\\) \\(\\rightarrow\\) \\(\\theta \\sim \\mathrm{Uniform}(0, \\pi)\\) \\(\\therefore\\) 바늘이 선에 걸쳐질 확률은 \\[ P(바늘이~걸쳐질 ~확률) = P\\left (0 \\leq a \\leq \\frac{l}{2} \\sin \\theta \\right ) \\] 두 확률변수의 결합분포를 구한 후 결합밀도함수에 대한 적분값(확률)을 구하는 문제!! 수학적 표현 \\(a\\) 에 대한 확률분포 \\[ a \\sim \\mathrm{Uniform}(0, d/2) = \\begin{cases} \\frac{2}{d}, &amp; 0 \\leq a \\leq d/2 \\\\ 0, &amp; \\mathrm{otherwise} \\end{cases} \\] \\(\\theta\\) 에 대한 확률분포 \\[ \\theta \\sim \\mathrm{Uniform}(0, \\pi) = \\begin{cases} \\frac{1}{\\pi}, &amp; 0 \\leq \\theta \\leq \\pi \\\\ 0, &amp; \\mathrm{otherwise} \\end{cases} \\] 두 확률변수가 독립이기 때문에 \\(a\\)와 \\(\\theta\\)의 결합분포는 아래와 같음 \\[ f(a, \\theta) = \\begin{cases} \\frac{2}{d\\pi}, &amp; 0 \\leq a \\leq d/2;~ 0 \\leq \\theta \\leq \\pi \\\\ 0, &amp; \\mathrm{otherwise} \\end{cases} \\] 따라서 바늘이 평행선에 걸쳐질 확률은 \\[ \\begin{align} P\\left (0 \\leq a \\leq \\frac{l}{2} \\sin \\theta \\right ) &amp;= \\int_{\\theta = 0}^{\\pi}\\int_{a = 0}^{(l/2)\\sin \\theta} \\frac{2}{d\\pi} \\,da\\,d\\theta\\\\ &amp;= \\int_{\\theta = 0}^\\pi \\frac{l\\sin\\theta}{d\\pi}\\,d\\theta \\\\ &amp;= \\frac{l\\cos\\theta}{d\\pi} \\Big|_{0}^\\pi = \\frac{2l}{d\\pi} \\end{align} \\] 위 식을 이용해 모의실험을 통해 \\(\\pi\\) 값 추정이 가능. \\[ \\hat{\\pi} = \\frac{2l}{d\\hat{P}} \\] 실제 모의실험 시 확률 계산 방법 바늘의 중점(\\(m\\))에서 바늘과 가장 가까운 평행선 까지 주식 거리(\\(a\\))는 \\(d/2\\) 안에 있기 때문에 표본공간(\\(S\\))은 다음과 같이 정의할 수 있음. \\[ S = \\{(a, \\theta)|0 \\leq a \\leq \\frac{d}{2}, ~ 0 \\leq \\theta \\leq \\pi \\} \\] 표본공간 \\(S\\)에서 \\(\\frac{l}{2} \\sin \\theta\\)의 함수 아래 면적(\\(A\\))이 결국 바늘이 평행선 상에 걸칠 확률임. 따라서 \\[ P\\left (0 \\leq a \\leq \\frac{l}{2} \\sin \\theta \\right ) = \\frac{\\mathrm{A}의~넓이}{\\mathrm{S}의~넓이} = \\frac{\\int_0^{\\pi} 0.5l\\sin{\\theta}~d\\theta}{0.5d\\pi} = \\frac{2l}{d\\pi} \\] 기하학적 표현 # l = 1, d = 2 l &lt;- 1; d &lt;- 2 x &lt;- seq(0, pi, by = 0.01) y &lt;- 0.5 * l * sin(x) plot(1, xlim = c(0, pi), ylim = c(0, d/2), type = &quot;n&quot;, xlab = expression(theta), ylab = &quot;d/2&quot;, cex.lab = 1.5) polygon(x, y, col = &quot;yellow&quot;, border = &quot;yellow&quot;) lines(x = x, y = y, lty = 1, lwd = 2) rect(0, 0, pi, 1, lty = 2, lwd = 1.5) text(x = 1.5, y = 0.6, expression(paste(f, &quot;(&quot;, theta, &quot;)&quot; == frac(l, 2) * sin * theta)), adj = 0, cex = 2) text(x = 0.05, y = 0.95, &quot;S&quot;, adj = c(0,1), cex = 2) text(x = pi/2, y = 0.2, &quot;A&quot;, adj = 0, cex = 2) Figure 10.3: Buffon 바늘 실험의 표본 공간과 확률 영역 Implementation 실제 바늘이 던져지는 상황 시각화 Buffon의 바늘실험(30회 실행), 그림은 buffon_needle_draw.R 함수 참고 buffon_needle_draw &lt;- function(nmax = 20, l = 0.8, # 바늘의 길이 d = 1, # 두 평생선 간 간격 col = c(&quot;lightgray&quot;, &quot;red&quot;), plot = TRUE, return.value = FALSE) { # 반복 초기화 j &lt;- 1; n &lt;- 0 # x &lt;- y &lt;- x0 &lt;- y0 &lt;- theta &lt;- a &lt;- rep(NA, ani.options(&quot;nmax&quot;)) x &lt;- y &lt;- x0 &lt;- y0 &lt;- theta &lt;- a &lt;- rep(NA, nmax) while (j &lt;= length(x)) { theta[j] &lt;- runif(1, 0, pi) a[j] &lt;- runif(1, 0, d/2) y[j] &lt;- sample(c(0.5 * d + a[j], 1.5 * d - a[j]), 1) x[j] &lt;- runif(1, 0, l) # 바늘이 떨어졌을 때 수평선과 이루는 각도 반영 x0[j] &lt;- 0.5 * l * cos(theta[j]) y0[j] &lt;- 0.5 * l * sin(theta[j]) j &lt;- j + 1 if (plot) { dev.hold() plot(1, xlim = c(-0.5*l, 1.5*l), ylim = c(0, 2*d), type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, axes = FALSE) axis(1, c(0, l), c(&quot;&quot;, &quot;&quot;), tcl = -1) axis(1, 0.5 * l, &quot;L&quot;, font = 3, tcl = 0, cex.axis = 1.5, mgp = c(0, 0.5, 0)) axis(2, c(0.5, 1.5) * d, c(&quot;&quot;, &quot;&quot;), tcl = -1) axis(2, d, &quot;D&quot;, font = 3, tcl = 0, cex.axis = 1.5, mgp = c(0, 0.5, 0)) box() bd &lt;- par(&quot;usr&quot;) # 실제 device plot 영역 상 x-y 좌표 시작 끝 점 정보 반환 rect(bd[1], 0.5 * d, bd[2], 1.5 * d, col = col[1]) abline(h = c(0.5 * d, 1.5 * d), lwd = 2) # 그림 1: 부폰의 바늘 실험: 바늘과 평행선 # 실제 바늘이 평행선 안에 떨어지는 모습 모사 segments(x - x0, y - y0, x + x0, y + y0, col = col[2]) dev.flush() # Sys.sleep(1) } } if(return.value) { result &lt;- list(nmax =nmax, l = l, d = d, a = a, theta = theta) return(result) } } # buffon_needle_draw(nmax = 20, l = 0.8, d = 1, plot = TRUE, return.value = FALSE) set.seed(5000) # 바늘의 길이가 15이고 평행선 간격이 20일 때 바늘이 평행선에 걸칠 확률 param &lt;- buffon_needle_draw(nmax = 5000, l = 15, d = 20, plot = FALSE, return.value = TRUE) \\(P(A)\\) 계산: 표본공간 및 바늘을 던졌을 때 표본공간 안에 바늘이 들어와 있는지 확인 \\(\\rightarrow\\) 바늘이 금에 걸쳐질 확률 계산 step 0: 바늘의 길이(\\(l\\))과 수평선 사이 거리(\\(d\\)) 설정 step 1: \\(a ~ \\mathrm{Uniform}(0, d/2)\\)에서 난수 한개 발생 step 2: \\(\\theta ~ \\mathrm{Uniform}(0, \\pi)\\)에서 난수 한개 발생 step 3: 바늘이 선에 걸치는 경우(\\(a \\leq 0.5l\\sin{\\theta}\\)) 카운트한 후 확률 계산 buffon_prob &lt;- function(param, plot = TRUE, ndraw = 20) { # browser() l &lt;- param$l d &lt;- param$d a &lt;- param$a theta &lt;- param$theta ntry &lt;- length(a) A &lt;- a &lt;= 0.5 * l * sin(theta) phati &lt;- cumsum(A)/(1:ntry) phat &lt;- sum(A)/ntry # 시뮬레이션 추정 확률 ptrue &lt;- 2*l/(pi*d) # 이론적 확률 idx &lt;- NULL if (plot) { for (i in 1:ndraw) { dev.hold() x = seq(0, pi, by = 0.01) plot(x, 0.5 * l * sin(x), type = &quot;l&quot;, ylim = c(0, 0.5 * d), bty = &quot;l&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, col = &quot;black&quot;) # rect(0, 0, pi, d/2, lty = 2, lwd = 1.5) text(pi/2, 0.4 * l, expression(y == frac(L, 2) * sin(theta)), cex = 1.5) idx = c(idx, as.numeric(a[i] &gt; 0.5 * l * sin(theta[i])) + 1) points(theta[1:i], a[1:i], col = c(&quot;red&quot;, &quot;blue&quot;)[idx]) phatii &lt;- format(phati[i], nsmall = 6, digits = 6) legend(&quot;topright&quot;, legend = substitute(hat(P) == phatii, list(phatii = phatii)), bty = &quot;n&quot;, cex = 1.3) dev.flush() # Sys.sleep(0.05) } } cat(&quot;True Probability:&quot;, sprintf(&quot;%.3f&quot;, ptrue), &quot;\\n&quot;) cat(&quot;Estimated Probability:&quot;, sprintf(&quot;%.3f (total %d dropping)&quot;, phat, ndraw), &quot;\\n&quot;) } buffon_prob(param, plot = FALSE, ndraw = 5000) True Probability: 0.477 Estimated Probability: 0.478 (total 5000 dropping) Buffon의 바늘실험(500 회 실행): 표본공간 상 바늘을 던졌을 때 사건 A 집계 과정 추정한 \\(\\hat{\\pi}\\) 값이 횟수가 증가할수록 실제 \\(\\pi\\) 값에 수렴하는지 확인 buffon_pi_estimate() buffon_pi_estimate &lt;- function(param, plot = TRUE, ndraw = 20) { # browser() l &lt;- param$l d &lt;- param$d a &lt;- param$a theta &lt;- param$theta ntry &lt;- length(a) A &lt;- a &lt;= 0.5 * l * sin(theta) csum_A &lt;- cumsum(A) phat &lt;- csum_A/(1:ntry) # i 번째 시행 때 까지 바늘이 선에 걸쳐질 확률 pihat &lt;- (2 * l)/(d * phat) # pi 계산 if (plot) { for (i in 1:ndraw) { dev.hold() plot(pihat[1:i], ylim = c((1 - 0.5) * pi, (1 + 0.5) * pi), xlim = c(0, ndraw), xlab = paste(&quot;바늘 던진 횟수:&quot;, i), ylab = expression(hat(pi)), type = &quot;l&quot;, col = &quot;black&quot;, cex.lab = 1.5) abline(h = pi, lty = 2, col = &quot;red&quot;) # phati &lt;- sprintf(&quot;%.6f&quot;, pihat[i]) pihati &lt;- format(pihat[i], nsmall = 7, digits = 7) legend(&quot;topright&quot;, legend = substitute(hat(pi) == pihati, list(pihati = pihati)), bty = &quot;n&quot;, cex = 1.3) dev.flush() # Sys.sleep(0.05) } } cat(&quot;Estimated pi: &quot;, sprintf(&quot;%.6f (%d dropping)&quot;, pihat[ndraw], ndraw)) } buffon_pi_estimate(param, plot = FALSE, ndraw = 5000) Estimated pi: 3.139389 (5000 dropping) Buffon의 바늘실험(500 회 실행): PI 추정 과정 "],["시뮬레이션과-통계학.html", "10.4 시뮬레이션과 통계학", " 10.4 시뮬레이션과 통계학 통계학에서 다루는 많은 이론들은 모의실험을 통해 그 이론의 의미를 더욱 명확하게 확인 가능하다. 특히 본 절에서는 데이터 분석 실무에서 꼭 알아두어야 할 중요 개념에 대해 간단히 review를 하고, 중심극한정리(central limit theorem, CLT), 신뢰구간(confidence interval), p-value 등에 대한 모의실험을 통해 이해를 증진 혈압강하제 임상시험 DBP.txt: 통계패키지활용 Github 저장소에서 데이터 확인 가능 1960년대 중반 미국에서 실시한 고혈압 치료제 유효성 확인을 위한 임상시험 결과 데이터 총 40명의 고혈압 환자를 대상으로 임상시험을 실시했으며, 랜덤하게 환자를 고혈압 치료제 투여군(A)과 위약군(B)에 균등하게 배정 기처지(baseline, DBP1) 측정 이후 월 단위로 4 번 이완기 혈압(diastolic blood pressure, DBP)을 측정(DBP2 ~ DBP5) 유효성 평가는 기저치 대비 투약 4 개월 후 DBP의 변화(감소)량(d = DBP5 - DBP1)이 두 군간 차이를 보이는지… 데이터 요약 # 데이터 불러오기 DBP &lt;- read_delim(&quot;data/DBP.txt&quot;, delim = &quot;\\t&quot;) Rows: 40 Columns: 9 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;\\t&quot; chr (2): TRT, Sex dbl (7): Subject, DBP1, DBP2, DBP3, DBP4, DBP5, Age ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # 변화량 변수 추기 DBP &lt;- DBP %&gt;% mutate(DIFF = DBP5 - DBP1) # 각 투약군 별 변화량 측정값 DBP$DIFF[DBP$TRT == &quot;A&quot;] [1] -9 -15 -21 -14 -11 -15 -19 -18 -11 -18 -16 -14 -15 -19 -13 -14 -15 -17 -14 [20] -16 DBP$DIFF[DBP$TRT == &quot;B&quot;] [1] -1 -6 -5 1 -7 -4 -4 -6 -6 -7 -2 -8 -6 -5 -6 -8 -7 -4 -2 -3 # 요약 통계량 DBP %&gt;% group_by(TRT) %&gt;% summarise(N = n(), Mean = mean(DIFF, na.rm = TRUE), SD = sd(DIFF, na.rm = TRUE), Min = min(DIFF, na.rm = TRUE), Max = max(DIFF, na.rm = TRUE), Median = median(DIFF, na.rm = TRUE), Q1 = quantile(DIFF, probs = 0.25), Q3 = quantile(DIFF, probs = 0.75)) %&gt;% kbl %&gt;% kable_paper TRT N Mean SD Min Max Median Q1 Q3 A 20 -15.2 2.966479 -21 -9 -15.0 -17.25 -14.00 B 20 -4.8 2.419221 -8 1 -5.5 -6.25 -3.75 데이터 시각화 # 변화량 데이터의 분포 확인(치료약에 대해서) ## ggplot 사용 # require(tidyverse) require(ggpubr) DBP %&gt;% ggplot() + aes(x = DIFF, fill = TRT) + geom_density(color = &quot;white&quot;, alpha = 0.2) + scale_x_continuous(limits = c(-25, 5)) + geom_histogram(aes(y = ..density..), color = &quot;white&quot;, binwidth = 1.8, alpha = 0.4) + scale_fill_manual(values = c(&quot;red&quot;, &quot;blue&quot;)) + theme_minimal() -&gt; p1 DBP %&gt;% ggplot() + aes(x = TRT, y = DIFF, fill = TRT) + geom_boxplot(alpha = 0.4) + scale_fill_manual(values = c(&quot;red&quot;, &quot;blue&quot;)) + theme_minimal() -&gt; p2 # 두 개 플롯을 한 화면에 표시하기 위한 함수 ggarrange(p1, p2, ncol = 1, common.legend = TRUE) 위 데이터로부터 어떤 결론을 도출할 수 있을까? 혈압치료제 A는 4 개월 복용 후 DBP를 감소시키는가? 위약 B를 4 개월 복용 후에도 DBP를 감소 시키는가? 치료약 A는 위약 B보다 효과가 있는가? 위약 대비 치료약 A의 효과는 어느 정도인가? 다른 고혈압 환자가 치료제 A를 복용하면 어떤 효과가 있을까? require(tidymodels) # Question 1-2: 일표본 t 검정 DBP %&gt;% mutate_if(is.character, factor) %&gt;% group_by(TRT) %&gt;% nest %&gt;% # group 변수 별로 데이터 나누기 # split한 데이터셋 각각에 일표본 t-검정 실시 mutate(t_test_result = map(data, ~ t.test(.x$DIFF))) %&gt;% # ttest 결과로부터 통계량 추출 후 tibble로 변환 mutate(result = map(t_test_result, ~ tidy(.x))) %&gt;% select(TRT, result) %&gt;% unnest(cols = result) %&gt;% mutate_at(vars(statistic, conf.low, conf.high), format, digits = 3) %&gt;% mutate(p.value = format(p.value, digits = 2)) %&gt;% select(-method, -alternative) %&gt;% set_names(c(&quot;Treatment&quot;, &quot;$\\\\hat{\\\\delta}$&quot;, &quot;t-value&quot;, &quot;p-value&quot;, &quot;df&quot;, &quot;LCL (95%)&quot;, &quot;UCL (95%)&quot;)) %&gt;% kbl(escape = FALSE) %&gt;% kable_paper Treatment \\(\\hat{\\delta}\\) t-value p-value df LCL (95%) UCL (95%) A -15.2 -22.9 2.6e-15 19 -16.6 -13.8 B -4.8 -8.87 3.5e-08 19 -5.93 -3.67 # Question 3-4: 독립 이표본 t 검정 t.test(DIFF ~ TRT, data = DBP, var.equal = TRUE) Two Sample t-test data: DIFF by TRT t = -12.15, df = 38, p-value = 1.169e-14 alternative hypothesis: true difference in means between group A and group B is not equal to 0 95 percent confidence interval: -12.132758 -8.667242 sample estimates: mean in group A mean in group B -15.2 -4.8 중요 용어 모집단(population): 조사/실험/연구 등에서 관심의 대상이 되는 모든 개체의 관측값, 사건, 항목, 측정단위의 집합 \\(\\rightarrow\\) 획득한 데이터가 랜덤하게 표집되었다고 가정하는 분포 또는 집단 대한민국 20대 남녀을 대상으로 측정한 관찰값(예: 키, 몸무게, 설문지, 혈액검사, ECG, EEG 등) 모수(parameter): 모집단의 특성 또는 분포를 정의하는 알려지지 않은 상수(수식 표현 시 일반적으로 greek 문자로 표시) 이항분포(binomial distribution): 성공 또는 실패 중 하나가 결과로 나오는 실험을 \\(n\\) 번 시행했을 때 성공이 나올 확률 \\(\\theta\\) 정규분포(normal distribution): 평균 \\(\\mu\\), 표준편차 \\(\\sigma\\) 가설검정(hypothesis testing): 표본으로부터 얻은 정보를 토대로 모집단에 대한 특정 가설을 받아들이거나(accept) 혹은 기각(reject)을 위한 통계적 절차 귀무가설(null hypothesis): 모수에 대한 기존의 사실 또는 디폴트 값 두 측정 변수 간 연관성이 존재하지 않음/ 두 집단 간 평균의 차이가 없음 … \\(H_0: \\mu_X = \\mu_Y\\), \\(\\rho_{XY} = 0\\), … 대립가설(alternative hypothesis): 모수에 대해 귀무가설과 대립해 증명하고 싶은 사실 또는 연구자가 입증하고 싶어하는 가설 \\(H_1: \\mu_X \\neq \\mu_Y\\), \\(\\rho_{XY} \\neq 0\\) 1종 오류(type I error): 사실인 귀무가설을 기각할 사건(오류) 2종 오류(type II error): 대립가설이 사실인데 이를 기각한 사건 = 귀무가설이 거짓인데 귀무가설을 기각하지 않은 사건 P 값(p-value): 귀무가설이 참일 때 실제 데이터가 보여준 정도로 특이한 값이 관측될 확률 \\(\\rightarrow\\) 귀무가설 하에서 실제 데이터로부터 얻은 통계량이 관찰된 것과 같거나 그 이상의 극단적 결과를 얻을 확률 \\(\\rightarrow\\) 귀무가설이 참이라는 검정 통계량을 바탕으로 귀무가설을 기각했을 때 실제로 제 1종 오류를 범할 최대 확률 p-value = 0.5: 귀무가설 하에서 주어진 데이터로부터 얻은 통계량보다 크거나 작은 값들이 두 번에 한 번 꼴로 관찰 \\(\\rightarrow\\) 귀무가설을 기각하기에 충분한 근거가 아님 p-value = 0.0001: 귀무가설 하에서 데이터로부터 획득한 통계량만큼의 값을 관찰할 확률이 매우 낮음 \\(\\rightarrow\\) 귀무가설 기각하기에 충분한 근거 표본(sample): 통계적 처리를 위해 임의의 모집단으로부터 관찰된 일부 관찰값 또는 측정값의 집합 용어 연결(DBP 예제) 모집단: 미국 또는 지구 상 존재하는 모든 고혈압 환자 모수: 고혈압 환자에 치료약(A)와 위약(B)을 투여 했을 때, 기저치 대비 4개월 후 DBP 변화량의 평균 표본: 랜덤하게 표집된 전체 40명의 고혈압 환자(각 투여군 당 20 명씩 무작위로 배정된 고혈압 환자) 통계량: 각 투여군 별 기저치 대비 4개월 후 DBP 변화(감소)량의 평균 귀무가설: 치료약 A와 위약 B를 투여 했을 때 두 집단 간 DBP 변화(감소)량은 차이가 없다. 대립가설: 치료약 A를 투여 했을 때 DBP의 기저치 대비 변화(감소)량은 위약군에 비해 크다(같지 않다). 1종 오류: 실제 치료약 A와 위약 B의 DBP 변화량이 차이가 없음에도 불구하고 차이가 있다고 결론내릴 오류 2종 오류: 실제 치료약 A와 위약 B의 DBP 변화량이 차이가 있는데 이를 감지하지 못해 차이가 없다고 결론내릴 오류 P 값: 실제 두 투약군 간 차이가 없을 때 데이터가 보여준 두 군간 평균 변화량이 관찰된 값 이상의 극단적 결과를 얻을 확률 표본분포 통계학의 가장 중요한 개념: 우리가 현재 관측한 데이터는 특정 모수를 갖는 모집단에서 관측될 수 있는 여러 가능한 데이터 중 하나임. 예를 들어 DBP 예제처럼 또 다른 40명을 추출해 동일한 임상시험을 진행한다고 하면 DBP 변화량은 현재 데이터와 동일한 관찰값을 가지진 않을 것임. 즉, 표본을 추출할 때 마다 표본 간 그리고 표본 내 자연스러운 변동이 존재할 것임. 빈도론적 관점에서 통계학은 모집단으로부터 각기 다른 표본(일종의 평행우주)을 무수히 많이 추출 했다고 보고 이를 일반화 하는데서 모든 추론이 시작됨. 통계량(statistics): 모수를 추정하기 위해 표본(데이터)로부터 계산된 값(일반적으로 알파벳으로 표시) 표본평균 \\(\\bar{X}\\), 표본분산 \\(s^2\\) 통계량은 확률변수(random variable) 표본푼포(sampling distribution): 통계량의 분포. 즉, 여러 평행우주(표본)으로부터 도출한 각기 다른 값을 갖는 통계량이 이루는 분포 실제 관찰한 데이터 외에 “평행우주”로 지칭되는 나머지 표본은 관측되지 않은 값 \\(\\rightarrow\\) 시뮬레이션을 통해 가상의 평행우주를 생성 가능함 Figure 10.4: 모집단, 표본, 통계량, 표본분포 관계 DBP 예제에서 독립 이표본 t-검정을 시뮬레이션을 통해 확인 # 1. 현재 획득한 표본으로부터 필요한 통계량 계산 n1 &lt;- n2 &lt;- 20 n &lt;- n1 + n2 # 전체 표본 수 mu_real &lt;- tapply(DBP$DIFF, DBP$TRT, mean) sigma_real &lt;- tapply(DBP$DIFF, DBP$TRT, sd) delta_real &lt;- -diff(mu_real) sp &lt;- sqrt(mean(sigma_real^2)) tval &lt;- delta_real/(sp * sqrt(1/n1 + 1/n2)) set.seed(38317) # 귀무가설이 참(mu_a = mu_b)이라는 가정 하에서 # DBP 변화량의 두 군 간 차이에 대해 10,000개의 표본(평행우주) 생성 # 단, 분산(표준편차)은 현재 획득한 표본으로부터 구한 # 합동표준편차(분산)과 동일하다고 가정 # 표본 개수는 40개로 동일 B &lt;- 10000 delta_star &lt;- replicate(B, rnorm(n, 0, sp)) md_star &lt;- apply(delta_star, 2, mean) sd_star &lt;- apply(delta_star, 2, sd) t_star &lt;- md_star/(sd_star * sqrt(1/n1 + 1/n2)) par(mfrow = c(2, 2)) hist(md_star, nclass = 100, main = expression(Histogram~of~bar(delta)), xlim = c(-11, 2)) abline(v = delta_real, col = &quot;red&quot;) hist(sd_star, nclass = 100, main = expression(Histogram~of~s[p])) abline(v = sp, col = &quot;red&quot;) hist(t_star, nclass = 100, main = expression(Histogram~of~t[0]), xlim = c(-12.5, 3)) abline(v = tval, col = &quot;red&quot;) qqnorm(t_star); qqline(t_star) # p-value 계산: 귀무가설 하에 관찰한 통계량만큼 큰(작은) 값이 발생할 확률 length(which(t_star &lt; tval))/B [1] 0 중심극한정리 표본평균이 갖는 확률분포에 대한 정리 모집단의 분포와 관계 없이 표본의 크기(수)가 무한하게 크다면 표본평균의 분포는 정규분포에 근사 평균이 \\(\\mu\\) 이고, 분산이 \\(\\sigma^2\\) 인 임의의 모집단에서 추출한 표본 \\(X_{1}, X_2, \\ldots, X_n\\) 의 평균 \\(\\bar{X}\\) 의 분포는 \\(n\\rightarrow\\infty\\) 일 때(충분히 클 때), 근사적으로 평균이 \\(\\mu\\) 이고 분산이 \\(\\sigma^2 /n\\)인 정규분포를 따르고, \\(Z=\\sqrt{N}(\\bar X - \\mu)/\\sigma\\) 의 분포는 표준정규분포 \\(N(0, 1)\\)에 근사함. 통계적 추론의 핵심인 가설검정의 이론적 토대 마련 경험적으로 \\(n \\geq 30\\) 이면 표본평균 \\(\\bar X\\)는 정규분포를 따름 만약 표본의 크기가 무한하게 크다면( \\(n\\rightarrow\\infty\\) ), 표본평균의 분산은 0에 가까워 질 것이기 때문에 \\(\\bar X\\) 를 모평균 \\(\\mu\\)로 간주할 수 있음 # CLT 시각화를 위한 일반 함수 clt_test &lt;- function(rep = 300, # 반복 수 n = 50, mtrue = NULL, strue = NULL, FUN = rbinom, plot = TRUE, sim.out = FALSE, ...) { # browser() dots &lt;- list(...) x &lt;- matrix(nrow = n, ncol = rep) for (i in 1:n) { x[i, ] &lt;- apply(matrix(drop( mapply(FUN, i*rep, MoreArgs = dots)), i, rep), 2, mean) } if (is.null(mtrue)) mtrue = NA if (is.null(strue)) strue = NA mf &lt;- match.call() FUN.name &lt;- as.character(mf$FUN) title_name &lt;- switch(FUN.name, rbinom = &quot;Binomial distribution&quot;, rpois = &quot;Poisson distribution&quot;, runif = &quot;Uniform distribution&quot;, rexp = &quot;Exponential distribution&quot;, rnorm = &quot;Normal distribution&quot;, rchisq = expression(chi^2 ~ distribution), rt = &quot;t distribution&quot;) xlim &lt;- quantile(x, c(0.005, 0.995)) # norm_line_x &lt;- seq(xlim[1], xlim[2], length = 300) if (plot) { for (i in 1:n) { dev.hold() hist(x[i, ], freq = FALSE, main = title_name, xlab = substitute(italic(bar(X)[N == i]), list(i = i)), xlim = xlim) lines(density(x[i, ]), col = &quot;red&quot;) if (!is.na(mtrue) &amp;&amp; !is.na(strue)) { curve(dnorm(x, mtrue, strue/sqrt(i)), col = &quot;blue&quot;, lty = 2, add = TRUE) legend(&quot;bottomright&quot;, legend = bquote(mu == .(sprintf(&quot;%.3f&quot;, mtrue)) ~ sigma/sqrt(n) == .(sprintf(&quot;%.3f&quot;, strue/sqrt(i)))), bty = &quot;n&quot;, cex = 1.5) } legend(&quot;topright&quot;, legend = bquote(bar(bar(x)) == .(sprintf(&quot;%.3f&quot;, mean(x[i,]))) ~ hat(sigma)[bar(x)] == .(sprintf(&quot;%.3f&quot;, sd(x[i,])))), bty = &quot;n&quot;, cex = 1.5) dev.flush() # Sys.sleep(0.01) } } if (sim.out) return(x) } # binomial distribution # p &lt;- 0.25; size = 1 # clt_test(rep = 500, n = 50, # FUN = rbinom, mtrue = size * p, # strue = sqrt(size * p * (1 - p)), size = size, prob = p * size) # # clt_test(rep = 300, n = 30, FUN = rchisq, mtrue = 5, strue = sqrt(2*5), df = 5) 이항분포 베르누이 시행(Bernoulli trial): 성공 또는 실패로 결과가 나오는 시행 또는 시험 베르누이 시행을 \\(n\\) 번 반복 했을 때, 성공이 나타난 횟수를 확률변수 \\(X\\) \\(\\rightarrow\\) 이항확률변수(binomial random variable) \\(n\\) 번 베르누이 시행을 할 때, 각각의 시행은 서로 영향을 주지 않음 \\(\\rightarrow\\) 독립 성공 확률이 \\(\\theta\\) 이고, 실패확률이 \\(1-\\theta\\) 일 때, 베르누이 시행을 독립적으로 \\(n\\) 번 시행했을 때 성공횟수에 대한 확률분포 \\(\\rightarrow\\) 이항분포 이항분포의 확률질량함수 \\[P(X = x) = f(x; n, \\theta) = {n \\choose x} \\theta^x (1-\\theta)^{n-x}\\] 이항분포의 평균과 분산 \\[\\mu_X = n\\theta,~\\sigma^2_X = n\\theta(1-\\theta)\\] CLT에 따른 표본 평균의 정규근사 \\[ \\bar{X}_N \\stackrel{d}{\\rightarrow} \\mathcal{N}(\\mu, \\frac{\\sigma^2_X}{N}) = \\mathcal{N}(n\\theta, \\frac{n\\theta(1-\\theta)}{N}) \\] 예제 확률 변수 \\(X \\sim \\mathrm{binom}(n = 1, \\theta = 0.25)\\) 일때 표본분포의 CLT에 따른 표본 평균(300개의 평행우주로부터 표본 50개 추출) 의 정규 근사 과정 clt_test(rep = 300, n = 50, FUN = rbinom, mtrue = size * p, strue = sqrt(size * p * (1 - p)), size = size, prob = p) \\(\\theta = 0.25\\), \\(n = 1\\)인 이항분포의 표본평균 정규근사 포아송 분포 단위 시간 안에 어떤 사건이 몇 번 발생할 것인지를 표현한 이산확률분포로 정해진 시간 안에 어떤 사건이 일어날 횟수의 기댓값을 \\(\\lambda\\) 라고 할 때, 사건이 \\(n\\) 번 발생할 확률 확률질량함수 \\[ P(X =x; \\lambda) = \\frac{\\lambda^{x}e^{-\\lambda}}{x!} \\] 포아송 분포의 평균과 분산 \\[ \\mu_X = \\sigma^2_X = \\lambda \\] CLT에 따른 표본 평균의 정규근사 \\[ \\bar{X}_N \\stackrel{d}{\\rightarrow} \\mathcal{N}(\\mu, \\frac{\\sigma^2_X}{N}) = \\mathcal{N}(\\lambda, \\frac{\\lambda}{N}) \\] 예제 확률 변수 \\(X \\sim \\mathrm{pois}(\\lambda = 3)\\) 일때 표본분포의 CLT에 따른 표본 평균(300개의 평행우주로부터 표본 50개 추출) 의 정규 근사 과정 l &lt;- 3 clt_test(rep = 300, n = 50, FUN = rpois, mtrue = l, strue = sqrt(l), lambda = l) \\(\\lambda = 3\\)인 포아송 분포의 표본평균 정규근사 연속 균일 분포 확률밀도함수 \\[ f(X = x; a, b) = \\begin{cases} \\frac{1}{b - a}, &amp; ~ -\\infty &lt; a &lt; b &lt; \\infty \\\\ 0, &amp; \\mathrm{otherwise} \\end{cases} \\] 균일분포의 평균과 분산 \\[\\mu_X = \\frac{1}{2}(a + b), ~ \\sigma^2_X = \\frac{1}{12}(b - a)^2\\] CLT에 따른 표본 평균의 정규근사 \\[ \\bar{X}_N \\stackrel{d}{\\rightarrow} \\mathcal{N}(\\mu, \\frac{\\sigma^2_X}{N}) = \\mathcal{N}(\\frac{1}{2}(a +b), \\frac{(b - a)^2}{12N}) \\] 예제 확률 변수 \\(X \\sim U(0, 1)\\) 일때 표본분포의 CLT에 따른 표본 평균(300개의 평행우주로부터 표본 50개 추출) 의 정규 근사 과정 a = 0; b = 1 clt_test(rep = 300, n = 50, FUN = runif, mtrue = 0.5 * (a + b), strue = sqrt((b - a)^2/12), min = a, max = b) \\(X \\sim U(a = 0, b = 1)\\) 의 표본평균 정규근사 \\(\\chi^2\\) 분포 확률밀도함수 \\[ \\frac{1}{2^{\\nu/2}\\Gamma(\\nu/2)}x^{(\\nu/2) - 1}e^{-x/2}, ~ x \\in (0, +\\infty),~\\nu \\in \\mathbb{N} \\] \\(\\chi^2\\) 분포의 평균과 분산 \\[\\mu_X = \\nu, ~ \\sigma^2 = 2\\nu\\] CLT에 따른 표본 평균의 정규근사 \\[ \\bar{X}_N \\stackrel{d}{\\rightarrow} \\mathcal{N}(\\mu, \\frac{\\sigma^2_X}{N}) = \\mathcal{N}(\\nu, \\frac{2\\nu}{N}) \\] 예제 확률 변수 \\(X \\sim \\chi^2(\\nu = 3)\\) 일때 표본분포의 CLT에 따른 표본 평균(300개의 평행우주로부터 표본 50개 추출) 의 정규 근사 과정 nu = 3 clt_test(rep = 300, n = 50, FUN = rchisq, mtrue = nu, strue = sqrt(2*nu), df = nu) \\(X \\sim \\chi^2(\\nu = 3)\\) 의 표본평균 정규근사 신뢰구간의 정확한 의미 모평균 \\(\\mu\\)에 대한 \\((1 - \\alpha) \\%\\) 신뢰구간의 일반적 형태(모분산을 알고 있다고 가정한 경우) \\[ \\hat{\\mu} \\pm \\Phi^{-1}(\\alpha /2)\\frac{\\sigma}{\\sqrt{n}} \\] 신뢰구간: 같은 모형(분포)에서 반복적으로 표본을 추출해서 얻은 통계량에 대한 신뢰구간을 구했을 때 신뢰구간이 참 모수값을 포함할 확률이 \\((1 - \\alpha) %\\)가 되도록 만들어진 구간 주어진 확률\\((1 - \\alpha) \\%\\) (신뢰계수)에 대해 표본분포의 통계량이 모집단 모수에 포함되는 구간 모든 가능한 모수에 대한 표본 추정치의 신뢰구간 중 95 %가 모수를 포함 “모수가 신뢰구간에 포함될 확률”이라는 해석은 정확한 해석이 아님. 예제: sleep 데이터 10명의 대상자가 수면제 1과 수면제 2를 복용 시 수면시간 증가량 데이터 군 별 기술통계량 요약 # 독립 이표본 t 검정에서 두 군간 평균 차이에 대한 95% 신뢰구간 sleep %&gt;% group_by(group) %&gt;% summarise(N = n(), Mean = mean(extra), SD = sd(extra)) -&gt; desc_sleep desc_sleep %&gt;% kbl() %&gt;% kable_paper group N Mean SD 1 10 0.75 1.789010 2 10 2.33 2.002249 독립 이표본 t-검정 mean_diff &lt;- -diff(desc_sleep$Mean); mean_diff [1] -1.58 sp &lt;- sqrt(mean(desc_sleep$SD^2)) tval &lt;- mean_diff/(sp * sqrt(sum(1/desc_sleep$N))); tval [1] -1.860813 # df = n1 + n2 - 2 = 10 + 10 - 2 = 18 p.value &lt;- 2*pt(tval, df = 18); p.value [1] 0.07918671 해당 데이터가 주어졌을 때 두 군간 평균 차이에 대한 95 % 신뢰구간 alpha &lt;- 0.05 lcl &lt;- mean_diff - qt(1 - alpha/2, 18) * sqrt(sum((desc_sleep$SD^2)/10)) ucl &lt;- mean_diff + qt(1 - alpha/2, 18) * sqrt(sum((desc_sleep$SD^2)/10)) lcl; ucl [1] -3.363874 [1] 0.203874 # check t.test(extra ~ group, data = sleep, var.equal = TRUE) Two Sample t-test data: extra by group t = -1.8608, df = 18, p-value = 0.07919 alternative hypothesis: true difference in means between group 1 and group 2 is not equal to 0 95 percent confidence interval: -3.363874 0.203874 sample estimates: mean in group 1 mean in group 2 0.75 2.33 실제 \\(X_1 \\sim \\mathcal{N}(1.0, 1.79^2)\\), \\(X_2 \\sim \\mathcal{N}(3.0, 2.0^2)\\) 이라고 가정하고, 현재 획득한 표본 수 만큼 해당 분포로 부터 추출(\\(n_1 = 10, n_2 = 10\\)) 후, 두 군 간 평균 차이에 대한 95 % 신뢰구간을 구하는 작업을 100 번 반복 N &lt;- 100 n1 &lt;- n2 &lt;- 10 m_true &lt;- -2 # mu_x1 - mu_x2 mu_contain_count = 0 plot(c(1, N), c(-8, 2), type = &quot;n&quot;, ylab = &quot;95 % CI&quot;, xlab = &quot;Replicates&quot;) abline(h = m_true, col = &quot;red&quot;, lty = 2) set.seed(1313) for (i in 1:N) { x1 &lt;- rnorm(n1, 1, 1.79) x2 &lt;- rnorm(n2, 3, 2.0) md &lt;- mean(x1) - mean(x2) lcl &lt;- md - qt(1 - alpha/2, n1 + n2 - 2) * sqrt((sd(x1)^2 + sd(x2)^2)/10) ucl &lt;- md + qt(1 - alpha/2, n1 + n2 - 2) * sqrt((sd(x1)^2 + sd(x2)^2)/10) contain_mu &lt;- lcl &lt;= m_true &amp; m_true &lt;= ucl if(contain_mu) mu_contain_count &lt;- mu_contain_count + 1 segments(i, lcl, i, ucl, col = as.numeric(!contain_mu) + 1) } legend(&quot;bottomright&quot;, legend = sprintf(&quot;# of not containing true mu: %d&quot;, N - mu_contain_count), bty = &quot;n&quot;) 위 sleep 데이터의 결과가 모집단의 특성을 충분히 반영했다고 가정하고, 독립 이표본 t 검정에서 귀무가설이 참일 때 두 집단 간 평균 차이에 대한 95 % 신뢰구간이 0을 포함하는 빈도 m_true &lt;- 0 # mu_x1 - mu_x2 mu_contain_count = 0 plot(c(1, N), c(-6, 3), type = &quot;n&quot;, ylab = &quot;95 % CI&quot;, xlab = &quot;Replicates&quot;) abline(h = m_true, col = &quot;red&quot;, lty = 2) set.seed(1313) for (i in 1:N) { x1 &lt;- rnorm(n1, 0.75, 1.79) x2 &lt;- rnorm(n2, 2.33, 2.0) md &lt;- mean(x1) - mean(x2) lcl &lt;- md - qt(1 - alpha/2, n1 + n2 - 2) * sqrt((sd(x1)^2 + sd(x2)^2)/10) ucl &lt;- md + qt(1 - alpha/2, n1 + n2 - 2) * sqrt((sd(x1)^2 + sd(x2)^2)/10) contain_mu &lt;- lcl &lt;= m_true &amp; m_true &lt;= ucl if(contain_mu) mu_contain_count &lt;- mu_contain_count + 1 segments(i, lcl, i, ucl, col = as.numeric(!contain_mu) + 1) } legend(&quot;bottomright&quot;, legend = sprintf(&quot;# of not containing true mu: %d&quot;, N - mu_contain_count), bty = &quot;n&quot;) 10.4.0.1 P 값에 대한 이해 Simulation setting 1: 귀무가설이 참인 경우 \\(X \\sim \\mathcal{N}(\\mu_{X}, \\sigma^{2}_{X})\\), \\(Y \\sim \\mathcal{N}(\\mu_{Y}, \\sigma^{2}_{Y})\\) 일 때, \\(\\mu_{X}=\\mu_{Y}=100\\) 이고 \\(\\sigma_{X}=\\sigma_{Y}=20\\) \\(X\\)와 \\(Y\\)의 분포로부터 \\(n_X = n_Y = 30\\) 개를 추출한 데이터로 독립 이표본 t-검정 후 p-value 값 획득 10,000 번 반복 nsim &lt;- 10000 p &lt;- numeric(nsim) set.seed(19780904) for (i in 1:nsim) { x &lt;- rnorm(n = 30, mean = 100, sd = 20) y &lt;- rnorm(n = 30, mean = 100, sd = 20) p[i] &lt;- t.test(x, y)$p.value } hist(p, main = &quot;Histogram of p-values under the null hypothesis&quot;, xlab = &quot;Observed p-value&quot;, col = &quot;#87DAFA&quot;) \\(X\\)와 \\(Y\\)의 분포가 동일함에도 불구하고 관찰한 p-value의 4.8 % 가 0.05보다 작게 나타남. Simulation setting 2: 대립가설이 참인 경우 \\(\\mu_{X} = 100\\), \\(\\mu_{Y} = 96\\), \\(\\sigma_{X}=\\sigma_{Y}=20\\) 실제효과크기: \\(\\eta = 0.2\\) 첫 번째 모의실험과 동일한 크기로 진행 set.seed(19780904) for (i in 1:nsim) { x &lt;- rnorm(n = 30, mean = 100, sd = 20) y &lt;- rnorm(n = 30, mean = 96, sd = 20) p[i] &lt;- t.test(x, y)$p.value } hist(p, main = &quot;Histogram of p-values under the alternative hypothesis with ES = 0.2&quot;, xlab = &quot;Observed p-value&quot;, col = &quot;#87DAFA&quot;) \\(p&lt;0.05\\)인 비율: 11.8 % Simulation setting 3: 대립가설이 참, 표본 크기를 증가시킨 경우 \\(\\mu_{X} = 100\\), \\(\\mu_{Y} = 96\\), \\(\\sigma_{X}=\\sigma_{Y}=20\\) \\(X\\)와 \\(Y\\)의 분포로부터 \\(n_X = n_Y = 100\\) 개를 추출한 데이터로 독립 이표본 t-검정 후 p-value 값 획득 set.seed(19780904) for (i in 1:nsim) { x &lt;- rnorm(n = 100, mean = 100, sd = 20) y &lt;- rnorm(n = 100, mean = 96, sd = 20) p[i] &lt;- t.test(x, y)$p.value } hist(p, main = &quot;Histogram of p-values under the alternative hypothesis with 100 samples per group&quot;, xlab = &quot;Observed p-value&quot;, col = &quot;#87DAFA&quot;) \\(p&lt;0.05\\)인 비율: 28.3 % Simulation setting 4: 대립가설이 참, 효과크기가 1.0인 경우 \\(\\mu_{X} = 100\\), \\(\\mu_{Y} = 84\\), \\(\\sigma_{X}=\\sigma_{Y}=20\\) \\(X\\)와 \\(Y\\)의 분포로부터 \\(n_X = n_Y = 30\\) 개를 추출한 데이터로 독립 이표본 t-검정 후 p-value 값 획득 set.seed(19780904) for (i in 1:nsim) { x &lt;- rnorm(n = 30, mean = 100, sd = 20) y &lt;- rnorm(n = 30, mean = 80, sd = 20) p[i] &lt;- t.test(x, y)$p.value } hist(p, main = &quot;Histogram of p-values under the alternative hypothesis: n = 30, eta = 1.0&quot;, xlab = &quot;Observed p-value&quot;, col = &quot;#87DAFA&quot;) \\(p&lt;0.05\\)인 비율: 96.8 % p-value와 “통계적 유의성”에 대한 미국 통계학회 성명 P-value는 가정한 통계 모형이 데이터와 호환되지 않음을 나타낸다(P-values can indicate how incompatible the data are with a specified statistical model) P-value는 연구 가설이 참인 확률이나 데이터가 랜덤하게 생성된 확률을 측정하지 않는다(P-values do not measure the probability that the studied hypothesis is true, or the probability that the data were produced by random chance alone) 과학적 연구 결론 도출이나 비지니스 및 정책 결정 과정에서 p-value가 어떤 경계값(임계점)보다 크거나 작다는 것에 근거해서는 안된다(Scientific conclusions and business or policy decisions should not be based only on whether a p-value passes a specific threshold) 제대로된 추론을 위해서는 연구과정 전반에 대한 보고서와 투명성이 필요하다(Proper inference requires full reporting and transparency) P-value나 통계적 유의성은 효과의 크기나 결과의 중요성을 나타내지 않는다(A p-value, or statistical significance, does not measure the size of an effect or the importance of a result) P-value 자체만으로는 모형이나 가설에 대한 증거가 될 수 없다(By itself, a p-value does not provide a good measure of evidence regarding a model or hypothesis) "],["data-handling.html", "11 데이터 핸들링(Data handling)", " 11 데이터 핸들링(Data handling) 학습 목표 Hadely Weckam이 개발한 데이터의 전처리 및 시각화를 위해 각광받는 tidyverse 패키지에 대해 알아본다 데이터를 읽고, 저장하고, 목적에 맞게 가공하고, tidyverse 하에서 반복 계산 방법에 대해 알아본다. 데이터 분석과정 데이터를 R 작업환경(workspace)에 불러오고(import), 불러온 데이터를 가공하고(data management, data preprocessing), 가공한 데이터를 분석(analysis, modeling) 및 시각화(visualization) 후, 분석 결과를 저장(save) 및 외부 파일로 내보낸(export) 후, 이를 통해 전문가와 소통(communicate) Figure 11.1: Data 분석의 과정. Wickham and Grolemund (2016) 에서 발췌 R의 데이터 가공(관리) 방법 기본 R을 활용: 지금까지 배워온 방법으로 분석을 위한 데이터 가공(색인, 필터, 병합 등) tidyverse 패키지 활용 직관적 코드 작성 가능 빠른 실행속도 data.table 패키지 활용(본 강의에서는 다루지 않음) 빠른 실행속도 다양한 통계 함수와 최신 분석에 대한 여러 패키지 및 함수를 R 언어를 통해 활용 가능함에도 불구하고, 타 통계 소프트웨어(SAS, SPSS, Stata, Minitab 등)에 비해 데이터 가공 및 처리가 직관적이지 않고 불편했던 점은 R이 갖고 있던 큰 단점 중 하나임. RStudio의 수석 데이터 과학자인 Hadely Wickham의 tidyverse는 이러한 단점을 최대한 보완했고, 현재는 R을 통한 데이터 분석에서 핵심적인 도구로 자리매김 하고 있음. Tidyverse의 철학은 R 언어의 생태계에 혁신적인 변화를 가져왔을 뿐 아니라 지속적으로 진화하고 있기 때문에 해당 패키지들이 제공하는 언어 형태를 이해할 필요가 있음. References "],["tidyverse.html", "11.1 Tidyverse", " 11.1 Tidyverse “Tidy” + “Universe”의 조어로 “tidy data”의 기본 설계 철학, 문법 및 데이터 구조를 공유하는 RStudio 수석 과학자인 Hadley Wickham이 개발한 패키지 묶음(번들) 또는 메타 패키지로, 데이터 과학(data science)을 위한 R package를 표방 (Wickham 2019b) 데이터 분석 과정 중 가장 긴 시간을 할애하는 데이터 전처리(data preprocessing, data management, data wrangling, data munging 등으로 표현)를 위한 다양한 함수들을 제공하며, 특히 파이프(pipe) 연산자로 지칭되는 %&gt;%를 통한 코드의 간결성 및 가독성을 최대화 하는 것이 tidyverse 패키지들의 특징 Hadley Wickham이 주창한 Tidy Tools Manifesto에 따르면, tidyverse가 추구하는 프로그래밍 인터페이스에 대한 4 가지 원칙을 제시 기존 데이터의 구조를 재사용 파이프 연산자를 이용한 최대한 간결한 함수 작성 R의 특징 중 하나인 functional programming 수용 사람이 읽기 쉬운 프로그램으로 설계 Tidyverse를 구성하는 주요 패키지(알파벳 순) dplyr: 가장 일반적인 데이터 가공 및 처리 해결을 위한 “동사”(함수)로 구성된 문법 제공 forcat: 범주형 변수 처리를 위해 Rdml factor와 관련된 일반적인 문제 해결을 위한 함수 제공 ggplot2: 그래픽 문법을 기반으로 2차원 그래픽을 생성하기 위해 고안된 시스템 purrr: 함수 및 벡터의 반복 작업을 수행할 수 있는 도구를 제공 readr: base R에서 제공하는 파일 입출력 함수보다 효율적인 성능을 갖는 입출력 함수로 구성 stringr: 가능한 한 쉬운 방법으로 문자열을 다룰 수 있는 함수 제공 tibble: Tidyverse에서 재해석한 데이터 프레임 형태로 tidyverse에서 다루는 데이터의 기본 형태 tidyr: 데이터를 정리하고 “tidy data”를 도출하기 위한 일련의 함수 제공 그 밖에 유용한 tidyverse에 소속되어 있는 패키지 haven: 타 통계 프로그램(SAS, SPSS, Stata)의 데이터 포멧 입출력 함수 제공 readxl: Excel 파일 입력 함수 제공 lubridate: 시간(년/월/일/시/분) 데이터 가공 및 연산 함수 제공 magrittr: Tidyverse의 문법(함수)를 연결 시켜주는 파이프 연산자 제공. 예전에는 독립적인 패키지였으나 지금은 모든 tidyverse 패키지에 내장되어 있음 References "],["readr.html", "11.2 readr 패키지", " 11.2 readr 패키지 기본적으로 ?? 절에서 학습했던 read.table(), read.csv()와 거의 동일하게 작동하지만, 읽고 저장하는 속도가 base R에서 제공하는 기본 입출력 함수보다 월등히 뛰어남. 최근 readr 패키지에서 제공하는 입출력 함수보다 더 빠르게 데이터 입출력이 가능한 feather 패키지 (Wickham 2019a) 제공 데이터를 읽는 동안 사소한 문제가 있는 경우 해당 부분에 경고 표시 및 행, 관측 정보를 표시해줌 \\(\\rightarrow\\) 데이터 디버깅에 유용 주요 함수12 read_table(), write_table() read_csv(), write_csv() readr vignette을 통해 더 자세한 예시를 살펴볼 수 있음 read_csv( file, # 파일 명 col_names = TRUE, # 첫 번째 행를 변수명으로 처리할 것인지 여부 # read.table(), read.csv()의 header 인수와 동일 col_types = NULL, # 열(변수)의 데이터 형 지정 # 기본적으로 데이터 유형을 자동으로 감지하지만, # 입력 텍스트의 형태에 따라 데이터 유형을 # 잘못 추측할 수 있기 때문에 간혹 해당 인수 입력 필요 # col_* 함수 또는 campact string으로 지정 가능 # c=character, i=integer, n=number, d=double, # l=logical, f=factor, D=date, T=date time, t=time # ?=guess, _/- skip column progress, # 데이터 읽기/쓰기 진행 progress 표시 여부 ) 예시 # dataset/titanic3.csv 불러오기 titanic &lt;- read_csv(&quot;dataset/titanic3.csv&quot;) Rows: 1309 Columns: 14 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (7): name, sex, ticket, cabin, embarked, boat, home.dest dbl (7): pclass, survived, age, sibsp, parch, fare, body ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. titanic # read.csv와 비교 head(read.csv(&quot;dataset/titanic3.csv&quot;, header = T), 10) # column type을 변경 titanic2 &lt;- read_csv(&quot;dataset/titanic3.csv&quot;, col_types = &quot;iicfdiicdcfcic&quot;) titanic2 # 특정 변수만 불러오기 titanic3 &lt;- read_csv(&quot;dataset/titanic3.csv&quot;, col_types = cols_only( pclass = col_integer(), survived = col_integer(), sex = col_factor(), age = col_double() )) titanic3 # 대용량 데이터셋 읽어올 때 시간 비교 # install.packages(&quot;feather&quot;) # feather package require(feather) 필요한 패키지를 로딩중입니다: feather system.time(pulse &lt;- read.csv(&quot;dataset/pulse.csv&quot;, header = T)) 사용자 시스템 elapsed 4.686 0.032 4.721 write_feather(pulse, &quot;dataset/pulse.feather&quot;) system.time(pulse &lt;- readRDS(&quot;output/pulse.rds&quot;)) 사용자 시스템 elapsed 0.078 0.000 0.079 system.time(pulse &lt;- read_csv(&quot;dataset/pulse.csv&quot;)) Rows: 69 Columns: 20000 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; dbl (20000): V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13, V14, V1... ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. 사용자 시스템 elapsed 11.716 42.102 31.238 system.time(pulse &lt;- read_feather(&quot;dataset/pulse.feather&quot;)) 사용자 시스템 elapsed 4.383 0.000 4.388 11.2.1 tibble 패키지 readr 또는 readxl 패키지에서 제공하는 함수를 이용해 외부 데이터를 읽어온 후, 확인할 때 기존 데이터 프레임과 미묘한 차이점이 있다는 것을 확인 프린트된 데이터의 맨 윗 부분을 보면 A tibble: 데이터 차원 이 표시된 부분을 볼 수 있음 tibble은 tidyverse 생태계에서 사용되는 데이터 프레임 \\(\\rightarrow\\) 데이터 프레임을 조금 더 빠르고 사용하기 쉽게 수정한 버전의 데이터 프레임 tibble 생성하기 기본 R 함수에서 제공하는 as.* 계열 함수 처럼 as_tibble() 함수를 통해 기존 일반적인 형태의 데이터 프레임을 tibble 로 변환 가능 head(iris) as_tibble(iris) 개별 벡터로부터 tibble 생성 가능 방금 생성한 변수 참조 가능 문자형 변수가 입력된 경우 데이터 프레임과 다르게 별다른 옵션이 없어도 강제로 factor로 형 변환을 하지 않음 # 벡터로부터 tibble 객체 생성 tibble(x = letters, y = rnorm(26), z = y^2) # 데이터 프레임으로 위와 동일하게 적용하면? data.frame(x = letters, y = rnorm(26), z = y^2) Error in data.frame(x = letters, y = rnorm(26), z = y^2): 객체 &#39;y&#39;를 찾을 수 없습니다 # 벡터의 길이가 다른 경우 # 길이가 1인 벡터는 재사용 가능 tibble(x = 1, y = rep(0:1, each = 4), z = 2) # 데이터 프레임과 마찬가지로 비정상적 문자를 변수명으로 사용 가능 # 역따옴표(``) tibble(`2000` = &quot;year&quot;, `:)` = &quot;smile&quot;, `:(` = &quot;sad&quot;) tribble() 함수 사용: transposed (전치된) tibble의 약어로 데이터를 직접 입력 시 유용 tribble( ~x, ~y, ~z, &quot;M&quot;, 172, 69, &quot;F&quot;, 156, 45, &quot;M&quot;, 165, 73, ) tibble()과 data.frame()의 차이점 가장 큰 차이점은 데이터 처리의 속도 및 데이터의 프린팅 tibble이 데이터 프레임 보다 간결하고 많은 정보 확인 가능 str()에서 확인할 수 있는 데이터 유형 확인 가능 head(iris) dd &lt;- as_tibble(iris) dd References "],["dplyr.html", "11.3 dplyr 패키지", " 11.3 dplyr 패키지 dplyr에서 제공하는 “동사”(함수)로 데이터(데이터 프레임) 전처리 방법에 대해 익힌다. dplyr은 tidyverse 에서 데이터 전처리를 담당하는 패키지로 데이터 전처리 과정을 쉽고 빠르게 수행할 수 있는 함수로 구성된 패키지임. 데이터 핸들링을 위해 Hadley Wickham이 개발한 plyr 패키지를 최적화한 패키지로 C++ 로 코딩되어 성능이 plyr에 비해 월등히 우수함. base R에 존재하는 함수만으로도 전처리는 충분히 가능하나, dplyr은 아래와 같은 장점을 가짐 파이프 연산자(%&gt;%)로 코드의 가독성 극대화 코드 작성이 쉬움 전통적인 R의 데이터 처리에서 사용되는 [, [[, $와 같은 색인 연산자 최소화 dplyr은 몇 가지 “동사”를 조합하여 사용 RStudio를 사용할 경우 코드 작성이 빨라짐 접근 방법이 SQL 문과 유사함 dplyr은 초기 데이터 프레임만을 다루지만, purrr 패키지를 통해 행렬, 배열, 리스트 등에도 적용 가능 dplyr에서 제공하는 가장 기본 “동사”는 다음과 같음 filter(): 각 행(row)을 조건에 따라 선택 arrange(): 선택한 변수(column)에 해당하는 행(row)을 기준으로 정렬 select(): 변수(column) 선택 mutate(): 새로운 변수를 추가하거나 이미 존재하는 변수를 변환 summarize() 또는 summarise(): 변수 집계(평균, 표준편차, 최댓값, 최솟값, …) group_by() : 위 열거한 모든 동사들을 그룹별로 적용 base R 제공 함수와 비교 Table 11.1: dplyr 패키지 함수와 R base 패키지 함수 비교 동사(함수) 내용 R base 패키지 함수 filter() 행 추출 subset() arrange() 내림차순/오름차순 정렬 order(), sort() select() 열 선택 data[, c(‘var_name01’, ‘var_name03’)] mutate() 열 추가 및 변환 transform() summarise() 집계 aggregate() group_by() 그룹별 집계 및 함수 적용 dplyr 기본 동사와 연동해서 사용되는 주요 함수 slice(): 행 색인을 이용한 추출 \\(\\rightarrow\\) data[n:m, ]과 동일 distinct(): 행 레코드 중 중복 항복 제거 \\(\\rightarrow\\) base R 패키지의 unique() 함수와 유사 sample_n(), sample_frac(): 데이터 레코드를 랜덤하게 샘플링 rename(): 변수명 변경 inner_join, right_join(), left_join(), full_join : 두 데이터셋 병합 \\(\\rightarrow\\) merge() 함수와 유사 tally(), count(), n(): 데이터셋의 행의 길이(개수)를 반환하는 함수로 (그룹별) 집계에 사용: length(), nrow()/NROW() 함수와 유사 *_all,, *_at, *_if: dplyr에서 제공하는 기본 동사(group_by() 제외) 사용 시 적용 범위를 설정해 기본 동사와 동일한 기능을 수행하는 함수 R에서 데이터 전처리 및 분석을 수행할 때, 간혹 동일한 이름의 함수명들이 중복된 채 R 작업공간에 읽어오는 경우가 있는데, 이 경우 가장 마지막에 읽어온 패키지의 함수를 작업공간에서 사용한다. 예를 들어 R base 패키지의 filter() 함수는 시계열 데이터의 노이즈를 제거하는 함수이지만, tidyverse 패키지를 읽어온 경우, dplyr 패키지의 filter() 함수와 이름이 중복되기 때문에 R 작업공간 상에서는 dplyr 패키지의 filter()가 작동을 함. 만약 stats 패키지의 filter() 함수를 사용하고자 하면 stats::filter()를 사용. 이를 더 일반화 하면 현재 컴퓨터 상에 설치되어 있는 R 패키지의 특정 함수는 :: 연산자를 통해 접근할 수 있으며, package_name::function_name() 형태로 접근 가능함. 11.3.1 파이프 연산자: %&gt;% Tidyverse 세계에서 tidy를 담당하는 핵심적인 함수 여러 함수를 연결(chain)하는 역할을 하며, 이를 통해 불필요한 임시변수를 정의할 필요가 없어짐 function_1(x) %&gt;% function_2(y) = function_2(function_1(x), y): function_1(x)에서 반환한 값을 function_2()의 첫 번째 인자로 사용 x %&gt;% f(y) %&gt;% g(z)= ? 기존 R 문법과 차이점 기존 R: 동사(목적어, 주변수, 나머지 변수) Pipe 연결 방식: 목적어 %&gt;% 동사(주변수, 나머지 변수) 예시 # base R 문법 적용 print(head(iris, 4)) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa # %&gt;% 연산자 이용 iris %&gt;% head(4) %&gt;% print Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa # setosa 종에 해당하는 변수들의 평균 계산 apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, mean) Sepal.Length Sepal.Width Petal.Length Petal.Width 5.006 3.428 1.462 0.246 # tidyverse의 pipe 연산자 이용 # require(tidyverse) iris %&gt;% filter(Species == &quot;setosa&quot;) %&gt;% select(-Species) %&gt;% summarise_all(mean) # Homework #3 b-c 풀이를 위한 pipe 연산 적용 # df &lt;- within(df, { # am &lt;- factor(am, levels = 0:1, # labels = c(&quot;automatic&quot;, &quot;manual&quot;)) # }) # ggregate(cbind(mpg, disp, hp, drat, wt, qsec) ~ am, # data = df, # mean) # aggregate(cbind(mpg, disp, hp, drat, wt, qsec) ~ am, # data = df, # sd) mtcars %&gt;% mutate(am = factor(vs, levels = 0:1, labels = c(&quot;automatic&quot;, &quot;manual&quot;))) %&gt;% group_by(am) %&gt;% summarise_at(vars(mpg, disp:qsec), list(mean = mean, sd = sd)) 11.3.2 filter() 행(row, case, observation) 조작 동사 데이터 프레임(또는 tibble)에서 특정 조건을 만족하는 레코드(row) 추출 Figure 11.2: filter() 함수 다이어그램 R base 패키지의 subset() 함수와 유사하게 작동하지만 성능이 더 좋음(속도가 더 빠르다). 추출을 위한 조건은 2.2.4 절 논리형 스칼라에서 설명한 비교 연산자를 준용함. 단 filter() 함수 내에서 and (&amp;) 조건은 ,(콤마, comma)로 표현 가능 filter()에서 가능한 불린(boolean) 연산 Figure 11.3: 가능한 모든 boolean 연산 종류: x는 좌변, y는 우변을 의미하고 음영은 연산 이후 선택된 부분을 나타냄. # filter() 동사 prototype dplyr::filter(x, # 데이터 프레임 또는 티블 객체 condition_01, # 첫 번째 조건 condition_02, # 두 번째 조건 # 두 번째 인수 이후 조건들은 # condition_1 &amp; condition 2 &amp; ... &amp; condition_n 임 ...) 예시 1: mpg 데이터(ggplot2 패키지 내장 데이터) mpg 데이터 코드북 데이터 구조 확인을 위해 dplyr 패키지에서 제공하는 glimpse() 함수(str() 유사) 사용 Table 11.2: mpg 데이터셋 설명(코드북) 변수명 변수설명(영문) 변수설명(국문) manufacturer manufacturer name 제조사 model model name 모델명 displ engine displacement, in litres 배기량 (리터) year year of manufacture 제조년도 cyl number of cylinders 엔진 기통 수 trans type of transmission 트렌스미션 drv the type of drive train, where f = front-wheel drive, r = rear wheel drive, 4 = 4wd 구동 유형: f = 전륜구동, r = 후륜구동, 4 = 4륜 구동 cty city miles per gallon 시내 연비 hwy highway miles per gallon 고속 연비 fl fuel type: e = E85, d = diesel, r = regular, p = premium, c = CNG 연료: e = 에탄올 85, r = 가솔린, p = 프리미엄, d = 디젤, c = CNP class ‘type’ of car 자동차 타입 glimpse(mpg) Rows: 234 Columns: 11 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cyl &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, … $ trans &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;auto… $ drv &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2… $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p… $ class &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;c… # 현대 차만 추출 ## 기본 문법 사용 # mpg[mpg$manufacturer == &quot;hyundai&quot;, ] # subset(mpg, manufacturer == &quot;hyundai&quot;) ## filter() 함수 사용 # filter(mpg, manufacturer == &quot;hyundai&quot;) ## pipe 연산자 사용 mpg %&gt;% filter(manufacturer == &quot;hyundai&quot;) # 시내 연비가 20 mile/gallon 이상이고 타입이 suv 차량 추출 ## 기본 문법 사용 # mpg[mpg$cty &gt;= 20 &amp; mpg$class == &quot;suv&quot;, ] # subset(mpg, cty &gt;= 20 &amp; class == &quot;suv&quot;) ## filter() 함수 사용 # filter(mpg, cty &gt;= 20, class == &quot;suv&quot;) ## pipe 연산자 사용 mpg %&gt;% filter(cty &gt;= 20, class == &quot;suv&quot;) # 제조사가 audi 또는 volkswagen 이고 고속 연비가 30 miles/gallon 인 차량만 추출 mpg %&gt;% filter(manufacturer == &quot;audi&quot; | manufacturer == &quot;volkswagen&quot;, hwy &gt;= 30) 11.3.3 arrange() 행(row, case, observation) 조작 동사 지정한 열을 기준으로 데이터의 레코드(row)를 오름차순(작은 값부터 큰 값)으로 정렬 내림차순(큰 값부터 작은 값) 정렬 시 desc() 함수 이용 Figure 11.4: arrange() 함수 다이어그램 arrange(data, # 데이터 프레임 또는 티블 객체 var1, # 기준 변수 1 var2, # 기준 변수 2 ...) 예시 1: mpg 데이터셋 # 시내 연비를 기준으로 오름차순 정렬 ## R 기본 문법 사용 # mpg[order(mpg$cty), ] ## arrange 함수 사용 # arrange(mpg, cty) ## pipe 사용 mpg_asc &lt;- mpg %&gt;% arrange(cty) mpg_asc %&gt;% print # A tibble: 234 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 dodge dakota pi… 4.7 2008 8 auto… 4 9 12 e pick… 2 dodge durango 4… 4.7 2008 8 auto… 4 9 12 e suv 3 dodge ram 1500 … 4.7 2008 8 auto… 4 9 12 e pick… 4 dodge ram 1500 … 4.7 2008 8 manu… 4 9 12 e pick… 5 jeep grand che… 4.7 2008 8 auto… 4 9 12 e suv 6 chevrolet c1500 sub… 5.3 2008 8 auto… r 11 15 e suv 7 chevrolet k1500 tah… 5.3 2008 8 auto… 4 11 14 e suv 8 chevrolet k1500 tah… 5.7 1999 8 auto… 4 11 15 r suv 9 dodge caravan 2… 3.3 2008 6 auto… f 11 17 e mini… 10 dodge dakota pi… 5.2 1999 8 manu… 4 11 17 r pick… # … with 224 more rows # 시내 연비는 오름차순, 차량 타입은 내림차순(알파벳 역순) 정렬 ## R 기본 문법 사용 ### 문자형 벡터의 순위 계산을 위해 rank() 함수 사용 mpg_sortb &lt;- mpg[order(mpg$cty, -rank(mpg$class)), ] ## arrange 함수 사용 mpg_sortt &lt;- mpg %&gt;% arrange(cty, desc(class)) mpg_sortt %&gt;% print # A tibble: 234 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 dodge durango 4… 4.7 2008 8 auto… 4 9 12 e suv 2 jeep grand che… 4.7 2008 8 auto… 4 9 12 e suv 3 dodge dakota pi… 4.7 2008 8 auto… 4 9 12 e pick… 4 dodge ram 1500 … 4.7 2008 8 auto… 4 9 12 e pick… 5 dodge ram 1500 … 4.7 2008 8 manu… 4 9 12 e pick… 6 chevrolet c1500 sub… 5.3 2008 8 auto… r 11 15 e suv 7 chevrolet k1500 tah… 5.3 2008 8 auto… 4 11 14 e suv 8 chevrolet k1500 tah… 5.7 1999 8 auto… 4 11 15 r suv 9 dodge durango 4… 5.2 1999 8 auto… 4 11 16 r suv 10 dodge durango 4… 5.9 1999 8 auto… 4 11 15 r suv # … with 224 more rows # 두 데이터 셋 동일성 여부 identical(mpg_sortb, mpg_sortt) [1] TRUE 11.3.4 select() 열(변수) 조작 동사 데이터셋을 구성하는 열(column, variable)을 선택하는 함수 Figure 7.4: select() 함수 다이어그램 select( data, # 데이터 프레임 또는 티블 객체 var_name1, # 변수 이름 (따옴표 없이도 가능) var_name2, ... ) # 제조사(manufacturer), 모델명(model), 배기량(displ) # 제조년도(year), 시내연비 (cty)만 추출 ## 기본 R 문법 이용한 변수 추출 glimpse(mpg[, c(&quot;manufacturer&quot;, &quot;model&quot;, &quot;displ&quot;, &quot;year&quot;, &quot;cty&quot;)]) Rows: 234 Columns: 5 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… # glimpse(mpg[, c(1:4, 8)]) # glimpse(mpg[, names(mpg) %in% c(&quot;manufacturer&quot;, &quot;displ&quot;, &quot;model&quot;, # &quot;year&quot;, &quot;cty&quot;)]) ## select() 함수 이용 ### 아래 스크립트는 모두 동일한 결과를 반환 # mpg %&gt;% select(1:4, 8) # # mpg %&gt;% # select(c(&quot;manufacturer&quot;, &quot;model&quot;, &quot;displ&quot;, &quot;year&quot;, &quot;cty&quot;)) mpg %&gt;% select(&quot;manufacturer&quot;, &quot;model&quot;, &quot;displ&quot;, &quot;year&quot;, &quot;cty&quot;) %&gt;% glimpse Rows: 234 Columns: 5 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… R 기본 문법과 차이점 선택하고자 하는 변수 입력 시 따옴표가 필요 없음 : 연산자를 이용해 선택 변수의 범위 지정 가능 - 연산자를 이용해 선택 변수 제거 # 제조사(manufacturer), 모델명(model), 배기량(displ) # 제조년도(year), 시내연비 (cty)만 추출 ## select() 따옴표 없이 변수명 입력 mpg %&gt;% select(manufacturer, model, displ, year, cty) %&gt;% glimpse Rows: 234 Columns: 5 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… ## : 연산자로 변수 범위 지정 mpg %&gt;% select(manufacturer:year, cty) %&gt;% glimpse Rows: 234 Columns: 5 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… ## 관심 없는 열을 -로 제외 가능 mpg %&gt;% select(-cyl, -trans, -drv, -hwy, -fl, -class) %&gt;% glimpse Rows: 234 Columns: 5 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… ## 조금 더 간결하게 (`:`와 `-` 연산 조합) mpg %&gt;% select(-cyl:-drv, -hwy:-class) %&gt;% glimpse Rows: 234 Columns: 5 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… ### 동일한 기능: -는 괄호로 묶을 수 있음 mpg %&gt;% select(-(cyl:drv), -(hwy:class)) %&gt;% glimpse Rows: 234 Columns: 5 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… # select() 함수를 이용해 변수명 변경 가능 mpg %&gt;% select(city_mpg = cty) %&gt;% glimpse Rows: 234 Columns: 1 $ city_mpg &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 15, 1… select()와 조합 시 유용한 선택 함수 starts_with(\"abc\"): “abc”로 시작하는 변수 선택 ends_with(\"xyz\"): “xyz”로 끝나는 변수 선택 contains(\"def\"): “def”를 포함하는 변수 선택 matches(\"^F[0-9]\"): 정규표현식과 일치하는 변수 선택. “F”와 한 자리 숫자로 시작하는 변수 선택 everything(): select() 함수 내에서 미리 선택한 변수를 제외한 모든 변수 선택 # &quot;m&quot;으로 시작하는 변수 제거 ## 기존 select() 함수 사용 mpg %&gt;% select(-manufacturer, -model) %&gt;% glimpse Rows: 234 Columns: 9 $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.8, 2.8,… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 2008, 2008… $ cyl &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8… $ trans &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;auto(l5)&quot;, … $ drv &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;,… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 15, 15, … $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 25, 24, … $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;,… $ class &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;… ## select() + starts_with() 함수 사용 mpg %&gt;% select(-starts_with(&quot;m&quot;)) %&gt;% glimpse Rows: 234 Columns: 9 $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.8, 2.8,… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 2008, 2008… $ cyl &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8… $ trans &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;auto(l5)&quot;, … $ drv &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;,… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 15, 15, … $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 25, 24, … $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;,… $ class &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;… # &quot;l&quot;로 끝나는 변수 선택: ends_with() 함수 사용 mpg %&gt;% select(ends_with(&quot;l&quot;)) %&gt;% glimpse Rows: 234 Columns: 4 $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;a4 quat… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.8, 2.8,… $ cyl &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8… $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;,… # dplyr 내장 데이터: starwars에서 이름, 성별, &quot;color&quot;를 포함하는 변수 선택 ## contains() 함수 사용 starwars %&gt;% select(name, gender, contains(&quot;color&quot;)) %&gt;% head # 다시 mpg 데이터... ## 맨 마지막 문자가 &quot;y&quot;로 끝나는 변수 선택(제조사, 모델 포함) ## matches() 사용 mpg %&gt;% select(starts_with(&quot;m&quot;), matches(&quot;y$&quot;)) %&gt;% glimpse Rows: 234 Columns: 4 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2… # cty, hwy 변수를 각각 1-2 번째 열에 위치 mpg %&gt;% select(matches(&quot;y$&quot;), everything()) %&gt;% glimpse Rows: 234 Columns: 11 $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2… $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cyl &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, … $ trans &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;auto… $ drv &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4… $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p… $ class &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;c… 11.3.5 mutate() 열(변수) 조작 동사: 새로운 열을 추가하는 함수로 기본 R 문법의 data$new_variable &lt;- value 와 유사한 기능을 함 주어진 데이터 셋(데이터 프레임)에 이미 존재하고 있는 변수를 이용해 새로운 값 변환 시 유용 새로 만든 열을 mutate() 함수 내에서 사용 가능 \\(\\rightarrow\\) R base 패키지에서 재공하는 transform() 함수는 mutate() 함수와 거의 동일한 기능을 하지만, transform() 함수 내에서 생성한 변수의 재사용이 불가능 Figure 11.5: mutate() 함수 다이어그램 # mpg 데이터 셋의 연비 단위는 miles/gallon으로 입력 -&gt; kmh/l 로 변환 mile &lt;- 1.61 #km gallon &lt;- 3.79 #litres kpl &lt;- mile/gallon ## 기본 R 문법 glimpse(transform(mpg, cty_kpl = cty * kpl, hwy_kpl = hwy * kpl)) Rows: 234 Columns: 13 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cyl &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, … $ trans &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;auto… $ drv &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2… $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p… $ class &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;c… $ cty_kpl &lt;dbl&gt; 7.646438, 8.920844, 8.496042, 8.920844, 6.796834, 7.64643… $ hwy_kpl &lt;dbl&gt; 12.319261, 12.319261, 13.168865, 12.744063, 11.044855, 11… ## tidyverse 문법 mpg %&gt;% mutate(cty_kpl = cty*kpl, hwy_kpl = hwy*kpl) %&gt;% glimpse Rows: 234 Columns: 13 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cyl &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, … $ trans &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;auto… $ drv &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2… $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p… $ class &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;c… $ cty_kpl &lt;dbl&gt; 7.646438, 8.920844, 8.496042, 8.920844, 6.796834, 7.64643… $ hwy_kpl &lt;dbl&gt; 12.319261, 12.319261, 13.168865, 12.744063, 11.044855, 11… # 새로 생성한 변수를 이용해 변환 변수를 원래 단위로 바꿔보기 ## R 기본 문법: transform() 사용 glimpse(transform(mpg, cty_kpl = cty * kpl, hwy_kpl = hwy * kpl, cty_raw = cty_kpl/kpl, hwy_raw = hwy_kpl/kpl, )) Error in eval(substitute(list(...)), `_data`, parent.frame()): 객체 &#39;cty_kpl&#39;를 찾을 수 없습니다 ## Tidyverse 문법 mpg %&gt;% mutate(cty_kpl = cty*kpl, hwy_kpl = hwy*kpl, cty_raw = cty_kpl/kpl, hwy_raw = hwy_kpl/kpl) %&gt;% glimpse Rows: 234 Columns: 15 $ manufacturer &lt;chr&gt; &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;audi&quot;, &quot;… $ model &lt;chr&gt; &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4&quot;, &quot;a4 quattro&quot;, &quot;… $ displ &lt;dbl&gt; 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.… $ year &lt;int&gt; 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200… $ cyl &lt;int&gt; 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, … $ trans &lt;chr&gt; &quot;auto(l5)&quot;, &quot;manual(m5)&quot;, &quot;manual(m6)&quot;, &quot;auto(av)&quot;, &quot;auto… $ drv &lt;chr&gt; &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, &quot;4… $ cty &lt;int&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… $ hwy &lt;int&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2… $ fl &lt;chr&gt; &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p&quot;, &quot;p… $ class &lt;chr&gt; &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;compact&quot;, &quot;c… $ cty_kpl &lt;dbl&gt; 7.646438, 8.920844, 8.496042, 8.920844, 6.796834, 7.64643… $ hwy_kpl &lt;dbl&gt; 12.319261, 12.319261, 13.168865, 12.744063, 11.044855, 11… $ cty_raw &lt;dbl&gt; 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1… $ hwy_raw &lt;dbl&gt; 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2… 11.3.6 transmute() 열(변수) 조작 동사: mutate()와 유사한 기능을 하지만 추가 또는 변환된 변수만 반환 `연비` &lt;- mpg %&gt;% transmute(cty_kpl = cty*kpl, hwy_kpl = hwy*kpl, cty_raw = cty_kpl/kpl, hwy_raw = hwy_kpl/kpl) `연비` %&gt;% print # A tibble: 234 × 4 cty_kpl hwy_kpl cty_raw hwy_raw &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 7.65 12.3 18 29 2 8.92 12.3 21 29 3 8.50 13.2 20 31 4 8.92 12.7 21 30 5 6.80 11.0 16 26 6 7.65 11.0 18 26 7 7.65 11.5 18 27 8 7.65 11.0 18 26 9 6.80 10.6 16 25 10 8.50 11.9 20 28 # … with 224 more rows 11.3.7 summarise() 변수 요약 및 집계: 변수를 집계하는 함수로 R stat 패키지(R 처음 실행 시 기본으로 불러오는 패키지 중 하나)의 aggregate() 함수와 유사한 기능을 함 보통 mean(), sd(), var(), median(), min(), max() 등 요약 통계량을 반환하는 함수와 같이 사용 데이터 프레임(티블) 객체 반환 변수의 모든 레코드에 집계 함수를 적용하므로 summarise()만 단일로 사용하면 1개의 행만 반환 Figure 11.6: summarise() 함수 다이어그램 # cty, hwy의 평균과 표준편차 계산 mpg %&gt;% summarise(mean_cty = mean(cty), sd_cty = sd(cty), mean_hwy = mean(hwy), sd_hwy = sd(hwy)) 11.3.8 group_by() 행(row, case, observation) 그룹화 보통 summarise() 함수는 aggregate()함수와 유사하게 그룹 별 요약 통계량을 계산할 때 주로 사용됨 group_by()는 “주어진 그룹에 따라(by group)”, 즉 지정한 그룹(변수) 별 연산을 지정 Figure 10.2: group_by() 함수 다이어그램 # 모델, 년도에 따른 cty, hwy 평균 계산 by_mpg &lt;- group_by(mpg, model, year) ## 그룹 지정 check by_mpg %&gt;% head %&gt;% print # A tibble: 6 × 11 # Groups: model, year [2] manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… ## 통계량 계산 by_mpg %&gt;% summarise(mean_cty = mean(cty), mean_hwy = mean(hwy)) %&gt;% print `summarise()` has grouped output by &#39;model&#39;. You can override using the `.groups` argument. # A tibble: 76 × 4 # Groups: model [38] model year mean_cty mean_hwy &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 4runner 4wd 1999 15.2 19 2 4runner 4wd 2008 15 18.5 3 a4 1999 18.2 27.5 4 a4 2008 19.7 29.3 5 a4 quattro 1999 16.5 25.2 6 a4 quattro 2008 17.8 26.2 7 a6 quattro 1999 15 24 8 a6 quattro 2008 16.5 24 9 altima 1999 20 28 10 altima 2008 21 29 # … with 66 more rows ## by_group() chain 연결 mean_mpg &lt;- mpg %&gt;% group_by(model, year) %&gt;% summarise(mean_cty = mean(cty), mean_hwy = mean(hwy)) group_by() 이후 적용되는 동사는 모두 그룹 별 연산 수행 # 제조사 별 시내연비가 낮은 순으로 정렬 audi &lt;- mpg %&gt;% group_by(manufacturer) %&gt;% arrange(cty) %&gt;% filter(manufacturer == &quot;audi&quot;) audi %&gt;% print # A tibble: 18 × 11 # Groups: manufacturer [1] manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 quattro 2.8 1999 6 auto… 4 15 25 p comp… 2 audi a4 quattro 3.1 2008 6 manu… 4 15 25 p comp… 3 audi a6 quattro 2.8 1999 6 auto… 4 15 24 p mids… 4 audi a4 2.8 1999 6 auto… f 16 26 p comp… 5 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… 6 audi a6 quattro 4.2 2008 8 auto… 4 16 23 p mids… 7 audi a4 quattro 2.8 1999 6 manu… 4 17 25 p comp… 8 audi a4 quattro 3.1 2008 6 auto… 4 17 25 p comp… 9 audi a6 quattro 3.1 2008 6 auto… 4 17 25 p mids… 10 audi a4 1.8 1999 4 auto… f 18 29 p comp… 11 audi a4 2.8 1999 6 manu… f 18 26 p comp… 12 audi a4 3.1 2008 6 auto… f 18 27 p comp… 13 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… 14 audi a4 quattro 2 2008 4 auto… 4 19 27 p comp… 15 audi a4 2 2008 4 manu… f 20 31 p comp… 16 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… 17 audi a4 1.8 1999 4 manu… f 21 29 p comp… 18 audi a4 2 2008 4 auto… f 21 30 p comp… 그룹화된 데이터셋을 다시 그룹화 하지 않은 원래 데이터셋으로 변경할 때 ungroup() 함수를 사용 11.3.9 dplyr 관련 유용한 함수 데이터 핸들링 시 dplyr 기본 함수와 같이 사용되는 함수 모음 slice() 행(row, case, observation) 조작 동사: filter()의 특별한 케이스로 데이터의 색인을 직접 설정하여 원하는 row 추출 # 1 ~ 8행에 해당하는 데이터 추출 slice_mpg &lt;- mpg %&gt;% slice(1:8) slice_mpg %&gt;% print # A tibble: 8 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto(… f 18 29 p comp… 2 audi a4 1.8 1999 4 manua… f 21 29 p comp… 3 audi a4 2 2008 4 manua… f 20 31 p comp… 4 audi a4 2 2008 4 auto(… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto(… f 16 26 p comp… 6 audi a4 2.8 1999 6 manua… f 18 26 p comp… 7 audi a4 3.1 2008 6 auto(… f 18 27 p comp… 8 audi a4 quattro 1.8 1999 4 manua… 4 18 26 p comp… # 각 모델 별 첫 번째 데이터만 추출 slice_mpg_grp &lt;- mpg %&gt;% group_by(model) %&gt;% slice(1) %&gt;% arrange(model) slice_mpg_grp %&gt;% print # A tibble: 38 × 11 # Groups: model [38] manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 toyota 4runner 4… 2.7 1999 4 manu… 4 15 20 r suv 2 audi a4 1.8 1999 4 auto… f 18 29 p comp… 3 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… 4 audi a6 quattro 2.8 1999 6 auto… 4 15 24 p mids… 5 nissan altima 2.4 1999 4 manu… f 21 29 r comp… 6 chevrolet c1500 sub… 5.3 2008 8 auto… r 14 20 r suv 7 toyota camry 2.2 1999 4 manu… f 21 29 r mids… 8 toyota camry sol… 2.2 1999 4 auto… f 21 27 r comp… 9 dodge caravan 2… 2.4 1999 4 auto… f 18 24 r mini… 10 honda civic 1.6 1999 4 manu… f 28 33 r subc… # … with 28 more rows top_n() 행(row, case, observation) 조작 동사: 선택한 변수를 기준으로 상위 n 개의 데이터(행)만 추출 # mpg 데이터에서 시내 연비가 높은 데이터 5개 추출 mpg %&gt;% top_n(5, cty) %&gt;% arrange(desc(cty)) distinct() 행(row, case, observation) 조작 동사: 선택한 변수를 기준으로 중복 없는 유일한(unique)한 행 추출 시 사용 R base 패키지의 unique() 또는 unqiue.data.frame()과 유사하게 작동하지만 처리 속도 면에서 뛰어남 # mpg 데이터에서 중복데이터 제거 (모든 열 기준) mpg_uniq &lt;- mpg %&gt;% distinct() mpg_uniq %&gt;% print # A tibble: 225 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… 3 audi a4 2 2008 4 manu… f 20 31 p comp… 4 audi a4 2 2008 4 auto… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… # … with 215 more rows # model을 기준으로 중복 데이터 제거 mpg_uniq2 &lt;- mpg %&gt;% distinct(model, .keep_all = TRUE) %&gt;% arrange(model) mpg_uniq2 %&gt;% head(6) %&gt;% print # A tibble: 6 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 toyota 4runner 4wd 2.7 1999 4 manu… 4 15 20 r suv 2 audi a4 1.8 1999 4 auto… f 18 29 p comp… 3 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… 4 audi a6 quattro 2.8 1999 6 auto… 4 15 24 p mids… 5 nissan altima 2.4 1999 4 manu… f 21 29 r comp… 6 chevrolet c1500 subu… 5.3 2008 8 auto… r 14 20 r suv # 위 그룹별 slice(1) 예제와 비교 identical(slice_mpg_grp %&gt;% ungroup, mpg_uniq2) [1] TRUE sample_n()/sample_frac() 행(row, case, observation) 조작 동사: 데이터의 행을 랜덤하게 추출하는 함수 sample_(n): 전체 \\(N\\) 행에서 \\(n\\) 행을 랜덤하게 추출 sample_frac(p): 전체 \\(N\\) 행에서 비율 \\(p\\) (\\(0\\leq p \\leq1\\)) 만큼 추출 # 전체 234개 행에서 3개 행을 랜덤하게 추출 mpg %&gt;% sample_n(3) # 전체 234개 행의 5%에 해당하는 행을 랜덤하게 추출 mpg %&gt;% sample_frac(0.05) rename() 열(변수) 조작 동사: 변수의 이름을 변경하는 함수 rename(new_variable_name = old_variable_name) 형태로 변경 # 변수명 변셩 ## R 기본 문법으로 변수명 변경 varn_mpg &lt;- names(mpg) # 원 변수명 저장 names(mpg)[5] &lt;- &quot;cylinder&quot; # cyl을 cylinder로 변셩 names(mpg) &lt;- varn_mpg # ## Tidyverse 문법: rename() 사용 mpg %&gt;% rename(cylinder = cyl) %&gt;% head %&gt;% print # A tibble: 6 × 11 manufacturer model displ year cylinder trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p comp… 2 audi a4 1.8 1999 4 manual(… f 21 29 p comp… 3 audi a4 2 2008 4 manual(… f 20 31 p comp… 4 audi a4 2 2008 4 auto(av) f 21 30 p comp… 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p comp… 6 audi a4 2.8 1999 6 manual(… f 18 26 p comp… ## cty를 city_mpg, hwy를 hw_mpg로 변경 mpg %&gt;% rename(city_mpg = cty, hw_mpg = hwy) %&gt;% print # A tibble: 234 × 11 manufacturer model displ year cyl trans drv city_mpg hw_mpg fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… 3 audi a4 2 2008 4 manu… f 20 31 p comp… 4 audi a4 2 2008 4 auto… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… 8 audi a4 qu… 1.8 1999 4 manu… 4 18 26 p comp… 9 audi a4 qu… 1.8 1999 4 auto… 4 16 25 p comp… 10 audi a4 qu… 2 2008 4 manu… 4 20 28 p comp… # … with 224 more rows Count 관련 동사(함수) 데이터셋의 행 개수를 집계하는 함수들로 데이터 요약 시 유용하게 사용 tally() 총계, 행의 개수를 반환하는 함수13 데이터 프레임(티블) 객체 반환 # 전체 행 개수 (nrow(data))와 유사 mpg %&gt;% tally %&gt;% print # A tibble: 1 × 1 n &lt;int&gt; 1 234 # 제조사, 년도별 데이터 개수 mpg %&gt;% group_by(manufacturer, year) %&gt;% tally %&gt;% ungroup %&gt;% print # A tibble: 30 × 3 manufacturer year n &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 audi 1999 9 2 audi 2008 9 3 chevrolet 1999 7 4 chevrolet 2008 12 5 dodge 1999 16 6 dodge 2008 21 7 ford 1999 15 8 ford 2008 10 9 honda 1999 5 10 honda 2008 4 # … with 20 more rows count() tally() 함수와 유사하나 개수 집계 전 group_by()와 집계 후 ungroup()을 실행 # 제조사, 년도별 데이터 개수: tally() 예시와 비교 mpg %&gt;% count(manufacturer, year) %&gt;% print # A tibble: 30 × 3 manufacturer year n &lt;chr&gt; &lt;int&gt; &lt;int&gt; 1 audi 1999 9 2 audi 2008 9 3 chevrolet 1999 7 4 chevrolet 2008 12 5 dodge 1999 16 6 dodge 2008 21 7 ford 1999 15 8 ford 2008 10 9 honda 1999 5 10 honda 2008 4 # … with 20 more rows n() 위에서 소개한 함수와 유사하게 행 개수를 반환하지만, 기본 동사(summarise(), mutate(), filter()) 내에서만 사용 # 제조사, 년도에 따른 배기량, 시내연비의 평균 계산(그룹 별 n 포함) mpg %&gt;% group_by(manufacturer, year) %&gt;% summarise( N = n(), mean_displ = mean(displ), mean_hwy = mean(cty)) %&gt;% print `summarise()` has grouped output by &#39;manufacturer&#39;. You can override using the `.groups` argument. # A tibble: 30 × 5 # Groups: manufacturer [15] manufacturer year N mean_displ mean_hwy &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 audi 1999 9 2.36 17.1 2 audi 2008 9 2.73 18.1 3 chevrolet 1999 7 4.97 15.1 4 chevrolet 2008 12 5.12 14.9 5 dodge 1999 16 4.32 13.4 6 dodge 2008 21 4.42 13.0 7 ford 1999 15 4.45 13.9 8 ford 2008 10 4.66 14.1 9 honda 1999 5 1.6 24.8 10 honda 2008 4 1.85 24 # … with 20 more rows # mutate, filter에서 사용하는 경우 mpg %&gt;% group_by(manufacturer, year) %&gt;% mutate(N = n()) %&gt;% filter(n() &lt; 4) %&gt;% print # A tibble: 18 × 12 # Groups: manufacturer, year [9] manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 jeep grand che… 4 1999 6 auto… 4 15 20 r suv 2 jeep grand che… 4.7 1999 8 auto… 4 14 17 r suv 3 land rover range rov… 4 1999 8 auto… 4 11 15 p suv 4 land rover range rov… 4.2 2008 8 auto… 4 12 18 r suv 5 land rover range rov… 4.4 2008 8 auto… 4 12 18 r suv 6 land rover range rov… 4.6 1999 8 auto… 4 11 15 p suv 7 lincoln navigator… 5.4 1999 8 auto… r 11 17 r suv 8 lincoln navigator… 5.4 1999 8 auto… r 11 16 p suv 9 lincoln navigator… 5.4 2008 8 auto… r 12 18 r suv 10 mercury mountaine… 4 1999 6 auto… 4 14 17 r suv 11 mercury mountaine… 4 2008 6 auto… 4 13 19 r suv 12 mercury mountaine… 4.6 2008 8 auto… 4 13 19 r suv 13 mercury mountaine… 5 1999 8 auto… 4 13 17 r suv 14 pontiac grand prix 3.1 1999 6 auto… f 18 26 r mids… 15 pontiac grand prix 3.8 1999 6 auto… f 16 26 p mids… 16 pontiac grand prix 3.8 1999 6 auto… f 17 27 r mids… 17 pontiac grand prix 3.8 2008 6 auto… f 18 28 r mids… 18 pontiac grand prix 5.3 2008 8 auto… f 16 25 p mids… # … with 1 more variable: N &lt;int&gt; 11.3.10 부가 기능 위에서 소개한 dplyr 패키지의 기본 동사 함수를 조금 더 효율적으로 사용(예: 특정 조건을 만족하는 두 개 이상의 변수에 함수 적용)하기 위한 범위 지정 함수로서 아래와 같은 부사(adverb), 접속사 또는 전치사가 본 동사 뒤에 붙음 *_all: 모든 변수에 적용 *_at: vars() 함수를 이용해 선택한 변수에 적용 *_if: 조건식 또는 조건 함수로 선택한 변수에 적용 여기서 * = {filter, arrange, select, rename, mutate, transmute, summarise, group_by} 적용할 변수들은 대명사(pronoun)로 지칭되며, .로 나타냄 vars()는 *_at 계열 함수 내에서 변수를 선택해주는 함수로 select() 함수와 동일한 문법으로 사용 가능(단독으로는 사용하지 않음) filter_all(), filter_at(), filter_if() filter_all():all_vars() 또는 any_vars() 라는 조건 함수와 같이 사용되며, 해당 함수 내에 변수는 대명사 .로 나타냄 filter_at(): 변수 선택 지시자 vars()와 vars()에서 선택한 변수에 적용할 조건식 또는 조건 함수를 인수로 받음. 조건식 설정 시 vars() 에 포함된 변수들은 대명사 . 으로 표시 filter_if(): 조건을 만족하는 변수들을 선택한 후, 선택한 변수들 중 모두 또는 하나라도 입력한 조건을 만족하는 행 추출 # mtcars 데이터셋 사용 ## filter_all() ### 모든 변수들이 100 보다 큰 케이스 추출 mtcars %&gt;% filter_all(all_vars(. &gt; 100)) %&gt;% print [1] mpg cyl disp hp drat wt qsec vs am gear carb &lt;0 행&gt; &lt;또는 row.names의 길이가 0입니다&gt; ### 모든 변수들 중 하나라도 300 보다 큰 케이스 추출 mtcars %&gt;% filter_all(any_vars(. &gt; 300)) %&gt;% print mpg cyl disp hp drat wt qsec vs am gear carb Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Duster 360 14.3 8 360 245 3.21 3.570 15.84 0 0 3 4 Cadillac Fleetwood 10.4 8 472 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460 215 3.00 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 Dodge Challenger 15.5 8 318 150 2.76 3.520 16.87 0 0 3 2 AMC Javelin 15.2 8 304 150 3.15 3.435 17.30 0 0 3 2 Camaro Z28 13.3 8 350 245 3.73 3.840 15.41 0 0 3 4 Pontiac Firebird 19.2 8 400 175 3.08 3.845 17.05 0 0 3 2 Ford Pantera L 15.8 8 351 264 4.22 3.170 14.50 0 1 5 4 Maserati Bora 15.0 8 301 335 3.54 3.570 14.60 0 1 5 8 ## filter_at() ### 기어 개수(gear)와 기화기 개수(carb)가 짝수인 케이스만 추출 mtcars %&gt;% filter_at(vars(gear, carb), ~ . %% 2 == 0) %&gt;% # 대명사 앞에 ~ 표시를 꼭 사용해야 함 print mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 ## filter_if() ### 내림한 값이 원래 값과 같은 변수들 모두 0이 아닌 케이스 추출 mtcars %&gt;% filter_if(~ all(floor(.) == .), all_vars(. != 0)) %&gt;% # filter_if(~ all(floor(.) == .), # ~ . != 0) %&gt;% print mpg cyl disp hp drat wt qsec vs am gear carb Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 select_all(), select_at(), select_if() 변수 선택과 변수명 변경을 동시에 수행 # select_all() 예시 ## mpg 데이터셋의 모든 변수명을 대문자로 변경 mpg %&gt;% select_all(~toupper(.)) %&gt;% print # A tibble: 234 × 11 MANUFACTURER MODEL DISPL YEAR CYL TRANS DRV CTY HWY FL CLASS &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… 3 audi a4 2 2008 4 manu… f 20 31 p comp… 4 audi a4 2 2008 4 auto… f 21 30 p comp… 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… # … with 224 more rows # select_if() 예시 ## 문자형 변수를 선택하고 선택한 변수의 이름을 대문자로 변경 mpg %&gt;% select_if(~ is.character(.), ~ toupper(.)) %&gt;% print # A tibble: 234 × 6 MANUFACTURER MODEL TRANS DRV FL CLASS &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 auto(l5) f p compact 2 audi a4 manual(m5) f p compact 3 audi a4 manual(m6) f p compact 4 audi a4 auto(av) f p compact 5 audi a4 auto(l5) f p compact 6 audi a4 manual(m5) f p compact 7 audi a4 auto(av) f p compact 8 audi a4 quattro manual(m5) 4 p compact 9 audi a4 quattro auto(l5) 4 p compact 10 audi a4 quattro manual(m6) 4 p compact # … with 224 more rows # select_at() 예시 ## model에서 cty 까지 변수를 선택하고 선택한 변수명을 대문자로 변경 mpg %&gt;% select_at(vars(model:cty), ~ toupper(.)) %&gt;% print # A tibble: 234 × 7 MODEL DISPL YEAR CYL TRANS DRV CTY &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 a4 1.8 1999 4 auto(l5) f 18 2 a4 1.8 1999 4 manual(m5) f 21 3 a4 2 2008 4 manual(m6) f 20 4 a4 2 2008 4 auto(av) f 21 5 a4 2.8 1999 6 auto(l5) f 16 6 a4 2.8 1999 6 manual(m5) f 18 7 a4 3.1 2008 6 auto(av) f 18 8 a4 quattro 1.8 1999 4 manual(m5) 4 18 9 a4 quattro 1.8 1999 4 auto(l5) 4 16 10 a4 quattro 2 2008 4 manual(m6) 4 20 # … with 224 more rows mutate_all(), mutate_at(), mutate_if() 실제 데이터 전처리 시 가장 많이 사용 mutate_all(): 모든 변수에 적용(모든 데이터가 동일한 데이터 타입인 경우 유용) mutate_at(): 선택한 변수에 적용. vars() 함수로 선택 mutate_if(): 특정 조건을 만족하는 변수에 적용 # mutate_all() 예시 ## 문자형 변수를 선택 후 모든 변수를 요인형으로 변환 mpg %&gt;% select_if(~is.character(.)) %&gt;% mutate_all(~factor(.)) %&gt;% head %&gt;% print # A tibble: 6 × 6 manufacturer model trans drv fl class &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; 1 audi a4 auto(l5) f p compact 2 audi a4 manual(m5) f p compact 3 audi a4 manual(m6) f p compact 4 audi a4 auto(av) f p compact 5 audi a4 auto(l5) f p compact 6 audi a4 manual(m5) f p compact # mutate_at() 예시 ## cty, hwy 단위를 km/l로 변경 mpg %&gt;% mutate_at(vars(cty, hwy), ~ . * kpl) %&gt;% # 원래 변수를 변경 head %&gt;% print # A tibble: 6 × 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto(l5) f 7.65 12.3 p compa… 2 audi a4 1.8 1999 4 manual(m5) f 8.92 12.3 p compa… 3 audi a4 2 2008 4 manual(m6) f 8.50 13.2 p compa… 4 audi a4 2 2008 4 auto(av) f 8.92 12.7 p compa… 5 audi a4 2.8 1999 6 auto(l5) f 6.80 11.0 p compa… 6 audi a4 2.8 1999 6 manual(m5) f 7.65 11.0 p compa… ## &quot;m&quot;으로 시작하거나 &quot;s&quot;로 끝나는 변수 선택 후 요인형으로 변환 mpg %&gt;% mutate_at(vars(starts_with(&quot;m&quot;), ends_with(&quot;s&quot;)), ~ factor(.)) %&gt;% summary manufacturer model displ year dodge :37 caravan 2wd : 11 Min. :1.600 Min. :1999 toyota :34 ram 1500 pickup 4wd: 10 1st Qu.:2.400 1st Qu.:1999 volkswagen:27 civic : 9 Median :3.300 Median :2004 ford :25 dakota pickup 4wd : 9 Mean :3.472 Mean :2004 chevrolet :19 jetta : 9 3rd Qu.:4.600 3rd Qu.:2008 audi :18 mustang : 9 Max. :7.000 Max. :2008 (Other) :74 (Other) :177 cyl trans drv cty Min. :4.000 auto(l4) :83 Length:234 Min. : 9.00 1st Qu.:4.000 manual(m5):58 Class :character 1st Qu.:14.00 Median :6.000 auto(l5) :39 Mode :character Median :17.00 Mean :5.889 manual(m6):19 Mean :16.86 3rd Qu.:8.000 auto(s6) :16 3rd Qu.:19.00 Max. :8.000 auto(l6) : 6 Max. :35.00 (Other) :13 hwy fl class Min. :12.00 Length:234 2seater : 5 1st Qu.:18.00 Class :character compact :47 Median :24.00 Mode :character midsize :41 Mean :23.44 minivan :11 3rd Qu.:27.00 pickup :33 Max. :44.00 subcompact:35 suv :62 # mutate_if() 예시 ## 문자형 변수를 요인형으로 변환 mpg %&gt;% mutate_if(~ is.character(.), ~ factor(.)) %&gt;% summary manufacturer model displ year dodge :37 caravan 2wd : 11 Min. :1.600 Min. :1999 toyota :34 ram 1500 pickup 4wd: 10 1st Qu.:2.400 1st Qu.:1999 volkswagen:27 civic : 9 Median :3.300 Median :2004 ford :25 dakota pickup 4wd : 9 Mean :3.472 Mean :2004 chevrolet :19 jetta : 9 3rd Qu.:4.600 3rd Qu.:2008 audi :18 mustang : 9 Max. :7.000 Max. :2008 (Other) :74 (Other) :177 cyl trans drv cty hwy Min. :4.000 auto(l4) :83 4:103 Min. : 9.00 Min. :12.00 1st Qu.:4.000 manual(m5):58 f:106 1st Qu.:14.00 1st Qu.:18.00 Median :6.000 auto(l5) :39 r: 25 Median :17.00 Median :24.00 Mean :5.889 manual(m6):19 Mean :16.86 Mean :23.44 3rd Qu.:8.000 auto(s6) :16 3rd Qu.:19.00 3rd Qu.:27.00 Max. :8.000 auto(l6) : 6 Max. :35.00 Max. :44.00 (Other) :13 fl class c: 1 2seater : 5 d: 5 compact :47 e: 8 midsize :41 p: 52 minivan :11 r:168 pickup :33 subcompact:35 suv :62 summarise_all(), summarise_at(), summarise_if() 사용 방법은 mutate_all, mutate_at, mutate_all 과 동일 다중 변수 요약 시 코드를 효율적으로 작성할 수 있음. # summary_all() 예시 ## 모든 변수의 최솟값과 최댓값 요약 ## 문자형 변수는 알파벳 순으로 최솟값과 최댓값 반환 ## 복수의 함수를 적용 시 list()함수 사용 mpg %&gt;% summarise_all(list(min = ~ min(.), max = ~ max(.))) %&gt;% glimpse Rows: 1 Columns: 22 $ manufacturer_min &lt;chr&gt; &quot;audi&quot; $ model_min &lt;chr&gt; &quot;4runner 4wd&quot; $ displ_min &lt;dbl&gt; 1.6 $ year_min &lt;int&gt; 1999 $ cyl_min &lt;int&gt; 4 $ trans_min &lt;chr&gt; &quot;auto(av)&quot; $ drv_min &lt;chr&gt; &quot;4&quot; $ cty_min &lt;int&gt; 9 $ hwy_min &lt;int&gt; 12 $ fl_min &lt;chr&gt; &quot;c&quot; $ class_min &lt;chr&gt; &quot;2seater&quot; $ manufacturer_max &lt;chr&gt; &quot;volkswagen&quot; $ model_max &lt;chr&gt; &quot;toyota tacoma 4wd&quot; $ displ_max &lt;dbl&gt; 7 $ year_max &lt;int&gt; 2008 $ cyl_max &lt;int&gt; 8 $ trans_max &lt;chr&gt; &quot;manual(m6)&quot; $ drv_max &lt;chr&gt; &quot;r&quot; $ cty_max &lt;int&gt; 35 $ hwy_max &lt;int&gt; 44 $ fl_max &lt;chr&gt; &quot;r&quot; $ class_max &lt;chr&gt; &quot;suv&quot; # summary_at() 예시 ## dipl, cyl, cty, hwy에 대해 제조사 별 n수와 평균과 표준편차 계산 mpg %&gt;% add_count(manufacturer) %&gt;% # 행 집계 결과를 열 변수로 추가하는 함수 group_by(manufacturer, n) %&gt;% summarise_at(vars(displ, cyl, cty:hwy), list(mean = ~ mean(.), sd = ~ sd(.))) %&gt;% print # A tibble: 15 × 10 # Groups: manufacturer [15] manufacturer n displ_mean cyl_mean cty_mean hwy_mean displ_sd cyl_sd &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 audi 18 2.54 5.22 17.6 26.4 0.673 1.22 2 chevrolet 19 5.06 7.26 15 21.9 1.37 1.37 3 dodge 37 4.38 7.08 13.1 17.9 0.868 1.12 4 ford 25 4.54 7.2 14 19.4 0.541 1 5 honda 9 1.71 4 24.4 32.6 0.145 0 6 hyundai 14 2.43 4.86 18.6 26.9 0.365 1.03 7 jeep 8 4.58 7.25 13.5 17.6 1.02 1.04 8 land rover 4 4.3 8 11.5 16.5 0.258 0 9 lincoln 3 5.4 8 11.3 17 0 0 10 mercury 4 4.4 7 13.2 18 0.490 1.15 11 nissan 13 3.27 5.54 18.1 24.6 0.864 1.20 12 pontiac 5 3.96 6.4 17 26.4 0.808 0.894 13 subaru 14 2.46 4 19.3 25.6 0.109 0 14 toyota 34 2.95 5.12 18.5 24.9 0.931 1.32 15 volkswagen 27 2.26 4.59 20.9 29.2 0.443 0.844 # … with 2 more variables: cty_sd &lt;dbl&gt;, hwy_sd &lt;dbl&gt; # summary_if() 예시 ## 1) 문자형 변수이거나 모든 값이 1999보다 크거나 같은 변수이거나 ## 8보다 작거나 같고 정수인 변수를 factor 변환 ## 2) 수치형 변수에 대한 제조사 별 n, 평균, 표준편차를 구한 후 ## 3) 평균 cty (cty_mean) 기준 내림차순으로 정렬 mpg %&gt;% mutate_if(~ is.character(.) | all(. &gt;= 1999) | (all(. &lt;= 8) &amp; is.integer(.)), ~ factor(.)) %&gt;% add_count(manufacturer) %&gt;% group_by(manufacturer, n) %&gt;% summarise_if(~ is.numeric(.), list(mean = ~ mean(.), sd = ~ sd(.))) %&gt;% arrange(desc(cty_mean)) %&gt;% print # A tibble: 15 × 8 # Groups: manufacturer [15] manufacturer n displ_mean cty_mean hwy_mean displ_sd cty_sd hwy_sd &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 honda 9 1.71 24.4 32.6 0.145 1.94 2.55 2 volkswagen 27 2.26 20.9 29.2 0.443 4.56 5.32 3 subaru 14 2.46 19.3 25.6 0.109 0.914 1.16 4 hyundai 14 2.43 18.6 26.9 0.365 1.50 2.18 5 toyota 34 2.95 18.5 24.9 0.931 4.05 6.17 6 nissan 13 3.27 18.1 24.6 0.864 3.43 5.09 7 audi 18 2.54 17.6 26.4 0.673 1.97 2.18 8 pontiac 5 3.96 17 26.4 0.808 1 1.14 9 chevrolet 19 5.06 15 21.9 1.37 2.92 5.11 10 ford 25 4.54 14 19.4 0.541 1.91 3.33 11 jeep 8 4.58 13.5 17.6 1.02 2.51 3.25 12 mercury 4 4.4 13.2 18 0.490 0.5 1.15 13 dodge 37 4.38 13.1 17.9 0.868 2.49 3.57 14 land rover 4 4.3 11.5 16.5 0.258 0.577 1.73 15 lincoln 3 5.4 11.3 17 0 0.577 1 11.3.11 데이터 연결 분석용 데이터를 만들기 위해 연관된 복수의 데이터 테이블을 결합하는 작업이 필수임 서로 연결 또는 연관된 데이터를 관계형 데이터(relational data)라고 칭함 관계는 항상 한 쌍의 데이터 테이블 간의 관계로 정의 관계형 데이터 작업을 위해 설계된 3 가지 “동사” 유형 Mutating join: 두 데이터 프레임 결합 시 두 테이블 간 행이 일치하는 경우 첫 번째 테이블에 새로운 변수 추가 Filtering join: 다른 테이블의 관측치와 일치 여부에 따라 데이터 테이블의 행을 필터링 Set operation: 데이터 셋의 관측치를 집합 연산으로 조합 본 강의에서는 mutating join 에 대해서만 다룸 R base 패키지에서 제공하는 merge() 함수로 mutating join에 해당하는 두 데이터 간 병합이 가능하지만 앞으로 배울 *_join()로도 동일한 기능을 수행할 수 있고, 다음과 같은 장점을 가짐 행 순서를 보존 merge()에 비해 코드가 직관적이고 빠름 예제 데이터: nycflights13 (2013년 미국 New York에서 출발하는 항공기 이착륙 기록 데이터) flights, airlines, airports, planes, weather 총 5 개의 데이터 프레임으로 구성되어 있으며, 데이터 구조와 코드북은 다음과 같음 # install.packages(&quot;nycflights13&quot;) require(nycflights13) 필요한 패키지를 로딩중입니다: nycflights13 flights: 336,776 건의 비행에 대한 기록과 19개의 변수로 구성되어 있는 데이터셋 # A tibble: 336,776 × 19 year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Table 11.3: flights 데이터셋 코드북 변수 설명 year, month, day 출발년도, 월, 일 dep_time, arr_time 실제 출발-도착 시간(현지시각) sched_dep_time, sched_arr_time 예정 출발-도착 시간(현지시각) dep_delay, arr_delay 출발 및 도착 지연 시간(분, min) carrier 항공코드 약어(두개 문자) tailnum 비행기 일련 번호 flight 항공편 번호 origin, dest 최초 출발지, 목적지 air_time 비행 시간(분, min) distance 비행 거리(마일, mile) hour, minutes 예정 출발 시각(시, 분)으로 분리 time_hour POSIXct 포맷으로로 기록된 예정 항공편 날짜 및 시간 airlines: 항공사 이름 및 약어 정보로 구성 # A tibble: 16 × 2 carrier name &lt;chr&gt; &lt;chr&gt; 1 9E Endeavor Air Inc. 2 AA American Airlines Inc. 3 AS Alaska Airlines Inc. 4 B6 JetBlue Airways 5 DL Delta Air Lines Inc. 6 EV ExpressJet Airlines Inc. 7 F9 Frontier Airlines Inc. 8 FL AirTran Airways Corporation 9 HA Hawaiian Airlines Inc. 10 MQ Envoy Air 11 OO SkyWest Airlines Inc. 12 UA United Air Lines Inc. 13 US US Airways Inc. 14 VX Virgin America 15 WN Southwest Airlines Co. 16 YV Mesa Airlines Inc. airports: 각 공항에 대한 정보를 포함한 데이터셋이고 faa는 공항 코드 # A tibble: 1,458 × 8 faa name lat lon alt tz dst tzone &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 04G Lansdowne Airport 41.1 -80.6 1044 -5 A America/… 2 06A Moton Field Municipal Airport 32.5 -85.7 264 -6 A America/… 3 06C Schaumburg Regional 42.0 -88.1 801 -6 A America/… 4 06N Randall Airport 41.4 -74.4 523 -5 A America/… 5 09J Jekyll Island Airport 31.1 -81.4 11 -5 A America/… 6 0A9 Elizabethton Municipal Airport 36.4 -82.2 1593 -5 A America/… 7 0G6 Williams County Airport 41.5 -84.5 730 -5 A America/… 8 0G7 Finger Lakes Regional Airport 42.9 -76.8 492 -5 A America/… 9 0P2 Shoestring Aviation Airfield 39.8 -76.6 1000 -5 U America/… 10 0S9 Jefferson County Intl 48.1 -123. 108 -8 A America/… # … with 1,448 more rows Table 11.4: airports 데이터셋 코드북 변수 설명 faa FAA 공항 코드 name 공항 명칭 lat 위도 lon 경도 alt 고도 tz 타임존 차이(GMT로부터) dst 일광 절약 시간제(섬머타임): A=미국 표준 DST, U=unknown, N=no DST tzone IANA 타임존 planes: 항공기 정보(제조사, 일련번호, 유형 등)에 대한 정보를 포함한 데이터셋 # A tibble: 3,322 × 9 tailnum year type manufacturer model engines seats speed engine &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 N10156 2004 Fixed wing multi… EMBRAER EMB-… 2 55 NA Turbo… 2 N102UW 1998 Fixed wing multi… AIRBUS INDU… A320… 2 182 NA Turbo… 3 N103US 1999 Fixed wing multi… AIRBUS INDU… A320… 2 182 NA Turbo… 4 N104UW 1999 Fixed wing multi… AIRBUS INDU… A320… 2 182 NA Turbo… 5 N10575 2002 Fixed wing multi… EMBRAER EMB-… 2 55 NA Turbo… 6 N105UW 1999 Fixed wing multi… AIRBUS INDU… A320… 2 182 NA Turbo… 7 N107US 1999 Fixed wing multi… AIRBUS INDU… A320… 2 182 NA Turbo… 8 N108UW 1999 Fixed wing multi… AIRBUS INDU… A320… 2 182 NA Turbo… 9 N109UW 1999 Fixed wing multi… AIRBUS INDU… A320… 2 182 NA Turbo… 10 N110UW 1999 Fixed wing multi… AIRBUS INDU… A320… 2 182 NA Turbo… # … with 3,312 more rows Table 11.5: planes 데이터셋 코드북 변수 설명 tailnum 항공기 일련번호 year 제조년도 type 항공기 유형 manufacturer 제조사 model 모델명 engines 엔진 개수 seats 좌석 수 speed 속력 engine 엔진 유형 weather: 뉴욕시 각 공항 별 날씨 정보 # A tibble: 26,115 × 15 origin year month day hour temp dewp humid wind_dir wind_speed &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 EWR 2013 1 1 1 39.0 26.1 59.4 270 10.4 2 EWR 2013 1 1 2 39.0 27.0 61.6 250 8.06 3 EWR 2013 1 1 3 39.0 28.0 64.4 240 11.5 4 EWR 2013 1 1 4 39.9 28.0 62.2 250 12.7 5 EWR 2013 1 1 5 39.0 28.0 64.4 260 12.7 6 EWR 2013 1 1 6 37.9 28.0 67.2 240 11.5 7 EWR 2013 1 1 7 39.0 28.0 64.4 240 15.0 8 EWR 2013 1 1 8 39.9 28.0 62.2 250 10.4 9 EWR 2013 1 1 9 39.9 28.0 62.2 260 15.0 10 EWR 2013 1 1 10 41 28.0 59.6 260 13.8 # … with 26,105 more rows, and 5 more variables: wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, # pressure &lt;dbl&gt;, visib &lt;dbl&gt;, time_hour &lt;dttm&gt; Table 11.6: weather 데이터셋 코드북 변수 설명 origin 기상관측소 year, month, day, hour 년도, 월, 일, 시간 temp, dewp 기온, 이슬점 (F) humid 습도 wind_dir, wind_speed, wind_gust 바람방향(degree), 풍속 및 돌풍속도(mph) precip 강수량(inch) pressure 기압(mbar) visib 가시거리(mile) time_hour POSIXct 포맷 일자 및 시간 열거한 각 테이블은 한 개 또는 복수의 변수로 연결 가능 flights \\(\\longleftrightarrow\\) planes (by tailnum) flights \\(\\longleftrightarrow\\) airlines (by carrier) flights \\(\\longleftrightarrow\\) airports (by origin, dest) flights \\(\\longleftrightarrow\\) weather (by origin, year, month, day, hour) Figure 11.7: NYC flight 2013 데이터 관계도(https://r4ds.had.co.nz/ 에서 발췌) 각 쌍의 데이터를 연결하는데 사용한 변수를 키(key)라고 지칭 기준 테이블(여기서는 flights 데이터셋)의 키 \\(\\rightarrow\\) 기본키(primary key) 병합할 테이블의 키 \\(\\rightarrow\\) 외래키(foreign key) 다수의 변수를 이용한 기본키 및 외래키 생성 가능 inner_join 두 데이터셋 모두에 존재하는 키 변수가 일치하는 행을 기준으로 병합 x &lt;- tribble( ~key, ~val_x, 1, &quot;x1&quot;, 2, &quot;x2&quot;, 3, &quot;x3&quot; ) y &lt;- tribble( ~key, ~val_y, 1, &quot;y1&quot;, 2, &quot;y2&quot;, 4, &quot;y3&quot; ) inner_join(x, y, by = &quot;key&quot;) %&gt;% print # A tibble: 2 × 3 key val_x val_y &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1 x1 y1 2 2 x2 y2 left_join() 두 데이터셋 관계 중 왼쪽(x) 데이터셋의 행은 모두 보존 left_join(x, y, by = &quot;key&quot;) %&gt;% print # A tibble: 3 × 3 key val_x val_y &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1 x1 y1 2 2 x2 y2 3 3 x3 &lt;NA&gt; right_join() 두 데이터셋 관계 중 오른쪽(y) 데이터셋의 행은 모두 보존 right_join(x, y, by = &quot;key&quot;) %&gt;% print # A tibble: 3 × 3 key val_x val_y &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1 x1 y1 2 2 x2 y2 3 4 &lt;NA&gt; y3 full_join 두 데이터셋의 관측치 모두를 보존 full_join(x, y, by = &quot;key&quot;) %&gt;% print # A tibble: 4 × 3 key val_x val_y &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 1 x1 y1 2 2 x2 y2 3 3 x3 &lt;NA&gt; 4 4 &lt;NA&gt; y3 11.3.11.1 NYC flights 2013 데이터 join 예시 # flights 데이터 간소화(일부 열만 추출) flights2 &lt;- flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) # flights2 와 airlines 병합 flights2 %&gt;% left_join(airlines, by = &quot;carrier&quot;) %&gt;% print # A tibble: 336,776 × 9 year month day hour origin dest tailnum carrier name &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 2013 1 1 5 EWR IAH N14228 UA United Air Lines Inc. 2 2013 1 1 5 LGA IAH N24211 UA United Air Lines Inc. 3 2013 1 1 5 JFK MIA N619AA AA American Airlines Inc. 4 2013 1 1 5 JFK BQN N804JB B6 JetBlue Airways 5 2013 1 1 6 LGA ATL N668DN DL Delta Air Lines Inc. 6 2013 1 1 5 EWR ORD N39463 UA United Air Lines Inc. 7 2013 1 1 6 EWR FLL N516JB B6 JetBlue Airways 8 2013 1 1 6 LGA IAD N829AS EV ExpressJet Airlines Inc. 9 2013 1 1 6 JFK MCO N593JB B6 JetBlue Airways 10 2013 1 1 6 LGA ORD N3ALAA AA American Airlines Inc. # … with 336,766 more rows # flights2와 airline, airports 병합 ## airports 데이터 간소화 airports2 &lt;- airports %&gt;% select(faa:name, airport_name = name) %&gt;% print # A tibble: 1,458 × 2 faa airport_name &lt;chr&gt; &lt;chr&gt; 1 04G Lansdowne Airport 2 06A Moton Field Municipal Airport 3 06C Schaumburg Regional 4 06N Randall Airport 5 09J Jekyll Island Airport 6 0A9 Elizabethton Municipal Airport 7 0G6 Williams County Airport 8 0G7 Finger Lakes Regional Airport 9 0P2 Shoestring Aviation Airfield 10 0S9 Jefferson County Intl # … with 1,448 more rows flights2 %&gt;% left_join(airlines, by = &quot;carrier&quot;) %&gt;% left_join(airports2, by = c(&quot;origin&quot; = &quot;faa&quot;)) %&gt;% print # A tibble: 336,776 × 10 year month day hour origin dest tailnum carrier name airport_name &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 2013 1 1 5 EWR IAH N14228 UA United Air… Newark Libe… 2 2013 1 1 5 LGA IAH N24211 UA United Air… La Guardia 3 2013 1 1 5 JFK MIA N619AA AA American A… John F Kenn… 4 2013 1 1 5 JFK BQN N804JB B6 JetBlue Ai… John F Kenn… 5 2013 1 1 6 LGA ATL N668DN DL Delta Air … La Guardia 6 2013 1 1 5 EWR ORD N39463 UA United Air… Newark Libe… 7 2013 1 1 6 EWR FLL N516JB B6 JetBlue Ai… Newark Libe… 8 2013 1 1 6 LGA IAD N829AS EV ExpressJet… La Guardia 9 2013 1 1 6 JFK MCO N593JB B6 JetBlue Ai… John F Kenn… 10 2013 1 1 6 LGA ORD N3ALAA AA American A… La Guardia # … with 336,766 more rows # flights2와 airline, airports, planes 병합 planes2 &lt;- planes %&gt;% select(tailnum, model) flights2 %&gt;% left_join(airlines, by = &quot;carrier&quot;) %&gt;% left_join(airports2, by = c(&quot;origin&quot; = &quot;faa&quot;)) %&gt;% left_join(planes2, by = &quot;tailnum&quot;) %&gt;% print # A tibble: 336,776 × 11 year month day hour origin dest tailnum carrier name airport_name model &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 2013 1 1 5 EWR IAH N14228 UA Unit… Newark Libe… 737-… 2 2013 1 1 5 LGA IAH N24211 UA Unit… La Guardia 737-… 3 2013 1 1 5 JFK MIA N619AA AA Amer… John F Kenn… 757-… 4 2013 1 1 5 JFK BQN N804JB B6 JetB… John F Kenn… A320… 5 2013 1 1 6 LGA ATL N668DN DL Delt… La Guardia 757-… 6 2013 1 1 5 EWR ORD N39463 UA Unit… Newark Libe… 737-… 7 2013 1 1 6 EWR FLL N516JB B6 JetB… Newark Libe… A320… 8 2013 1 1 6 LGA IAD N829AS EV Expr… La Guardia CL-6… 9 2013 1 1 6 JFK MCO N593JB B6 JetB… John F Kenn… A320… 10 2013 1 1 6 LGA ORD N3ALAA AA Amer… La Guardia &lt;NA&gt; # … with 336,766 more rows # flights2와 airline, airports2, planes2, weather2 병합 ## weather 데이터 간소화 weather2 &lt;- weather %&gt;% select(origin:temp, wind_speed) flights2 %&gt;% left_join(airlines, by = &quot;carrier&quot;) %&gt;% left_join(airports2, by = c(&quot;origin&quot; = &quot;faa&quot;)) %&gt;% left_join(planes2, by = &quot;tailnum&quot;) %&gt;% left_join(weather2, by = c(&quot;origin&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;)) %&gt;% glimpse Rows: 336,776 Columns: 13 $ year &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 201… $ month &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … $ day &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … $ hour &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6, … $ origin &lt;chr&gt; &quot;EWR&quot;, &quot;LGA&quot;, &quot;JFK&quot;, &quot;JFK&quot;, &quot;LGA&quot;, &quot;EWR&quot;, &quot;EWR&quot;, &quot;LGA&quot;, &quot;… $ dest &lt;chr&gt; &quot;IAH&quot;, &quot;IAH&quot;, &quot;MIA&quot;, &quot;BQN&quot;, &quot;ATL&quot;, &quot;ORD&quot;, &quot;FLL&quot;, &quot;IAD&quot;, &quot;… $ tailnum &lt;chr&gt; &quot;N14228&quot;, &quot;N24211&quot;, &quot;N619AA&quot;, &quot;N804JB&quot;, &quot;N668DN&quot;, &quot;N39463… $ carrier &lt;chr&gt; &quot;UA&quot;, &quot;UA&quot;, &quot;AA&quot;, &quot;B6&quot;, &quot;DL&quot;, &quot;UA&quot;, &quot;B6&quot;, &quot;EV&quot;, &quot;B6&quot;, &quot;AA… $ name &lt;chr&gt; &quot;United Air Lines Inc.&quot;, &quot;United Air Lines Inc.&quot;, &quot;Americ… $ airport_name &lt;chr&gt; &quot;Newark Liberty Intl&quot;, &quot;La Guardia&quot;, &quot;John F Kennedy Intl… $ model &lt;chr&gt; &quot;737-824&quot;, &quot;737-824&quot;, &quot;757-223&quot;, &quot;A320-232&quot;, &quot;757-232&quot;, &quot;… $ temp &lt;dbl&gt; 39.02, 39.92, 39.02, 39.02, 39.92, 39.02, 37.94, 39.92, 3… $ wind_speed &lt;dbl&gt; 12.65858, 14.96014, 14.96014, 14.96014, 16.11092, 12.6585… dplyr *_join() 과 base 패키지의 merge() 비교 Table 11.7: dplyr join 함수와 merge() 함수 비교 dplyr::*_join() base::merge() inner_join(x, y) merge(x, y) left_join(x, y) merge(x, y, all.x = TRUE) right_join(x, y) merge(x, y, all.y = TRUE) full_join(x, y) merge(x, y, all.x = TRUE, all.y = TRUE) 11.3.12 확장 예제: Gapminder 연습 데이터: Gapminder 데이터 활용. 각 대륙에 속한 국가의 인구, 경제, 보건, 교육, 환경, 노동에 대한 년도 별 국가 통계를 제공함. Gapminder는 스웨덴의 비영리 통계 분석 서비스를 제공하는 웹사이트로, UN이 제공하는 데이터를 기반으로 인구 예측, 부의 이동 등에 관한 연구 논문 및 통계정보, 데이터를 공유함 (“Gapminder” 2018). R 패키지 중 gapminder (Bryan 2017)는 1950 ~ 2007 년 까지 5년 단위의 국가별 인구(population), 기대수명(year), 일인당 국민 총소득(gross domestic product per captia, 달러)에 대한 데이터를 제공 하지만, 본 강의에서는 현재 Gapminder 사이트에서 직접 다운로드 받은 가장 최근 데이터를 가지고 dplyr 패키지의 기본 동사를 학습함과 동시에 최종적으로 gapminder 패키지에서 제공하는 데이터와 동일한 형태의 구조를 갖는 데이터를 생성하는 것이 목직임. 해당 데이터는 github 계정에서 다운로드가 가능함. gapminder-exercise.xlsx는 총 4개의 시트로 구성되어 있으며, 각 시트에 대한 설명은 아래와 같음. Table 11.8: gapminder-exercise.xlsx 설명 시트 이름 설명 region 국가별 지역 정보 포함 country_pop 국가별 1800 ~ 2100년 까지 추계 인구수(명) gdpcap 국가별 1800 ~ 2100년 까지 국민 총소득(달러) lifeexp 국가별 1800 ~ 2100년 까지 기대수명(세) Prerequisites gapminder 패키지 설치하기 install.packages(&quot;gapminder&quot;) Gapminder 데이터 핸들링 실습 readxl 패키지 + %&gt;%를 이용해 Gapminder 데이터(gapminder-exercise.xlsx) 불러오기 require(readxl) 필요한 패키지를 로딩중입니다: readxl require(gapminder) 필요한 패키지를 로딩중입니다: gapminder path &lt;- &quot;dataset/gapminder/gapminder-exercise.xlsx&quot; # base R 문법 적용 # sheet_name &lt;- excel_sheets(path) # gapmL &lt;- lapply(sheet_name, function(x) read_excel(path = path, sheet = x)) # names(gapmL) &lt;- sheet_name # pipe 연산자 이용 path %&gt;% excel_sheets %&gt;% set_names %&gt;% map(read_excel, path = path) -&gt; gapmL # 개별 객체에 데이터 저장 command &lt;- paste(names(gapmL), &quot;&lt;-&quot;, paste0(&quot;gapmL$&quot;, names(gapmL))) for (i in 1:length(command)) eval(parse(text = command[i])) # check ls() [1] &quot;내용&quot; &quot;동사(함수)&quot; &quot;변수&quot; [4] &quot;변수명&quot; &quot;변수설명(국문)&quot; &quot;변수설명(영문)&quot; [7] &quot;설명&quot; &quot;시트 이름&quot; &quot;연비&quot; [10] &quot;airports2&quot; &quot;audi&quot; &quot;base::merge()&quot; [13] &quot;by_mpg&quot; &quot;command&quot; &quot;country_pop&quot; [16] &quot;dd&quot; &quot;def.chunk.hook&quot; &quot;dplyr::*_join()&quot; [19] &quot;flights2&quot; &quot;gallon&quot; &quot;gapmL&quot; [22] &quot;gdpcap&quot; &quot;hook_output&quot; &quot;i&quot; [25] &quot;kpl&quot; &quot;lifeexp&quot; &quot;mile&quot; [28] &quot;mpg&quot; &quot;mpg_asc&quot; &quot;mpg_sortb&quot; [31] &quot;mpg_sortt&quot; &quot;mpg_uniq&quot; &quot;mpg_uniq2&quot; [34] &quot;path&quot; &quot;planes2&quot; &quot;pulse&quot; [37] &quot;R base 패키지 함수&quot; &quot;region&quot; &quot;slice_mpg&quot; [40] &quot;slice_mpg_grp&quot; &quot;tab4_01&quot; &quot;tab4_03&quot; [43] &quot;tab4_04&quot; &quot;tab4_05&quot; &quot;tab4_06&quot; [46] &quot;tab4_07&quot; &quot;tab4_08&quot; &quot;titanic&quot; [49] &quot;titanic2&quot; &quot;titanic3&quot; &quot;varn_mpg&quot; [52] &quot;weather2&quot; &quot;x&quot; &quot;y&quot; region %&gt;% print # A tibble: 234 × 3 iso country region &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 AFG Afghanistan Southern Asia 2 ALB Albania Southern Europe 3 DZA Algeria Northern Africa 4 ASM American Samoa Polynesia Oceania 5 AND Andorra Southern Europe 6 AGO Angola Middle Africa 7 AIA Anguilla Caribbean America 8 ATG Antigua and Barbuda Caribbean America 9 ARG Argentina South America 10 ARM Armenia Western Asia # … with 224 more rows country_pop %&gt;% print # A tibble: 59,297 × 4 iso country year population &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 afg Afghanistan 1800 3280000 2 afg Afghanistan 1801 3280000 3 afg Afghanistan 1802 3280000 4 afg Afghanistan 1803 3280000 5 afg Afghanistan 1804 3280000 6 afg Afghanistan 1805 3280000 7 afg Afghanistan 1806 3280000 8 afg Afghanistan 1807 3280000 9 afg Afghanistan 1808 3280000 10 afg Afghanistan 1809 3280000 # … with 59,287 more rows gdpcap %&gt;% print # A tibble: 46,995 × 4 iso_code country year gdp_total &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 afg Afghanistan 1800 1977840000 2 afg Afghanistan 1801 1977840000 3 afg Afghanistan 1802 1977840000 4 afg Afghanistan 1803 1977840000 5 afg Afghanistan 1804 1977840000 6 afg Afghanistan 1805 1977840000 7 afg Afghanistan 1806 1977840000 8 afg Afghanistan 1807 1977840000 9 afg Afghanistan 1808 1977840000 10 afg Afghanistan 1809 1977840000 # … with 46,985 more rows lifeexp %&gt;% print # A tibble: 56,130 × 4 country iso_code year life_expectancy &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Afghanistan afg 1800 28.2 2 Afghanistan afg 1801 28.2 3 Afghanistan afg 1802 28.2 4 Afghanistan afg 1803 28.2 5 Afghanistan afg 1804 28.2 6 Afghanistan afg 1805 28.2 7 Afghanistan afg 1806 28.2 8 Afghanistan afg 1807 28.1 9 Afghanistan afg 1808 28.1 10 Afghanistan afg 1809 28.1 # … with 56,120 more rows country_pop, gdpcap, lifeexp 데이터 셋 결합 gap_unfilter &lt;- country_pop %&gt;% left_join(gdpcap, by = c(&quot;iso&quot; = &quot;iso_code&quot;, &quot;country&quot;, &quot;year&quot;)) %&gt;% left_join(lifeexp, by = c(&quot;iso&quot; = &quot;iso_code&quot;, &quot;country&quot;, &quot;year&quot;)) gap_unfilter %&gt;% print # A tibble: 59,297 × 6 iso country year population gdp_total life_expectancy &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 afg Afghanistan 1800 3280000 1977840000 28.2 2 afg Afghanistan 1801 3280000 1977840000 28.2 3 afg Afghanistan 1802 3280000 1977840000 28.2 4 afg Afghanistan 1803 3280000 1977840000 28.2 5 afg Afghanistan 1804 3280000 1977840000 28.2 6 afg Afghanistan 1805 3280000 1977840000 28.2 7 afg Afghanistan 1806 3280000 1977840000 28.2 8 afg Afghanistan 1807 3280000 1977840000 28.1 9 afg Afghanistan 1808 3280000 1977840000 28.1 10 afg Afghanistan 1809 3280000 1977840000 28.1 # … with 59,287 more rows 인구 수 6만 이상, 1950 ~ 2020년 년도 추출 gap_filter &lt;- gap_unfilter %&gt;% filter(population &gt;= 60000, between(year, 1950, 2020)) gap_filter %&gt;% print # A tibble: 13,159 × 6 iso country year population gdp_total life_expectancy &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 afg Afghanistan 1950 7752117 18543063864 32.5 2 afg Afghanistan 1951 7840151 18988845722 32.9 3 afg Afghanistan 1952 7935996 19538422152 33.6 4 afg Afghanistan 1953 8039684 20645908512 34.3 5 afg Afghanistan 1954 8151316 20997790016 35.0 6 afg Afghanistan 1955 8270992 21330888368 35.7 7 afg Afghanistan 1956 8398873 22206620212 36.4 8 afg Afghanistan 1957 8535157 22131662101 37.1 9 afg Afghanistan 1958 8680097 23297380348 37.9 10 afg Afghanistan 1959 8833947 23895826635 38.6 # … with 13,149 more rows iso 변수 값을 대문자로 변환하고, 1인당 국민소득(gdp_total/population) 변수 gdp_cap 생성 후 gdp_total 제거 gap_filter &lt;- gap_filter %&gt;% mutate(iso = toupper(iso), gdp_cap = gdp_total/population) %&gt;% select(-gdp_total) gap_filter %&gt;% print # A tibble: 13,159 × 6 iso country year population life_expectancy gdp_cap &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 AFG Afghanistan 1950 7752117 32.5 2392 2 AFG Afghanistan 1951 7840151 32.9 2422 3 AFG Afghanistan 1952 7935996 33.6 2462 4 AFG Afghanistan 1953 8039684 34.3 2568 5 AFG Afghanistan 1954 8151316 35.0 2576 6 AFG Afghanistan 1955 8270992 35.7 2579 7 AFG Afghanistan 1956 8398873 36.4 2644 8 AFG Afghanistan 1957 8535157 37.1 2593 9 AFG Afghanistan 1958 8680097 37.9 2684 10 AFG Afghanistan 1959 8833947 38.6 2705 # … with 13,149 more rows region 데이터셋에서 대륙(region) 변수 결합 gap_filter &lt;- gap_filter %&gt;% left_join(region %&gt;% select(-country), by = c(&quot;iso&quot;)) gap_filter %&gt;% print # A tibble: 13,159 × 7 iso country year population life_expectancy gdp_cap region &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 AFG Afghanistan 1950 7752117 32.5 2392 Southern Asia 2 AFG Afghanistan 1951 7840151 32.9 2422 Southern Asia 3 AFG Afghanistan 1952 7935996 33.6 2462 Southern Asia 4 AFG Afghanistan 1953 8039684 34.3 2568 Southern Asia 5 AFG Afghanistan 1954 8151316 35.0 2576 Southern Asia 6 AFG Afghanistan 1955 8270992 35.7 2579 Southern Asia 7 AFG Afghanistan 1956 8398873 36.4 2644 Southern Asia 8 AFG Afghanistan 1957 8535157 37.1 2593 Southern Asia 9 AFG Afghanistan 1958 8680097 37.9 2684 Southern Asia 10 AFG Afghanistan 1959 8833947 38.6 2705 Southern Asia # … with 13,149 more rows 변수 정렬 (iso, country, region, year:gdp_cap 순서로) gap_filter &lt;- gap_filter %&gt;% select(iso:country, region, everything()) 문자형 변수를 요인형으로 변환하고, population을 정수형으로 변환 gap_filter &lt;- gap_filter %&gt;% mutate_if(~ is.character(.), ~factor(.)) %&gt;% mutate(population = as.integer(population)) 2-7 절차를 pipe로 묶으면 gap_filter &lt;- country_pop %&gt;% left_join(gdpcap, by = c(&quot;iso&quot; = &quot;iso_code&quot;, &quot;country&quot;, &quot;year&quot;)) %&gt;% left_join(lifeexp, by = c(&quot;iso&quot; = &quot;iso_code&quot;, &quot;country&quot;, &quot;year&quot;)) %&gt;% filter(population &gt;= 60000, between(year, 1950, 2020)) %&gt;% mutate(iso = toupper(iso), gdp_cap = gdp_total/population) %&gt;% select(-gdp_total) %&gt;% left_join(region %&gt;% select(-country), by = c(&quot;iso&quot;)) %&gt;% select(iso:country, region, everything()) %&gt;% mutate_if(~ is.character(.), ~factor(.)) %&gt;% mutate(population = as.integer(population)) # write_csv(gap_filter, &quot;dataset/gapminder/gapminder_filter.csv&quot;) 2020년 현재 지역별 인구수, 평균 일인당 국민소득, 평균 기대수명 계산 후 인구 수로 내림차순 정렬 gap_filter %&gt;% filter(year == 2020) %&gt;% group_by(region) %&gt;% summarise(Population = sum(population), `GDP/Captia` = mean(gdp_cap), `Life expect` = mean(life_expectancy, na.rm = TRUE)) %&gt;% arrange(desc(Population)) 지금까지 배운 dplyr 패키지와 관련 명령어를 포함한 주요 동사 및 함수에 대한 개괄적 사용 방법은 RStudio 에서 제공하는 cheat sheet을 통해 개념을 다질 수 있음. References "],["data-transformation.html", "11.4 데이터 변환", " 11.4 데이터 변환 Tidy data에 대한 개념을 알아보고, tidyr 패키지에서 제공하는 데이터 변환 함수 사용 방법에 대해 익힌다. 데이터 분석에서 적어도 80% 이상의 시간을 데이터 전처리에 할애 실제 데이터(real world data, RWD)가 우리가 지금까지 다뤄왔던 예제 데이터 처럼 깔끔하게 정리된 경우는 거의 없음. 이상치(outlier) 결측(missing data) 변수 정의의 부재(예: 어러 가지 변수 값이 혼합되어 한 열로 포함된 경우) 비정형 문자열로 구성된 변수 불분명한 데이터 구조 … Tidyverse 세계에서 지저분한 데이터(messy data)를 분석이 용이하고(전산 처리가 쉽고) 깔끔한 데이터(tidy data)로 정제하기 위해 데이터의 구조를 변환하는 함수를 포함하고 있는 패키지가 tidyr 여기서 “tidy”는 “organized”와 동일한 의미를 가짐 tidyr은 Hadely Wickam 이 개발한 reshape 와 reshape2 패키지 (Wickham 2007)가 포함하고 있는 전반적인 데이터 변환 함수 중 tidy data를 만드는데 핵심적인 함수만으로 구성된 패키지 11.4.1 Tidy data 시작 전 tidyverse 패키지를 R 작업공간으로 불러오기!! 아래 강의 내용은 Wickham et al. (2014) 의 내용을 재구성함 데이터셋의 구성 요소 데이터셋은 관측값(value)으로 구성 각 관찰값은 변수(variable)와 관측(observation) 단위에 속함 변수는 측정 속성과 단위가 동일한 값으로 구성(예: 키, 몸무게, 체온 등) 관측(observation)은 속성(변수) 전체에서 동일한 단위(예: 사람, 가구, 지역 등)에서 측정된 모든 값 Figure 11.8: 데이터의 구성 요소 Tidy Data Principles 각각의 변수는 하나의 열로 구성된다(Each variable forms a column). 각각의 관측은 하나의 행으로 구성된다(Each observation forms a row). 각각의 값은 반드시 자체적인 하나의 셀을 가져야 한다(Each value must have its own cell). 각각의 관찰 단위는 테이블을 구성한다(Each type of observational unit forms a table). 2 \\(\\times\\) 2 교차설계 데이터 예시: 2개의 열(column), 3개의 행(row), 각 행과 열은 이름을 갖고 있음(labelled) Table 11.9: Tidy data 예시 데이터 1 treatmenta treatmentb James McGill NA 1 Kimberly Wexler 17 14 Lalo Salamanca 8 19 데이터셋에서 중요한 요인인 배정군의 수준이 변수로 사용 \\(\\rightarrow\\) a와 b는 treatment의 하위 수준임 예시 데이터 1 전치 \\(\\rightarrow\\) 위 데이터 셋과 동일한 내용이지만 다른 레이아웃 형태 Table 11.10: Tidy data: 예시 데이터 1과 동일 내용, 다른 레이아웃 James McGill Kimberly Wexler Lalo Salamanca treatmenta NA 17 8 treatmentb 1 14 19 관측 단위가 변수로 사용 위 예시 데이터 1을 재정의 person: 3 개의 값(James, Kimberly, Lalo) treatment: 2 개의 값(a, b) result: 6 개의 값(결측 포함) person과 treatment의 조합 Table 11.11: Tidy data: 예시 데이터 1 구조 변환 name treatment result James McGill a NA Kimberly Wexler a 17 Lalo Salamanca a 8 James McGill b 1 Kimberly Wexler b 14 Lalo Salamanca b 19 위 데이터는 모든 행(row)는 observation을 나타냄 모든 result에 해당하는 값(value)은 하나의 treatment와 하나의 person에 대응함 모든 열은 변수(variable) \\(\\rightarrow\\) tidy data 원칙을 만족 Tidy data의 장점 표준화된 데이터 구조로 변수 및 관측치 추출이 용이 일관된 데이터 구조를 유지된다면 이와 관련한 도구(함수)를 배우는 것이 보다 용이함 R의 vectorized programming 환경에 최적화 \\(\\rightarrow\\) 동일한 관측에 대한 서로 다른 변수값이 항상 짝으로 매칭되는 것을 보장 Messy data의 일반적인 문제점 열 이름을 변수명이 아닌 값(value)으로 사용 두 개 이상의 변수에 해당하는 값이 하나의 열에 저장 이러한 문제를 해결(데이터 정돈)하기 위해 데이터의 구조 변환은 필수적이며, 이를 위해 tidyr 패키지에서 아래와 같은 패키지 제공 gather(), pivot_longer(): 아래로 긴 데이터 셋(melt된 데이터셋) \\(\\rightarrow\\) long format spread(), pivot_wider(): 옆으로 긴 데이터 셋(열에 cast된 데이터셋) \\(\\rightarrow\\) wide format long format: 데이터가 적은 수의 열로 이루어지며, 각 열 보통 행의 unique한 정보를 표현하기 위한 ID(또는 key)로 구성되어 있고 보통은 관측된 변수에 대한 한 개의 열로 구성된 데이터 형태 wide format: 통계학에서 다루는 데이터 구조와 동일한 개념으로 한 관측 단위(사람, 가구 등)가 한 행을 이루고, 관측 단위에 대한 측정값(예: 키, 몸무게, 성별)들이 변수(열)로 표현된 데이터 형태 mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 # A tibble: 352 × 3 model variable value &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 AMC Javelin mpg 15.2 2 AMC Javelin cyl 8 3 AMC Javelin disp 304 4 AMC Javelin hp 150 5 AMC Javelin drat 3.15 6 AMC Javelin wt 3.44 7 AMC Javelin qsec 17.3 8 AMC Javelin vs 0 9 AMC Javelin am 0 10 AMC Javelin gear 3 # … with 342 more rows dplyr 패키지와 마찬가지로 tidyr 패키지에서 제공하는 함수는 데이터 프레임 또는 티블에서만 작동함 11.4.2 Long format “long” 형태의 데이터 구조는 “wide” 형태의 데이터 보다 “사람”이 이해하기에 편한 형태는 아니지만 아래와 같은 장점을 가짐 “컴퓨터”가 이해하기 편한 구조 “wide” 형태보다 유연 \\(\\rightarrow\\) 데이터의 추가 및 삭제 용이 “wide” 형태의 데이터를 “long” 형태로 변환 해주는 tidyr 패키지 내장 함수는 pivot_longer(): 데이터의 행의 길이를 늘리고 열의 개수를 줄이는 함수 gather(): pivot_longer()의 이전 버전으로 보다 쉽게 사용할 수 있고, 함수 명칭도 보다 직관적이지만 함수 업데이트는 종료 “wide” 형태의 데이터를 “long” 형태로 바꾸는 것은 원래 구조의 데이터를 녹여서(melt) 길게 만든다는 의미로도 해석할 수 있음. tidyr의 초기 버전인 reshape 패키지에서 pivot_wider() 또는 gather()와 유사한 기능을 가진 함수 이름이 melt() 임. 본 강의에서는 melt() 함수의 사용 방법에 대해서는 다루지 않음. # pivot_longer()의 기본 사용 형태 pivot_longer( data, # 데이터 프레임 cols, # long format으로 변경을 위해 선택한 열 이름 # dplyr select() 함수에서 사용한 변수선정 방법 준용 names_to, # 선택한 열 이름을 값으로 갖는 변수명칭 지정 names_prefix, #변수명에 처음에 붙는 접두어 패턴 제거(예시 참조, optional) names_pattern, # 정규표현식의 그룹지정(())에 해당하는 패턴을 값으로 사용 # 예시 참조(optional) values_to # 선택한 열에 포함되어 있는 셀 값을 저장할 변수 이름 지정 ) # gather() 기본 사용 형태 gather( data, # 데이터 프레임 key, # 선택한 열 이름을 값으로 갖는 변수명칭 지정 value, # 선택한 열에 포함되어 있는 셀 값을 저장할 변수 이름 지정 ... # long format으로 변경할 열 선택 ) Examples 열의 이름이 변수명이 아니라 값으로 표현된 경우 # 데이터 불러오기: read_csv() 함수를 이용해 # tidyr-wide-ex01.csv 파일 불러오기 wide_01 &lt;- read_csv(&quot;dataset/tidyr-wide-ex01.csv&quot;) wide_01 총 21개의 열과 3개의 행으로 구성된 “wide” 형태 데이터 구조 열 이름 2001 ~ 2020은 2001년부터 2020년 까지 년도을 의미함 현재 데이터 구조에서 각 셀의 값(value)은 일인당 국민소득을 나타냄 한 행은 국가(country)의 2001년부터 2020년 까지 년도 별 일인당 국민소득 여기서 관측 단위(observational unit)은 국가(country)이며, 각 국가는 2001년부터 2020년 까지 일인당 국민소득에 대한 관찰값을 가짐 위 데이터가 tidy data 원칙을 준수하려면 어떤 형태로 재구성 되야 할까? 열 이름은 년도에 해당하는 값(value) 임 \\(\\rightarrow\\) year라는 새로운 변수에 해당 값을 저장 일인당 국민소득 정보를 포함한 gdp_cap이라는 변수 생성 대략 아래와 같은 형태의 데이터 long format 의 데이터 구조 Unique한 각각의 관측 결과(대한민국의 2001년 일인당 국민소득이 얼마)는 하나의 행에 존재 데이터에서 변수로 표현할 수 있는 속성은 모두 열로 표시 각 변수에 해당하는 값(value)은 하나의 셀에 위치 \\(\\rightarrow\\) tidy data 원칙 만족 예시 1: wide_01 데이터셋 # wide_01 데이터 tidying ## pivot_wider() 사용 tidy_ex_01 &lt;- wide_01 %&gt;% pivot_longer(`2001`:`2020`, names_to = &quot;year&quot;, values_to = &quot;gdp_cap&quot;) tidy_ex_01 %&gt;% print # A tibble: 60 × 3 country year gdp_cap &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Germany 2001 37325. 2 Germany 2002 37262. 3 Germany 2003 36977. 4 Germany 2004 37418. 5 Germany 2005 37704. 6 Germany 2006 39143. 7 Germany 2007 40474. 8 Germany 2008 40989. 9 Germany 2009 38784. 10 Germany 2010 40429. # … with 50 more rows ## gather() 사용 tidy_ex_01 &lt;- wide_01 %&gt;% gather(year, gdp_cap, `2001`:`2020`) tidy_ex_01 %&gt;% print # A tibble: 60 × 3 country year gdp_cap &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 Germany 2001 37325. 2 South Korea 2001 21530. 3 United States 2001 45663. 4 Germany 2002 37262. 5 South Korea 2002 22997. 6 United States 2002 46029. 7 Germany 2003 36977. 8 South Korea 2003 23549. 9 United States 2003 46941. 10 Germany 2004 37418. # … with 50 more rows 예시 2: tidyr 패키지에 내장되어 있는 billboard 데이터셋(help(billboard) 참고) billboard %&gt;% print # A tibble: 317 × 79 artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8 &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2 Pac Baby… 2000-02-26 87 82 72 77 87 94 99 NA 2 2Ge+her The … 2000-09-02 91 87 92 NA NA NA NA NA 3 3 Doors D… Kryp… 2000-04-08 81 70 68 67 66 57 54 53 4 3 Doors D… Loser 2000-10-21 76 76 72 69 67 65 55 59 5 504 Boyz Wobb… 2000-04-15 57 34 25 17 17 31 36 49 6 98^0 Give… 2000-08-19 51 39 34 26 26 19 2 2 7 A*Teens Danc… 2000-07-08 97 97 96 95 100 NA NA NA 8 Aaliyah I Do… 2000-01-29 84 62 51 41 38 35 35 38 9 Aaliyah Try … 2000-03-18 59 53 38 28 21 18 16 14 10 Adams, Yo… Open… 2000-08-26 76 76 74 69 68 67 61 58 # … with 307 more rows, and 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, # wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;, wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, # wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;, wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, # wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;, wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, # wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;, wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, # wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;, wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, # wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, wk43 &lt;dbl&gt;, wk44 &lt;dbl&gt;, wk45 &lt;dbl&gt;, wk46 &lt;dbl&gt;, … names(billboard) [1] &quot;artist&quot; &quot;track&quot; &quot;date.entered&quot; &quot;wk1&quot; &quot;wk2&quot; [6] &quot;wk3&quot; &quot;wk4&quot; &quot;wk5&quot; &quot;wk6&quot; &quot;wk7&quot; [11] &quot;wk8&quot; &quot;wk9&quot; &quot;wk10&quot; &quot;wk11&quot; &quot;wk12&quot; [16] &quot;wk13&quot; &quot;wk14&quot; &quot;wk15&quot; &quot;wk16&quot; &quot;wk17&quot; [21] &quot;wk18&quot; &quot;wk19&quot; &quot;wk20&quot; &quot;wk21&quot; &quot;wk22&quot; [26] &quot;wk23&quot; &quot;wk24&quot; &quot;wk25&quot; &quot;wk26&quot; &quot;wk27&quot; [31] &quot;wk28&quot; &quot;wk29&quot; &quot;wk30&quot; &quot;wk31&quot; &quot;wk32&quot; [36] &quot;wk33&quot; &quot;wk34&quot; &quot;wk35&quot; &quot;wk36&quot; &quot;wk37&quot; [41] &quot;wk38&quot; &quot;wk39&quot; &quot;wk40&quot; &quot;wk41&quot; &quot;wk42&quot; [46] &quot;wk43&quot; &quot;wk44&quot; &quot;wk45&quot; &quot;wk46&quot; &quot;wk47&quot; [51] &quot;wk48&quot; &quot;wk49&quot; &quot;wk50&quot; &quot;wk51&quot; &quot;wk52&quot; [56] &quot;wk53&quot; &quot;wk54&quot; &quot;wk55&quot; &quot;wk56&quot; &quot;wk57&quot; [61] &quot;wk58&quot; &quot;wk59&quot; &quot;wk60&quot; &quot;wk61&quot; &quot;wk62&quot; [66] &quot;wk63&quot; &quot;wk64&quot; &quot;wk65&quot; &quot;wk66&quot; &quot;wk67&quot; [71] &quot;wk68&quot; &quot;wk69&quot; &quot;wk70&quot; &quot;wk71&quot; &quot;wk72&quot; [76] &quot;wk73&quot; &quot;wk74&quot; &quot;wk75&quot; &quot;wk76&quot; # pivot_wider()을 이용해 데이터 정돈 billb_tidy &lt;- billboard %&gt;% pivot_longer(starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;) billb_tidy %&gt;% print # A tibble: 24,092 × 5 artist track date.entered week rank &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk1 87 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk2 82 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk3 72 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk4 77 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk5 87 6 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk6 94 7 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk7 99 8 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk8 NA 9 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk9 NA 10 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk10 NA # … with 24,082 more rows # pivot_longer() 함수의 인수 중 value_drop_na 값 조정을 통해 # 데이터 값에 포함된 결측 제거 가능 billb_tidy &lt;- billboard %&gt;% pivot_longer(starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;, values_drop_na = TRUE) billb_tidy %&gt;% print # A tibble: 5,307 × 5 artist track date.entered week rank &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk1 87 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk2 82 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk3 72 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk4 77 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk5 87 6 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk6 94 7 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk7 99 8 2Ge+her The Hardest Part Of ... 2000-09-02 wk1 91 9 2Ge+her The Hardest Part Of ... 2000-09-02 wk2 87 10 2Ge+her The Hardest Part Of ... 2000-09-02 wk3 92 # … with 5,297 more rows # pivot_longer() 함수의 인수 중 names_prefix 인수 값 설정을 통해 # 변수명에 처음에 붙는 접두어(예: V, wk 등) 제거 가능 billb_tidy &lt;- billboard %&gt;% pivot_longer(starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;, names_prefix = &quot;wk&quot;, values_drop_na = TRUE) billb_tidy %&gt;% print # A tibble: 5,307 × 5 artist track date.entered week rank &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 1 87 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 2 82 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 3 72 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 4 77 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 5 87 6 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 6 94 7 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 7 99 8 2Ge+her The Hardest Part Of ... 2000-09-02 1 91 9 2Ge+her The Hardest Part Of ... 2000-09-02 2 87 10 2Ge+her The Hardest Part Of ... 2000-09-02 3 92 # … with 5,297 more rows # pivot_longer() 함수의 인수 중 names_ptypes 또는 values_ptypes 인수 값 설정을 통해 # 새로 생성한 변수(name과 value 에 해당하는)의 데이터 타입 변경 가능 billb_tidy &lt;- billboard %&gt;% pivot_longer(starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;, names_prefix = &quot;wk&quot;, names_transform = list(week = as.integer), values_drop_na = TRUE) billb_tidy %&gt;% print # A tibble: 5,307 × 5 artist track date.entered week rank &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;int&gt; &lt;dbl&gt; 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 1 87 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 2 82 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 3 72 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 4 77 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 5 87 6 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 6 94 7 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 7 99 8 2Ge+her The Hardest Part Of ... 2000-09-02 1 91 9 2Ge+her The Hardest Part Of ... 2000-09-02 2 87 10 2Ge+her The Hardest Part Of ... 2000-09-02 3 92 # … with 5,297 more rows # 연습: wide_01 데이터에서 year을 정수형으로 변환(mutate 함수 사용하지 않고) 두 개 이상의 변수에 해당하는 값이 하나의 열에 저장 예시 데이터: tidyr 패키지에 내장되어 있는 who 데이터셋(help(who)를 통해 데이터 설명 참고) # A tibble: 7,240 × 60 country iso2 iso3 year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544 &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 Afghani… AF AFG 1980 NA NA NA NA 2 Afghani… AF AFG 1981 NA NA NA NA 3 Afghani… AF AFG 1982 NA NA NA NA 4 Afghani… AF AFG 1983 NA NA NA NA 5 Afghani… AF AFG 1984 NA NA NA NA 6 Afghani… AF AFG 1985 NA NA NA NA 7 Afghani… AF AFG 1986 NA NA NA NA 8 Afghani… AF AFG 1987 NA NA NA NA 9 Afghani… AF AFG 1988 NA NA NA NA 10 Afghani… AF AFG 1989 NA NA NA NA # … with 7,230 more rows, and 52 more variables: new_sp_m4554 &lt;int&gt;, # new_sp_m5564 &lt;int&gt;, new_sp_m65 &lt;int&gt;, new_sp_f014 &lt;int&gt;, # new_sp_f1524 &lt;int&gt;, new_sp_f2534 &lt;int&gt;, new_sp_f3544 &lt;int&gt;, # new_sp_f4554 &lt;int&gt;, new_sp_f5564 &lt;int&gt;, new_sp_f65 &lt;int&gt;, # new_sn_m014 &lt;int&gt;, new_sn_m1524 &lt;int&gt;, new_sn_m2534 &lt;int&gt;, # new_sn_m3544 &lt;int&gt;, new_sn_m4554 &lt;int&gt;, new_sn_m5564 &lt;int&gt;, # new_sn_m65 &lt;int&gt;, new_sn_f014 &lt;int&gt;, new_sn_f1524 &lt;int&gt;, … Table 11.12: tidyr 패키지 내장 데이터 who 코드 설명 변수명 변수설명 country 국가명 iso2, iso3 2자리 또는 3자리 국가코드 year 년도 new_sp_m014 - newrel_f65 변수 접두사: new_ 또는 new; 진단명: sp = positive pulmonary smear, sn = negative pulmonary smear, ep = extrapulmonary, rel = relapse; 성별: m = male, f = female; 연령대: 014 = 0-14 yrs, 1524 = 14-24 yrs, 2534 = 25-34 yrs, 3544 = 35-44 yrs, 4554 = 45-54 yrs, 5564 = 55-64 yrs, 65 = 65 yrs or older 데이터 정돈 전략(pivot_longer() 이용) country, iso2, iso3, year은 정상적인 변수 형태임 \\(\\rightarrow\\) 그대로 둔다 names_to 인수에 diagnosis, sex, age_group로 변수명을 지정 names_prefix 인수에서 접두어 제거 names_pattern 인수에서 추출한 변수의 패턴을 정규표현식을 이용해 표현(각 변수는 ()으로 구분) \\(\\rightarrow\\) _를 기준으로 왼쪽에는 (소문자 알파벳이 하나 이상 존재하고), 오른쪽에는 (m 또는 f)와 (숫자가 1개 이상)인 패턴 names_ptypes 인수를 이용해 생성한 변수의 데이터 타입 지정 diagnosis: factor sex: factor age_group: factor values_to 인수에 longer 형태로 변환 후 생성된 값을 저장한 열(변수) 이름 count 지정 values_drop_na 인수를 이용해 결측 제거 # pivot_longer()를 이용해 who 데이터셋 데이터 정돈 who_tidy &lt;- who %&gt;% pivot_longer( new_sp_m014:newrel_f65, names_to = c(&quot;diagnosis&quot;, &quot;sex&quot;, &quot;age_group&quot;), names_prefix = &quot;^new_?&quot;, names_pattern = &quot;([a-z]+)_(m|f)([0-9]+)&quot;, names_ptypes = list( diagnosis = factor(levels = c(&quot;rel&quot;, &quot;sn&quot;, &quot;sp&quot;, &quot;ep&quot;)), sex = factor(levels = c(&quot;f&quot;, &quot;m&quot;)), age_group = factor(levels = c(&quot;014&quot;, &quot;1524&quot;, &quot;2534&quot;, &quot;3544&quot;, &quot;4554&quot;, &quot;5564&quot;, &quot;65&quot;), ordered = TRUE) ), values_to = &quot;count&quot;, values_drop_na = TRUE ) who_tidy %&gt;% print # A tibble: 76,046 × 8 country iso2 iso3 year diagnosis sex age_group count &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;ord&gt; &lt;int&gt; 1 Afghanistan AF AFG 1997 sp m 014 0 2 Afghanistan AF AFG 1997 sp m 1524 10 3 Afghanistan AF AFG 1997 sp m 2534 6 4 Afghanistan AF AFG 1997 sp m 3544 3 5 Afghanistan AF AFG 1997 sp m 4554 5 6 Afghanistan AF AFG 1997 sp m 5564 2 7 Afghanistan AF AFG 1997 sp m 65 0 8 Afghanistan AF AFG 1997 sp f 014 5 9 Afghanistan AF AFG 1997 sp f 1524 38 10 Afghanistan AF AFG 1997 sp f 2534 36 # … with 76,036 more rows 11.4.3 Wide format long format의 반대가 되는 데이터 형태 관측 단위의 측정값(예: 다수 변수들)이 다중 행으로 구성된 경우 tidy data를 만들기 위해 wide format으로 데이터 변환 요구 요약표 생성 시 유용하게 사용 “long” 형태의 데이터를 “wide” 형태로 변환 해주는 tidyr 패키지 내장 함수는 pivot_wider(): 데이터의 행을 줄이고 열의 개수를 늘리는 함수 spread(): pivot_wider()의 이전 버전 # pivot_wider()의 기본 사용 형태 pivot_wider( data, # 데이터 프레임 names_from, # 출력 시 변수명으로 사용할 값을 갖고 있는 열 이름 values_from, # 위에서 선택한 변수의 각 셀에 대응하는 측정 값을 포함하는 열 이름 values_fill # ) # spread() 기본 사용 형태 spread( data, # 데이터 프레임 key, # 출력 시 변수명으로 사용할 값을 갖고 있는 열 이름 value # 위에서 선택한 변수의 각 셀에 대응하는 측정 값을 포함하는 열 이름 ) Examples pivot_longer()와의 관계 # 위 예시에서 생성한 tidy_ex_01 데이터 예시 ## long format으로 변환한 데이터를 다시 wide format으로 변경 ## pivot_wider() 함수 wide_ex_01 &lt;- tidy_ex_01 %&gt;% pivot_wider( names_from = year, values_from = gdp_cap ) wide_ex_01 %&gt;% print # A tibble: 3 × 21 country `2001` `2002` `2003` `2004` `2005` `2006` `2007` `2008` `2009` `2010` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Germany 37325. 37262. 36977. 37418. 37704. 39143. 40474. 40989. 38784. 40429. 2 South K… 21530. 22997. 23549. 24606. 25517. 26697. 28014. 28588. 28643. 30352. 3 United … 45663. 46029. 46941. 48275. 49513. 50438. 50898. 50350. 48644. 49479. # … with 10 more variables: `2011` &lt;dbl&gt;, `2012` &lt;dbl&gt;, `2013` &lt;dbl&gt;, # `2014` &lt;dbl&gt;, `2015` &lt;dbl&gt;, `2016` &lt;dbl&gt;, `2017` &lt;dbl&gt;, `2018` &lt;dbl&gt;, # `2019` &lt;dbl&gt;, `2020` &lt;dbl&gt; ## 데이터 동일성 확인 all.equal(wide_01, wide_ex_01) [1] &quot;Attributes: &lt; Names: 1 string mismatch &gt;&quot; [2] &quot;Attributes: &lt; Length mismatch: comparison on first 2 components &gt;&quot; [3] &quot;Attributes: &lt; Component \\&quot;class\\&quot;: Lengths (4, 3) differ (string compare on first 3) &gt;&quot; [4] &quot;Attributes: &lt; Component \\&quot;class\\&quot;: 3 string mismatches &gt;&quot; [5] &quot;Attributes: &lt; Component 2: 타겟은 externalptr이지만, 현재는 numeric 입니다 &gt;&quot; ## spread() 함수 wide_ex_01 &lt;- tidy_ex_01 %&gt;% spread(year, gdp_cap) all.equal(wide_01, wide_ex_01) [1] &quot;Attributes: &lt; Names: 1 string mismatch &gt;&quot; [2] &quot;Attributes: &lt; Length mismatch: comparison on first 2 components &gt;&quot; [3] &quot;Attributes: &lt; Component \\&quot;class\\&quot;: Lengths (4, 3) differ (string compare on first 3) &gt;&quot; [4] &quot;Attributes: &lt; Component \\&quot;class\\&quot;: 3 string mismatches &gt;&quot; [5] &quot;Attributes: &lt; Component 2: 타겟은 externalptr이지만, 현재는 numeric 입니다 &gt;&quot; 관측 단위의 측정값(예: 다수 변수들)이 다중 행으로 구성된 데이터 구조 변환 예시 데이터: tidyr 패키지 table2 데이터셋 # table2 데이터셋 check table2 %&gt;% print # A tibble: 12 × 4 country year type count &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; 1 Afghanistan 1999 cases 745 2 Afghanistan 1999 population 19987071 3 Afghanistan 2000 cases 2666 4 Afghanistan 2000 population 20595360 5 Brazil 1999 cases 37737 6 Brazil 1999 population 172006362 7 Brazil 2000 cases 80488 8 Brazil 2000 population 174504898 9 China 1999 cases 212258 10 China 1999 population 1272915272 11 China 2000 cases 213766 12 China 2000 population 1280428583 # type 변수의 값은 사실 관측 단위의 변수임 # type 값에 대응하는 값을 가진 변수는 count 임 ## 데이터 정돈(pivot_wider() 사용) table2_tidy &lt;- table2 %&gt;% pivot_wider( names_from = type, values_from = count ) table2_tidy %&gt;% print # A tibble: 6 × 4 country year cases population &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 데이터 요약 테이블 예시 데이터: mtcars 데이터셋 # 1) mtcars 데이터셋: 행 이름을 변수로 변환 후 long format 변환 ## rownames_to_column() 함수 사용 mtcars2 &lt;- mtcars %&gt;% rownames_to_column(var = &quot;model&quot;) %&gt;% pivot_longer( -c(&quot;model&quot;, &quot;vs&quot;, &quot;am&quot;), names_to = &quot;variable&quot;, values_to = &quot;value&quot; ) # 2) 엔진 유형 별 variable의 평균과 표준편차 계산 # &quot;사람&quot;이 읽기 편한 형태로 테이블 변경 mtcars2 %&gt;% mutate(vs = factor(vs, labels = c(&quot;V-shaped&quot;, &quot;Straight&quot;))) %&gt;% group_by(vs, variable) %&gt;% summarise(Mean = mean(value), SD = sd(value)) %&gt;% pivot_longer( Mean:SD, names_to = &quot;stat&quot;, values_to = &quot;value&quot; ) %&gt;% pivot_wider( names_from = variable, values_from = value ) `summarise()` has grouped output by &#39;vs&#39;. You can override using the `.groups` argument. # 조금 더 응용... ## 위 Mean ± SD 형태로 위와 유사한 구조의 테이블 생성 ### tip: 한글로 &quot;ㄷ(e) + 한자&quot; 통해 ± 입력 가능 mtcars2 %&gt;% mutate(vs = factor(vs, labels = c(&quot;V-shaped&quot;, &quot;Straight&quot;))) %&gt;% group_by(vs, variable) %&gt;% summarise(Mean = mean(value), SD = sd(value)) %&gt;% mutate(res = sprintf(&quot;%.1f ± %.1f&quot;, Mean, SD)) %&gt;% select(-(Mean:SD)) %&gt;% pivot_wider( names_from = variable, values_from = res ) `summarise()` has grouped output by &#39;vs&#39;. You can override using the `.groups` argument. 11.4.4 Separate and unite 하나의 열을 구성하는 값이 두 개 이상 변수가 혼합되어 한 셀에 표현된 경우 이를 분리해야 할 필요가 있음 \\(\\rightarrow\\) separate() 하나의 변수에 대한 값으로 표현할 수 있음에도 불구하고 두 개 이상의 변수로 구성된 경우(예: 날짜 변수의 경우 간혹 year, month,day와 같이 3 개의 변수로 분리), 이를 연결하여 하나의 변수로 변경 필요 \\(\\rightarrow\\) unite() Separate separate(): 지정한 구분 문자가 존재하는 경우 이를 쪼개서 하나의 열을 다수의 열로 분리 # separate() 함수 기본 사용 형태 seprate( data, # 데이터 프레임 col, # 분리 대상이 되는 열 이름 into, # 분리 후 새로 생성한 열들에 대한 이름(문자형 벡터) 지정 sep = &quot;[^[:alnum:]]+&quot;, # 구분자: 기본적으로 정규표현식 사용 convert # 분리한 열의 데이터 타입 변환 여부 ) 예시: tidyr 패키지 table3 데이터셋 # table3 데이터 체크 table3 %&gt;% print # A tibble: 6 × 3 country year rate * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; 1 Afghanistan 1999 745/19987071 2 Afghanistan 2000 2666/20595360 3 Brazil 1999 37737/172006362 4 Brazil 2000 80488/174504898 5 China 1999 212258/1272915272 6 China 2000 213766/1280428583 # rate 변수를 case와 population으로 분리 table3 %&gt;% separate(rate, into = c(&quot;case&quot;, &quot;population&quot;), sep = &quot;/&quot;) %&gt;% print # A tibble: 6 × 4 country year case population &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 table3 %&gt;% separate(rate, into = c(&quot;case&quot;, &quot;population&quot;), convert = TRUE) -&gt; table3_sep ## sep 인수값이 수치형 백터인 경우 분리할 위치로 인식 ## 양수: 문자열 맨 왼쪽에서 1부터 시작 ## 음수: 문자열 맨 오른쪽에서 -1부터 시작 ## sep의 길이(length)는 into 인수의 길이보다 작아야 함 # year 변수를 century와 year로 분할 table3 %&gt;% separate(year, into = c(&quot;century&quot;, &quot;year&quot;), sep = -2) %&gt;% print # A tibble: 6 × 4 country century year rate &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 19 99 745/19987071 2 Afghanistan 20 00 2666/20595360 3 Brazil 19 99 37737/172006362 4 Brazil 20 00 80488/174504898 5 China 19 99 212258/1272915272 6 China 20 00 213766/1280428583 Unite unite(): seprate() 함수의 반대 기능을 수행하며, 다수 변수를 결합 # unite() 기본 사용 형태 unite( data, # 데이터프레임 ..., # 선택한 열 이름 sep, # 연결 구분자 ) 예제: tidyr 패키지 table5 데이터셋 # table5 체크 table5 %&gt;% print # A tibble: 6 × 4 country century year rate * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 19 99 745/19987071 2 Afghanistan 20 00 2666/20595360 3 Brazil 19 99 37737/172006362 4 Brazil 20 00 80488/174504898 5 China 19 99 212258/1272915272 6 China 20 00 213766/1280428583 # century와 year을 결합한 new 변수 생성 table5 %&gt;% unite(new, century, year) %&gt;% print # A tibble: 6 × 3 country new rate &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Afghanistan 19_99 745/19987071 2 Afghanistan 20_00 2666/20595360 3 Brazil 19_99 37737/172006362 4 Brazil 20_00 80488/174504898 5 China 19_99 212258/1272915272 6 China 20_00 213766/1280428583 # _없이 결합 후 new를 정수형으로 변환 table5 %&gt;% unite(new, century, year, sep = &quot;&quot;) %&gt;% mutate(new = as.integer(new)) %&gt;% print # A tibble: 6 × 3 country new rate &lt;chr&gt; &lt;int&gt; &lt;chr&gt; 1 Afghanistan 1999 745/19987071 2 Afghanistan 2000 2666/20595360 3 Brazil 1999 37737/172006362 4 Brazil 2000 80488/174504898 5 China 1999 212258/1272915272 6 China 2000 213766/1280428583 # table5 데이터 정돈(separate(), unite() 동시 사용) table5 %&gt;% unite(new, century, year, sep = &quot;&quot;) %&gt;% mutate(new = as.integer(new)) %&gt;% separate(rate, c(&quot;case&quot;, &quot;population&quot;), convert = TRUE) %&gt;% print # A tibble: 6 × 4 country new case population &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 Afghanistan 1999 745 19987071 2 Afghanistan 2000 2666 20595360 3 Brazil 1999 37737 172006362 4 Brazil 2000 80488 174504898 5 China 1999 212258 1272915272 6 China 2000 213766 1280428583 응용 예제: mtcars 데이터셋에서 계산한 통계량 정리 # 기어 종류(`am`) 별 `mpg`, `cyl`, `disp`, `hp`, `drat`, `wt`, `qsec`의 # 평균과 표준편차 계산 mtcar_summ1 &lt;- mtcars %&gt;% mutate(am = factor(am, labels = c(&quot;automatic&quot;, &quot;manual&quot;))) %&gt;% group_by(am) %&gt;% summarise_at(vars(mpg:qsec), list(mean = ~ mean(.), sd = ~ sd(.))) mtcar_summ1 %&gt;% print # A tibble: 2 × 15 am mpg_mean cyl_mean disp_mean hp_mean drat_mean wt_mean qsec_mean mpg_sd &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 automa… 17.1 6.95 290. 160. 3.29 3.77 18.2 3.83 2 manual 24.4 5.08 144. 127. 4.05 2.41 17.4 6.17 # … with 6 more variables: cyl_sd &lt;dbl&gt;, disp_sd &lt;dbl&gt;, hp_sd &lt;dbl&gt;, # drat_sd &lt;dbl&gt;, wt_sd &lt;dbl&gt;, qsec_sd &lt;dbl&gt; # am을 제외한 모든 변수에 대해 long format으로 데이터 변환 mtcar_summ2 &lt;- mtcar_summ1 %&gt;% pivot_longer( -am, names_to = &quot;stat&quot;, values_to = &quot;value&quot; ) mtcar_summ2 %&gt;% print # A tibble: 28 × 3 am stat value &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; 1 automatic mpg_mean 17.1 2 automatic cyl_mean 6.95 3 automatic disp_mean 290. 4 automatic hp_mean 160. 5 automatic drat_mean 3.29 6 automatic wt_mean 3.77 7 automatic qsec_mean 18.2 8 automatic mpg_sd 3.83 9 automatic cyl_sd 1.54 10 automatic disp_sd 110. # … with 18 more rows # stat 변수를 &quot;variable&quot;, &quot;statistic&quot;으로 분리 후 # variable과 value를 wide format으로 데이터 변환 mtcar_summ3 &lt;- mtcar_summ2 %&gt;% separate(stat, c(&quot;variable&quot;, &quot;statistic&quot;)) %&gt;% pivot_wider( names_from = variable, values_from = value ) mtcar_summ3 %&gt;% print # A tibble: 4 × 9 am statistic mpg cyl disp hp drat wt qsec &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 automatic mean 17.1 6.95 290. 160. 3.29 3.77 18.2 2 automatic sd 3.83 1.54 110. 53.9 0.392 0.777 1.75 3 manual mean 24.4 5.08 144. 127. 4.05 2.41 17.4 4 manual sd 6.17 1.55 87.2 84.1 0.364 0.617 1.79 Tidy data를 만들기 위한 과정이 꼭 필요할까? \\(\\rightarrow\\) long format 데이터가 정말 필요할까? ggplot trailer: 11.4.2 절 Long format 에서 예시 데이터로 활용한 wide-01 데이터 셋을 이용해 국가별 연도에 따른 일인당 국민소득 추이를 시각화 Strategy wide-01 데이터 형태 그대로 시각화 wide-01을 long format으로 변환한 tidy_ex_01 에서 시각화 # ggplot trailer tidy_ex_01 &lt;- wide_01 %&gt;% pivot_longer(`2001`:`2020`, names_to = &quot;year&quot;, values_to = &quot;gdp_cap&quot;, names_transform = list(year = as.integer)) tidy_ex_01 %&gt;% ggplot + aes(x = year, y = gdp_cap, color = country, group = country) + geom_point(size = 3) + geom_line(size = 1) + labs(x = &quot;Year&quot;, y = &quot;Total GDP/captia&quot;) + theme_classic() tidy_ex_01 %&gt;% ggplot + aes(x = year, y = gdp_cap, group = country) + geom_point(size = 3) + geom_line(size = 1) + labs(x = &quot;Year&quot;, y = &quot;Total GDP/captia&quot;) + facet_grid(~ country) + theme_minimal() References "],["ch-data-visualization.html", "12 데이터 시각화", " 12 데이터 시각화 학습 목표 R에서 기본으로 제공하는 그래프 생성 개념 및 관련 함수의 의미 및 사용 방법에 대해 학습한다. Grammar of graphics를 기반으로 개발된 ggplot2 패키지에 대해 알아보고 사용 방법을 학습힌다. “The simple graph has brought more information to the data analyst’s mind than any other device.” \\(\\rightarrow\\) John Tukey 그래프는 생각보다 더 많은 정보를 제공 데이터 분석 시 통계량 만으로 데이터의 속성을 결정하는 것은 매우 위험(예: Anscombe’s quartet 데이터 예제) x1 x2 x3 x4 y1 y2 y3 y4 9.000000 9.000000 9.000000 9.000000 7.500909 7.500909 7.500000 7.500909 x1 x2 x3 x4 y1 y2 y3 y4 3.316625 3.316625 3.316625 3.316625 2.031568 2.031657 2.030424 2.030579 Figure 11.1: Anscombe’s quartet: https://goo.gl/Ugv3Cz 에서 스크립트 발췌 시각화는 분석에 필요한 통계량 또는 분석 방법론에 대한 가이드를 제시 인간의 뇌 구조 상 추상적인 숫자나 문자 보다는 그림이나 도표를 더 빨리 이해 다른 통계 패키지(SPSS, SAS, STATA 등)와 비교할 수 없을 정도로 월등한 성능의 그래픽 도구 및 기능 제공 "],["r-basic-graphics.html", "12.1 R 기본 그래프 함수", " 12.1 R 기본 그래프 함수 R의 그래픽은 그래픽 장치에 특정 그림(선, 점, 면 등)을 순차적으로 추가하는 명령(스크립트)을 통해 생성 그래픽 장치: R에서 그래프가 출력되는 장치 windows: R 프로그램 내에서 출력 graphic files: pdf, jpeg, tiff, png, bmp 등의 확장자를 갖는 이미지 파일 그래프 장치를 열기 위해 사용되는 함수 windows() 또는 win.graph(): 그래픽 장치를 열기 위해 사용하는 함수 dev.cur(): 현재 활성화된 그래프 장치 확인 dev.set(): 다수의 그래프 장치가 열려 있는 경우 which = 번호로 변경 dev.list(): 현재 열려 있는 그래픽 장치 목록 조회 dev.off(): 현재 작업 중인 그래픽 장치 중지 graphics.off(): 열려있는 모든 그래픽 장치 중지 R 그래프의 구조 Figure 12.1: R 그래프영역 Figure region: 범례(legend), x축, y축, 도표 등을 그래프가 표현하는 모든 구성요소를 포함하는 영역(plot region 포함) Plot region: 도표 부분 출력되는 영역 Figure margin: figure region 안에서 plot region의 여백 부분을 나타내며, x, y 축 레이블(label), 제목(title), 각 축의 tick 및 값 등이 주로 위치하는 영역 Outer margin: figure region 밖의 여백 부분 R 기본 그래프 함수에 대한 강의 내용은 주로 AIMS-R-users에서 참고를 함 그래프의 요소: 점(point), 선(line), 면(area), , 텍스트(text), 축(axis), 눈금(tick), 범례(legend) 등 저수준 그래프 함수(low level plotting function): 위의 그래프 요소들을 개별적으로 작업(좌표축 정의, 여백 정의)하기 위한 함수군 고수준 그래프 함수(high level plotting function): 그래프의 함수 기능(저수준 그래프 함수)를 모아서 하나의 완성된 도표(산점도, 막대도표, 히스토그램, 상자그림 등)를 생성할 수 있는 함수군 고수준 그래프 함수를 호출할 경우 자동으로 그래픽 장치가 열려서 win.graph() 등을 사용할 필요가 없으나, 이미 호출된 그래프는 사라짐 주의: 일반적으로 R 기본 그래픽 함수로 도표 작성 시 저수준 그래프 함수는 고수준 그래프 함수로 생성한 그래프에 부가적 기능을 추가하기 위해 사용됨. 따라서 저수준 그래프 함수군은 고수준 그래프 함수을 통해 먼저 생성한 그래프(주로 아래 설명할 plot() 함수) 위에 적용됨. "],["high-level-graph.html", "12.2 고수준 그래프 함수", " 12.2 고수준 그래프 함수 12.2.1 plot() 함수 R의 가장 대표적인 2차원 고수준 그래프 출력 함수 plot()의 가장 일반적인 용도는 그래프 장치를 설정(축, 값의 범위 등) 후 저수준 그래프 함수(축, 선, 점, 면 등)를 그래프 장치에 적용 데이터가 저장되어 있는 객체(벡터, 행렬, 데이터 프레임 등) 하나 이상을 함수의 인수(argument)로 사용 데이터의 클래스에 따라 출력되는 그래프 결과가 다름 \\(\\rightarrow\\) methods(plot)을 통해 plot() 함수가 적용되는 클래스 확인 가능 #각 클래스에 적용되는 plot() 함수 리스트 methods(plot) [1] plot,ANY-method plot,color-method plot.acf* [4] plot.data.frame* plot.decomposed.ts* plot.default [7] plot.dendrogram* plot.density* plot.ecdf [10] plot.factor* plot.formula* plot.function [13] plot.ggplot* plot.gtable* plot.hcl_palettes* [16] plot.hclust* plot.histogram* plot.HoltWinters* [19] plot.isoreg* plot.lm* plot.medpolish* [22] plot.mlm* plot.ppr* plot.prcomp* [25] plot.princomp* plot.profile.nls* plot.R6* [28] plot.raster* plot.spec* plot.stepfun [31] plot.stl* plot.table* plot.trans* [34] plot.ts plot.tskernel* plot.TukeyHSD* see &#39;?methods&#39; for accessing help and source code #예시 1: 객체 클래스가 데이터 프레임인 경우 # mtcars 데이터 예시 class(mtcars) [1] &quot;data.frame&quot; plot(mtcars) # 예시2: lm()으로 도출된 객체(list) ## 연비(mpg)를 종속 변수, 배기량(disp)을 독립변수로 한 회귀모형 ## lm() 함수 사용 -&gt; 객체 클래스는 lm mod &lt;- lm(mpg ~ disp, data = mtcars) class(mod) [1] &quot;lm&quot; par(mfrow = c(2, 2)) # 4개 도표를 한 화면에 표시(2행, 2열) plot(mod) dev.off() # 활성화된 그래프 장치 닫기 null device 1 # 예시3: 테이블 객체 class(Titanic) [1] &quot;table&quot; plot(Titanic) 객체의 클래스가 벡터나 행렬인 경우, 객체에 저장된 데이터를 2차원 평면(x-y 좌표)에 출력 # 예시1: 데이터 객체를 하나만 인수로 받는 경우 # -&gt; x축은 객체의 색인이고, x의 데이터는 y 좌표에 매핑 x &lt;- mtcars$disp y &lt;- mtcars$mpg plot(x); plot(y) # 두개의 객체를 인수로 받은 경우 # -&gt; 2차원 산점도 출력 plot(x, y) plot() 함수의 세부 옵션 plot( x, # x 축에 대응하는 데이터 객체 y, # y 축에 대응하는 데이터 객체 type, # 그래프 타입(예시 참조) main, # 제목 sub, # 부제목 xlim, ylim, # x, y 축 범위 지정 xlab, ylab, # x-y 축 이름 lty, # 선 모양 pch, # 점 모양 cex, # 점 및 텍스트 크기 lwd, # 선 굵기 col # 색상 ) type 인수: 그래프 타입 지정 # BOD 데이터셋 이용 x &lt;- BOD$Time; y &lt;- BOD$demand x; y [1] 1 2 3 4 5 7 [1] 8.3 10.3 19.0 16.0 15.6 19.8 ctype &lt;- c(&quot;p&quot;, &quot;l&quot;, &quot;b&quot;, &quot;o&quot;, &quot;c&quot;, &quot;h&quot;, &quot;s&quot;, &quot;n&quot;) type_desc &lt;- c(&quot;points&quot;, &quot;lines&quot;, &quot;both points and lines&quot;, &quot;overlapped points and plots&quot;, &quot;empty points joined by lines&quot;, &quot;histogram like vertical lines&quot;, &quot;stair steps&quot;, &quot;no lines and points&quot;) op &lt;- par(mfrow = c(2, 4)) for (i in 1:length(ctype)) { plot(x, y, type = ctype[i], main = paste(&quot;type =&quot;, &quot;&#39;&quot;, ctype[i], &quot;&#39;&quot;), sub = type_desc[i], cex.main = 1.5, cex.sub = 1.5, cex = 2) } par(op) xlim, ylim 인수: x, y 축의 범위 지정 op &lt;- par(mfrow = c(2, 3)) range &lt;- data.frame( x1 = rep(c(0, 1), each = 3), x2 = rep(c(10, 5), each = 3), y1 = rep(c(0, 5, 8), times = 2), y2 = rep(c(30, 20, 16), times = 2) ) for (i in 1:6) { plot(x, y, xlim = as.numeric(range[i, 1:2]), ylim = as.numeric(range[i, 3:4]), main = paste0(&quot;xlim = c(&quot;, paste(as.numeric(range[i, 1:2]), collapse = &quot;, &quot;), &quot;), &quot;, &quot;ylim = c(&quot;, paste(as.numeric(range[i, 3:4]), collapse = &quot;, &quot;), &quot;)&quot;) ) } par(op) xlab, ylab 인수: x축과 y축 이름 지정 x_lab &lt;- c(&quot; &quot;, &quot;Time (days)&quot;) y_lab &lt;- c(&quot;Demand&quot;, &quot;Oxygen demend (mg/l)&quot;) op &lt;- par(mfrow = c(2, 2)) lab_d &lt;- expand.grid(x_lab, y_lab) for (i in 1:4) { plot(x, y, xlab = lab_d[i, 1], ylab = lab_d[i, 2], main = paste0(&quot;xlab = &quot;, &quot;&#39;&quot;, lab_d[i, 1], &quot;&#39;&quot;, &quot;, &quot;, &quot;ylab = &quot;, &quot;&#39;&quot;, lab_d[i, 2], &quot;&#39;&quot;) ) } par(op); dev.off() null device 1 lty 인수: 선의 형태 지정 line_type &lt;- c(&quot;blank&quot;, &quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, &quot;twodash&quot;) plot(x = c(1:7), y = c(1:7), type=&quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;Basic Line Types&quot;, cex.main = 1.5) for (i in 1:length(line_type)) { lines(c(1, 5.2), c(i, i), lty = i - 1, lwd = 2) text(5.5, i, labels = paste0(&quot;lty = &quot;, i - 1, &quot; (&quot;, line_type[i], &quot;)&quot;), cex = 1.2, adj = 0) } Figure 12.2: lty 파라미터 값에 따른 선 형태 pch 인수: 점(point)의 모양을 지정 coord &lt;- expand.grid(x = 1:5, y = 1:5) plot(coord, type = &quot;n&quot;, xlim = c(0.8, 5.5), ylim = c(0.8, 5.5), xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;Basic plotting characters&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;) grid() points(coord, pch=1:25, cex = 2.5) text(coord + 0.2, labels = 1:25, cex = 1) Figure 12.3: R graphics 점 표현 기호 및 대응 번호 cex 인수: 텍스트 및 점의 크기 지정 cex.axis: 각 축의 눈금 레이블 크기 조정 cex.lab: x-y 축의 이름 크기 조정 cex.main: 그림 제목 크기 조정 cex.sub: 부제목 크기 조정 텍스트 cex 인수 적용 예시 par(mfrow = c(2, 3)) plot(BOD, type = &quot;p&quot;, cex = 2, main = &quot;cex = 2&quot;, sub = &quot;Subtitle&quot;) plot(BOD, type = &quot;p&quot;, cex.axis = 2, main = &quot;cex.axis = 2&quot;, sub = &quot;Subtitle&quot;) plot(BOD, type = &quot;p&quot;, cex.lab = 2, main = &quot;cex.lab = 2&quot;, sub = &quot;Subtitle&quot;) plot(BOD, type = &quot;p&quot;, cex.main = 2, main = &quot;cex.main = 2&quot;, sub = &quot;Subtitle&quot;) plot(BOD, type = &quot;p&quot;, cex.sub = 2, main = &quot;cex.sub = 2&quot;, sub = &quot;Subtitle&quot;) lwd 인수: 선의 두께 지정 점 cex 크기와 lwd 두께 coord &lt;- expand.grid(x = 1:5, y = 1:5) plot(coord, type=&quot;n&quot;, xlab = &quot;cex&quot;, ylab = &quot;lwd&quot;, xlim = c(0.5, 5.5), ylim = c(0.5, 5.5), main = &quot;pch and lwd size&quot;, cex.main = 2, cex.lab = 1.5) points(coord, pch=16, cex = 1:5, col = &quot;darkgray&quot;) for (i in 1:5) { points(1:5, coord$y[coord$y == i], pch=21, cex = 1:5, lwd = i, col = &quot;black&quot;) } col 인수: 그래프의 점, 면, 선의 색상 palette() 함수를 통해 그래픽 기본 색상 확인(총 8개) colors()를 통해 R에서 기본으로 제공하는 색상 확인 가능(총 657개) 내장 색상 팔레트: n 개의 색상을 반환하고, 색상의 투명도는 alpha 인수를 통해 조정 rainbow(n): Red \\(\\rightarrow\\) Violet heat.colors(n): White \\(\\rightarrow\\) Orange \\(\\rightarrow\\) Red terrain.colors(n): White \\(\\rightarrow\\) Brown \\(\\rightarrow\\) Green topo.colors(n): White \\(\\rightarrow\\) Brown \\(\\rightarrow\\) Green \\(\\rightarrow\\) Blue grey(n): White \\(\\rightarrow\\) Black R Color Chart 참고 12.2.2 주요 고수준 그래픽 함수 12.2.3 산점도 12.2.3.1 car::scatterplot() plot(x, y)를 통해 2차원 산점도를 그릴 수 있으나, car 패키지에 내장되어 있는 해당 함수를 이용해 보다 많은 정보(상자그림, 회귀곡선 등)를 포함 # car 패키지 설치 # install.packages(&quot;car&quot;) # require(car) car::scatterplot(mpg ~ disp, data = mtcars) plot() 함수의 인수 적용 가능 # help(scatterplot) 참고 car::scatterplot(mpg ~ disp, data = mtcars, regLine = list(method = lm, lty = 1, col = &quot;red&quot;), col = &quot;black&quot;, cex = 2, pch = 16) 12.2.3.2 pairs() pairs(): 산점도 행렬을 생성해주는 함수로, 객체의 클래스가 데이터 프레임인 경우 plot(dat)과 동일한 그래프를 반환 # iris dataset plot(iris) 12.2.3.3 car::scatterplotMatrix() R graphics 패키지의 pair()와 유사하나 각 변수 쌍별 회귀 곡선 및 분포 확인 가능 # iris dataset car::scatterplotMatrix(iris, col = &quot;black&quot;) # help(scatterplotMatrix) car::scatterplotMatrix(iris, col = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;), smooth = FALSE, groups = iris$Species, by.groups = FALSE, regLine = list(method = lm, lwd = 1, col = &quot;gray&quot;), pch = (15:17)) 12.2.4 행렬 그래프 행렬 객체를 plot() 함수의 입력으로 사용한 경우 1-2 번째 열 데이터로 산점도를 출력 # 행렬을 plot() 함수의 입력으로 받은 경우 par(mfrow = c(1,2)) x &lt;- seq(-5, 5, 0.01) X &lt;- mapply(dnorm, list(a = x, b = x, c = x), c(0, 1, 2), c(1, 2, 4)) X &lt;- matrix(X, nrow = length(x), ncol = 3) head(X) [,1] [,2] [,3] [1,] 1.486720e-06 0.002215924 0.02156933 [2,] 1.562867e-06 0.002249385 0.02166383 [3,] 1.642751e-06 0.002283295 0.02175862 [4,] 1.726545e-06 0.002317658 0.02185368 [5,] 1.814431e-06 0.002352479 0.02194902 [6,] 1.906601e-06 0.002387763 0.02204463 # plot() 함수를 이용한 행렬 그래프 출력 plot(X, type = &quot;l&quot;, main = &quot;plot matrix (X) using plot()&quot;) text(0.2, 0.05, labels = &quot;plot(X, type = `l`)&quot;) plot(X[, 1], X[, 2], type = &quot;l&quot;, main = &quot;scatterplot between X[, 1] and X[, 2]&quot;) text(0.2, 0.05, labels = &quot;plot(X[,1], X[,2], type = `l`)&quot;) matplot() 객체의 클래스가 행렬(matrix) 형태로 이루어진 데이터에 대한 그래프 출력 열 기준으로 그래프 출력 x 가 주어지지 않은 경우, 행렬의 색인을 x 축으로 사용 # matplot 도표 par(mfrow = c(1, 2)) matplot(X, type = &quot;l&quot;, lwd = 2, main = &quot;matplot() without x&quot;) matplot(x, X, type = &quot;l&quot;, lwd = 2, main = &quot;matplot() with x&quot;) 12.2.5 히스토그램 hist() hist( x, # vector 객체 breaks, # 빈도 계산을 위한 구간 freq, # y축 빈도 또는 밀도(density) 여부 col, # 막대 색상 지정 border, # 막대 테두리 색 지정 labels, # 막대 위 y 값 레이블 출력 여부 ... ) # airquality 데이터 셋 # help(airquality) 참고 glimpse(airquality) Rows: 153 Columns: 6 $ Ozone &lt;int&gt; 41, 36, 12, 18, NA, 28, 23, 19, 8, NA, 7, 16, 11, 14, 18, 14, … $ Solar.R &lt;int&gt; 190, 118, 149, 313, NA, NA, 299, 99, 19, 194, NA, 256, 290, 27… $ Wind &lt;dbl&gt; 7.4, 8.0, 12.6, 11.5, 14.3, 14.9, 8.6, 13.8, 20.1, 8.6, 6.9, 9… $ Temp &lt;int&gt; 67, 72, 74, 62, 56, 66, 65, 59, 61, 69, 74, 69, 66, 68, 58, 64… $ Month &lt;int&gt; 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,… $ Day &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,… temp &lt;- airquality$Temp hist(temp) hist() 함수의 반환값 h &lt;- hist(temp, plot = FALSE) # 그래프를 반환하지 않음 h $breaks [1] 55 60 65 70 75 80 85 90 95 100 $counts [1] 8 10 15 19 33 34 20 12 2 $density [1] 0.010457516 0.013071895 0.019607843 0.024836601 0.043137255 0.044444444 [7] 0.026143791 0.015686275 0.002614379 $mids [1] 57.5 62.5 67.5 72.5 77.5 82.5 87.5 92.5 97.5 $xname [1] &quot;temp&quot; $equidist [1] TRUE attr(,&quot;class&quot;) [1] &quot;histogram&quot; hist() 함수의 인수 사용(plot() 함수의 인수 거의 대부분 사용 가능) par(family = &quot;nanumgothic&quot;) hist(temp, main=&quot;La Guardia Airport 일중 최고 기온&quot;, xlab = &quot;온도&quot;, ylab = &quot;밀도&quot;, xlim = c(50,100), col = &quot;orange&quot;, freq = FALSE ) labels 인수를 통해 빈도값 출력 par(family = &quot;nanumgothic&quot;) hist(temp, main = &quot;La Guardia Airport 일중 최고 기온&quot;, xlab = &quot;온도&quot;, ylab = &quot;빈도&quot;, xlim = c(50,100), col = &quot;orange&quot;, labels = TRUE ) breaks 인수를 통해 막대 구간 조정 op &lt;- par(mfrow = c(1, 2)) hist(temp, breaks = 4, main = &quot;breaks = 4&quot;) hist(temp, breaks = 15, main = &quot;breaks = 15&quot;) par(op); dev.off() null device 1 12.2.6 막대 그래프 히스토그램(hist())은 연속형 데이터의 구간 별 빈도 또는 밀도를 나타냄 막대 도표(bar plot)는 해당 좌표의 값(value)를 나타냄 x = c(1,2,2,1,3,3,1,5) par(mfrow = c(1, 2)) hist(x); barplot(x) barplot() help(barplot) 을 통해 함수 사용 방법 확인 보통 요약통계량(예: 그룹별 빈도, 평군)의 시각화를 위해 많이 사용 ## Wool dataset: warpbreaks ## 제직 중 방적 횟수 ## 직조기 당 날실 파손 횟수 데이터 head(warpbreaks) count &lt;- with(warpbreaks, tapply(breaks, list(wool, tension), sum)) par(mfrow = c(1, 2)) barplot(count, legend = TRUE, xlab = &quot;Tension&quot;, ylab = &quot;Number of breaks&quot;, ylim = c(0, 700), cex.lab = 1.5) # stack 형태 barplot(count, legend = TRUE, beside = TRUE, xlab = &quot;Tension&quot;, ylab = &quot;Number of breaks&quot;, ylim = c(0, 450), cex.lab = 1.5) # 분리 형태 데이터 프레임을 대상으로 barplot() 실행 시 수식 표현 가능 막대도표 + 표준오차 mean_breaks &lt;- aggregate(breaks ~ wool + tension, data = warpbreaks, mean) se_breaks &lt;- aggregate(breaks ~ wool + tension, data = warpbreaks, FUN = function(x) sd(x)/sqrt(length(x))) barplot(breaks ~ wool + tension, data = mean_breaks, ylim = c(0, 55), beside = TRUE, legend = TRUE, # 범례 col = c(&quot;blue&quot;, &quot;skyblue&quot;) ) -&gt; bp cent &lt;- matrix(mean_breaks$breaks, 2, 3) sem &lt;- matrix(se_breaks$breaks, 2, 3) arrows(bp, cent - sem, bp, cent + sem, angle = 90, code = 3, length = 0.05) 12.2.7 상자 그림 다섯 개의 통계량(5 numbers summary: 최솟값, 1사분위수, 중앙값, 3사분위수, 최댓값)을 이용해 연속형 자료를 그래프로 표현한 도표 set.seed(20200522) x &lt;- rnorm(100) plab &lt;- c(&quot;min(x)&quot;, &quot;quantile(x, 0.25)&quot;, &quot;median(x)&quot;, &quot;quantile(x, 0.75)&quot;, &quot;max(x)&quot;) # x-axis 레이블 bxplt &lt;- boxplot(x, horizontal = TRUE, # x-y 축 회전 여부 axes = F, # x-y 축 출력 여부 main = &quot;Boxplot anatomy&quot;, cex.main = 2 ) # boxplot 수치 요약값 저장 axis(side = 1, at = bxplt$stats, labels = FALSE, las = 2) # x-axis 설졍 text(x = c(bxplt$stats), y = 0.4, labels = plab, xpd = TRUE, # 텍스트 출력 영역 범위 지정 srt = 25, # 레이블 로테이션 각도(degree) adj = 1.1, # 레이블 위치 조정 cex = 1.2 # 레이블 크기 조정 ) # x-axis 레이블 조정 abline(v = c(bxplt$stats), lty = 2, col = &quot;gray&quot;) # 수직 선 출력 arrows(x0 = c(bxplt$stats)[2], y0 = 1.3, x1 = c(bxplt$stats)[4], y1 = 1.3, code = 3, length = 0.1) # IQR 범위에 화살표 출력 text(x = -0.1, y = 1.3, labels = &quot;Interquartile range (IQR)&quot;, adj = 0.5, pos = 3) # boxplot() help(boxplot)을 통해 상세 함수 인수 내용 확인 boxplot(x, # boxplot 대상 객체 명 ... # 두 개 이상 객체(보통은 벡터) ) 또는 boxplot(formula, # 수식 표현 data, # 데이터 프레임 객체명 subset, # 부집단 선택 ... # help(boxplot)을 통해 인수 사용법 참고 ) 벡터, 행렬, 데이터 프레임, 리스트 객체에 적용 가능 데이터 프레임의 경우 수식 표현 가능 y ~ x: 변수 x (보통은 factor 형)에 따른 y y ~ x + y: 변수 x와 y의 조합에 따른 y par(mfrow = c(2, 2)) set.seed(20200522) y &lt;- rnorm(100, 2, 1) # vector 객체 boxplot boxplot(x, y, main = &quot;Boxplot for a vector object&quot;) axis(side = 1, at = 1:2, labels = c(&quot;x&quot;, &quot;y&quot;)) # 행렬 객체 boxplot head(X) [,1] [,2] [,3] [1,] 1.486720e-06 0.002215924 0.02156933 [2,] 1.562867e-06 0.002249385 0.02166383 [3,] 1.642751e-06 0.002283295 0.02175862 [4,] 1.726545e-06 0.002317658 0.02185368 [5,] 1.814431e-06 0.002352479 0.02194902 [6,] 1.906601e-06 0.002387763 0.02204463 boxplot(X, main = &quot;Boxplot for a matrix `X`&quot;) # 데이터 프레임 객체 boxplot boxplot(breaks ~ wool + tension, data = warpbreaks, main = &quot;Boxplot for a dataframe `warpbreaks`&quot;, col = topo.colors(6)) # 리스트 객체 boxplot ## list 생성: mapply set.seed(20200522) xl &lt;- mapply(rnorm, # 정규 난수 생성 함수 c(50, 100, 150, 200), # 첫번째 인수 n c(0, 2, 4, 6), # 두 번째 인수 mean c(1, 1, 1, 2)) # 세번째 인수 sd boxplot(xl, main = &quot;Boxplot for a list `xl`&quot;, col = &quot;lightgray&quot;) 12.2.8 바이올린 도표 상자그림과 유사하나, 가운데를 중심으로 왼쪽과 오른쪽에 데이터의 밀도(kernel density)를 표시 vioplot::viplot() boxplot()과 사용 방법이 유사 # install.packages(vioplot) # require(vioplot) ## generating bimodal distribution mu &lt;- 2; sigma &lt;- 1 set.seed(20200522) bimodal &lt;- c(rnorm(200, mu, sigma), rnorm(300, -mu, sigma)) # 두 정규분포 혼합 normal &lt;- rnorm(200, 2*mu, sigma) # 정규분포 unif &lt;- runif(200, -2, 2) # uniform 분포 (-2, 2) par(mfrow = c(2,2)) boxplot(bimodal, normal, unif, main = &quot;Boxplot for each distribution (vectors)&quot;) vioplot::vioplot(bimodal, normal, unif, main = &quot;Violin plot for each distribution (vectors)&quot;, col = &quot;skyblue&quot;) vioplot::vioplot(breaks ~ wool + tension, data = warpbreaks, main = &quot;Violin plot for a dataframe `warpbreaks`&quot;, col = heat.colors(6)) vioplot::vioplot(xl, data = warpbreaks, main = &quot;Violin plot for a list `xl`&quot;, col = rainbow(4)) 12.2.9 모자이크 도표 다변량 범주형 자료의 분포(빈도, frequency)를 시각화 하기 위한 그래프 전체 직사각형의 면적을 1이라고 할 때, 중첩되지 않는 각 셀의 빈도(행 기준)의 비율만큼 면적을 할당. 로그선형모형(log-linear model)에 대한 적합도 검정(goodness of fit test) 결과 출력 로그선형모형(log-linear model)은 다차원 교차표의 셀 빈도를 예측하기 위한 모형임. 해당 모형에 대한 기술은 본 강의의 범위 벗어나기 때문에 설명을 생략함. mosaicplot() R graphics 패키지(기본 그래픽 패키지)에 내장되어 있는 함수 기본적으로 table 객체(기본적으로 table()을 통해 생성된 객체)를 입력 데이터로 받음 수식 표현을 통해 모자이크 데이터 프레임(또는 리스트), 객체로부터 도출한 테이블로 도표 생성 가능(테이블 객체에도 수식 표현 가능) mosaicplot( x, # 테이블 객체 shade # goodness-of-test 결과 출력 여부 ... ) 또는 mosaicplot( formula, # 수식 표현식 data, # 데이터 프레임, 리스트 또는 테이블 shade ) 예시: 버클리 주립대 대학원 합격자 데이터 Simpson’s paradox를 설명하는 대표적인 예시로 많이 활용되는 데이터 dimnames(UCBAdmissions) $Admit [1] &quot;Admitted&quot; &quot;Rejected&quot; $Gender [1] &quot;Male&quot; &quot;Female&quot; $Dept [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; collapse_admin_tab &lt;- margin.table(UCBAdmissions, margin = c(1,2)) is.table(collapse_admin_tab) [1] TRUE par(mfrow = c(1, 2), mar = c(2, 0, 2, 0)) # figure margin 조정 # bottom, left, top, right mosaicplot(collapse_admin_tab, main = &quot;Student admissions at UC Berkeley&quot;, color = TRUE) mosaicplot(~ Dept + Admit + Gender, data = UCBAdmissions, color = TRUE) 각 학과 별 mosaic 도표(help(UCBAdmissions)의 예시 코드) par(mfrow = c(2, 3), oma = c(0, 0, 2, 0)) for (i in 1:6) { mosaicplot( UCBAdmissions[, , i], xlab = &quot;Admit&quot;, ylab = &quot;Sex&quot;, main = paste(&quot;Department&quot;, LETTERS[i]), color = TRUE ) } mtext( expression(bold(&quot;Student admissions at UC Berkeley&quot;)), outer = TRUE, cex = 1.2 ) "],["low-level-graphic.html", "12.3 저수준 그래프 함수", " 12.3 저수준 그래프 함수 고수준 그래픽 함수(일반적으로 plot() 함수)를 통해 호출한 그래픽 장치 위에 추가적인 그래프 요소(점, 선, 면, 문자, 범례 등)를 수동으로 추가 그래프의 미학적 효과를 극대화 하기 위해, 최소한으로 그래픽 장치를 호출(공백, 크기, 레이아웃 축 정의) 후 저수준 그래픽 함수를 이용해 그래프 생성 12.2.1 절 plot() 함수에서 확인했던 다양한 그래픽 관련 인수(예: main, xlim, ylim, pch lty, col 등)들을 저수준 그래프 함수에서 사용 가능 명시적으로 포함되지 않은(help() 통해 확인) 인수들은 ...로 표현되고, par() 함수 내 파라미터 값으로 전달 12.3.1 par() 전체 그래픽 장치에 적용되는 여러가지 파라미터를 제어하며, 고수준 및 저수준 그래프의 모양 및 미학적 특성 설정 par() 함수를 통해 그래픽 파라미터 설정 및 조회 가능 # 그래프 파라미터 조회 # 처음 12개 파라미터들에 대해서만 조회 unlist(par()) %&gt;% head(12) xlog ylog adj ann ask &quot;FALSE&quot; &quot;FALSE&quot; &quot;0.5&quot; &quot;TRUE&quot; &quot;FALSE&quot; bg bty cex cex.axis cex.lab &quot;transparent&quot; &quot;o&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; cex.main cex.sub &quot;1.2&quot; &quot;1&quot; # 파라미터 이름으로 값 추출 par(&quot;mar&quot;) [1] 5.1 4.1 4.1 2.1 par() 함수 조정 파라미터 리스트 Table 12.1: Parameter 값 설명 din, fin, pin = c(width, height) 그래픽 장치(device), figure, plot 영역 크기(너비: width, 높이: height) 조정(인치 단위) fig =c(left, right, bottom, top) 장치 내 figure 영역의 4개 좌표 조정을 통해 figure 위치 및 크기 조정 mai, mar = c(bottom, left, top, right) Figure 영역의 각 4개 마진의 크기 조정(인치 또는 현재 폰트 사이즈 기준 텍스트 길이 단위) mfcol,mfrow = c(row, column) 그래프 화면 출력을 열 또는 행 기준으로 분할 mfg =c(rows, columns) mfcol 또는 mfrow로 분할된 그림에서 figure의 위치 조정 new =TRUE or =FALSE 현재 figure 영역을 새 그래프 장치로 인지(TRUE 이면 이미 출력된 그림 위에 새로운 고수준 그래프 함수가 생성) 여부 oma,omd,omi =c(bottom, left, top, right) Outer margin (여백) 각 영역별 크기 조정(인치 또는 설정 텍스트 크기 기준) R 그래픽 레이아웃(그림 12.1 참조) 조정 파라미터 Figure 12.4: 레이아웃 파라미터. AIMS-R-Users 에서 발췌 아래 par() 함수의 파라미터 값에 대한 도표 생성을 위한 R 스크립트는 Graphical parameters of R graphics package에서 참고 및 발췌 pin 현재 plot의 차원(너비와 높이) 조정 fin Figure 영역의 차원(너비와 높이) fig c(x1, x2, y1, y2) 형태의 숫자형 벡터를 인수로 받아 그래픽 디바이스의 디스플레이 영역에서 figure 영역의 좌표 지정 처음 디폴트 값은 c(0, 1, 0, 1) fig 파라미터 조정의 목적이 여러 개의 그림을 한 화면에 출력하는 것이 목적이라면 par() 파라미터 중 new 의 값을 TRUE로 설정 text_loc &lt;- seq(0, 0.25, by = 0.05) par_name &lt;- c(&quot;mar&quot;, &quot;mai&quot;, &quot;fig&quot;, &quot;fin&quot;, &quot;plt&quot;, &quot;pin&quot;) plot_dim &lt;- function(x, y, op, title, ...) { for (i in 1:length(text_loc)) { text(x, y + text_loc[i], paste0(par_name[i], &quot; = c(&quot;, paste(round(op[[par_name[i]]]), collapse = &quot;, &quot;), &quot;)&quot;), adj = 0, ...) } text(x, y + text_loc[i] + 0.05, title, adj = 0) } # 1. plot area available when internal margins are 0 par(op) par(mai = c(0, 0, 0, 0), xaxs = &#39;i&#39;, yaxs = &#39;i&#39;) plot.new() abline(h = c(0.4, 0.9), v = c(0.4, 0.9), lty = 4) rect(0.4, 0.4, 0.9, 0.9, border = &quot;red&quot;) par(op) # 2. Plot new fig newfig &lt;- c(0.4, 0.9, 0.4, 0.9) par(fig = newfig, new = TRUE) op_reduced &lt;- par(no.readonly = TRUE) set.seed(12345) plot(runif(10), runif(10), typ = &#39;p&#39;, xlab = &#39;X&#39;, ylab = &#39;Y&#39;, xlim = c(0, 1), ylim = c(0, 1)) par(op) par(mai = c(0, 0, 0, 0), xaxs = &#39;i&#39;, yaxs = &#39;i&#39;, new = TRUE) # 3. Info about dimensions plot.new() plot_dim(0.05, 0.5, op_reduced, &quot;New plot dimension on the right&quot;, cex = 0.9) plot_dim(0.5, 0.05, op, &quot;Default plot dimensions&quot;, cex = 0.8) Figure 12.5: fig 인수 조정 예시: Graphical parameters of R graphics package에서 발췌 mar c(bottom, left, top, left) 형태의 수치형 벡터를 값으로 갖음 plot 영역 밖의 여백(figure 영역)을 line 수로 지정(아래 그림 참고) 디폴트 값은 c(5, 4, 4, 2) + 0.1 임 Figure 12.6: Figure 영역에서 기본 여백: Graphical parameters of R graphics package 에서 발췌 mfcol, mfrow c(nrow, ncol) 형태의 2차원 수치형 벡터를 값으로 갖음 앞의 예제에서 확인한 바와 같이 각 행과 열 별로 행 기준 또는 열 기준으로 다중 그래프를 한 화면에 출력 정방형 그래프로 분할하며 c(2, 2)인 경우 텍스트 크기는 cex 값 기준 0.83배 감소 par(oma = c(0, 0, 3, 0), # 윗쪽 여백 크기 조정 mfrow = c(3, 2)) for (i in 1:6) { set.seed(12345) plot(rnorm(20), rnorm(20), main = paste(&quot;Plot&quot;, i)) box(&quot;figure&quot;) } # 윗쪽 여백(side=3)에 텍스트 출력 mtext(side = 3, line = 1, cex = 0.8, col = &quot;blue&quot;, &quot;Muptiple plots with mfrow = c(2, 3)&quot;, outer = TRUE) # outer 여백 사용 여부 par(oma = c(0, 0, 3, 0), mfcol = c(3, 2)) for (i in 1:6) { set.seed(12345) plot(rnorm(20), rnorm(20), main = paste(&quot;Plot&quot;, i)) box(&quot;figure&quot;) } mtext(side = 3, line = 1, cex = 0.8, col = &quot;blue&quot;, &quot;Muptiple plots with mfcol = c(3, 2)&quot;, outer = TRUE) mfg c(i, j) 형태의 숫자형 벡터의 값 mfcol 또는 mfrow 파라미터로 그림 배열이 정해진 상태에서 어떤 그림이 다음에 드려지는지를 지정 c(1,1)은 차원과 상관 없이 맨 처음 출력한 그래프가 생성 df_order &lt;- expand.grid(x = 1:2, y = 1:3) set.seed(123) idx &lt;- sample(2:6, nrow(df_order)-1) df_order &lt;- df_order[c(1,idx), ] par(mfrow = c(2, 3), oma = c(0, 0, 3, 0)) for (i in 0:5) { set.seed(123) par(mfg = as.numeric(df_order[i+1, ])) plot(rnorm(20), rnorm(20), main = paste(&quot;Plot&quot;, i+1)) box(&quot;figure&quot;) } mtext(side = 3, line = 1, cex = 0.8, col = &quot;blue&quot;, &quot;Multiple plots by row: order in mfrow changed by mfg parameter.&quot;, outer = TRUE) mfrow와 mfcol 유사함수: layout(), split.screen() layout(): 행렬 객체를 인수로 받아 화면 분할 # mtcars 데이터셋 graph_array &lt;- matrix(c(1, 1, 2, 3), nrow = 2, byrow = TRUE) par(oma = c(0, 0 , 3, 0)) layout(mat = graph_array) plot(mpg ~ disp, # 데이터 프레임인 경우 수식 표현도 가능 data = mtcars, main = &quot;layout 1&quot;) hist(mtcars$disp, main = &quot;layout 2&quot;) hist(mtcars$mpg, main = &quot;layout 3&quot;) mtext(side = 3, line = 1, cex = 1, col = &quot;blue&quot;, &quot;c(1, 1): scatter plot, c(2) = histogram: dsip, c(3) = histogram: mpg&quot;, outer = TRUE) split.screen(): layout()과 유사하게 그래프의 화면을 분할하고 더 많은 기능을 제공 screen(): 분할된 화면 지정 erase.screen(): 지정된 화면의 그래프 삭제 split.screen(fig = c(2, 2)) # 화면을 2 by 2로 분할 [1] 1 2 3 4 par(oma = c(0, 0, 3, 0)) screen(n = 4) vioplot::vioplot(mpg ~ cyl, data = mtcars, main = &quot;screen n = 4&quot;) screen(n = 1) hist(mtcars$mpg, main = &quot;screen n = 1&quot;) screen(n = 3) plot(mpg ~ wt, data = mtcars, main = &quot;screen n = 3&quot;) screen(n = 2) boxplot(mpg ~ gear, data = mtcars, main = &quot;screen n = 2&quot;) mtext(side = 3, line = 1, cex = 0.8, col = &quot;blue&quot;, &quot;Split using split.screen()&quot;, outer = TRUE) new 논리값(TRUE 또는 FALSE) 지정 디폴트 값은 FALSE 새로운 그래프를 이미 존재하는 그래프 장치에 출력 # boxplot + violin plot ## iris 데이터 셋 par(bty = &quot;n&quot;) # x-y 축 스타일 지정 boxplot(Sepal.Length ~ Species, data = iris) new_fig &lt;- c(0.05, 0.46, 0.4, 0.99) par(new = TRUE, fig = new_fig) vioplot::vioplot(Sepal.Length ~ Species, data = iris, col = &quot;skyblue&quot;, yaxt = &quot;s&quot;, ann = FALSE) oma c(bottom, left, top, right) 형태의 숫자형 벡터 값 사용 Outer 여백의 크기 조정(텍스트 라인 기준) 아래 예시는 oma = c(2, 3, 3, 1) 인 경우 여백 표시 Figure 12.7: Outer 여백 조정 파라미터(mar = c(2, 3, 3, 1)) Graphical parameters of R graphics package에서 발췌 12.3.2 points() 점을 그리는 저수준 그래프 함수로 이미 출력된 x-y 좌표 위에 지정한 점 문자 출력 x-y 좌표 지정은 plot() 함수와 동일 많이 사용되는 점 문자 기호(symbol)은 그림 12.3 참고 # cars 데이터셋 par(mfrow = c(1, 2)) plot(dist ~ speed, data = cars, type = &quot;n&quot;, bty = &quot;n&quot;, main = &quot;points() function example 1: cars dataset&quot;) points(cars$speed, cars$dist, pch = 16, col = &quot;darkgreen&quot;, cex = 1.5) shapes &lt;- 15:17 # pch 지정 plot(Petal.Length ~ Sepal.Length, data = iris, type = &quot;n&quot;, bty = &quot;n&quot;, main = &quot;points() function example 2: iris dataset&quot;) points(iris$Sepal.Length, iris$Petal.Length, pch = shapes[as.numeric(iris$Species)], # 각 Species에 대해 shapes 할당 col = as.numeric(iris$Species), cex = 1.5) 12.3.3 lines() x-y 좌표의 점을 이어 선을 만드는 함수 plot() 함수에서 type 인수에 “l”을 사용한 것과 유사 선의 모양(lty)과 굵기(lwd)를 지정할 수 있으며 그림 12.2와 그림 12.8를 참고 Figure 12.8: 선 두께(lwd) 파라미터: Graphical parameters of R graphics package 에서 발췌 line() 함수 사용 예시: 정규분포 분포 그리기 # 정규분포 평균=0, 분산=1 # 정규분포 평균=0, 분산=2 # 정규분포 평균=0, 분산=3 par(mar = c(3, 0, 3, 0)) x &lt;- seq(-5, 5, 0.01) y &lt;- mapply(dnorm, list(x, x, x), c(0, 0, 0), c(1, sqrt(2), sqrt(3))) plot(x, y[,1], type = &quot;n&quot;, bty = &quot;n&quot;, yaxt = &quot;n&quot;, ann = FALSE, xlim = c(-5, 5)) lines(c(0, 0), c(0, max(y[,1])), lty = 2, col = &quot;lightgray&quot;) lines(x, y[,1], lty = 1, lwd = 2, col = &quot;black&quot;) lines(c(0.3, 2), rep(max(y[,1]), 2), lty = 1, col = &quot;gray&quot;) text(2.1, max(y[,1]), expression(paste(mu == 0, &quot;,&quot; ~~ sigma == 1)), # 수식 표현 adj = 0) lines(x, y[,2], lty = 2, lwd = 2, col = &quot;blue&quot;) lines(c(0.3, 2), rep(max(y[, 2]), 2), lty = 1, col = &quot;gray&quot;) text(2.1, max(y[,2]), expression(paste(mu == 0, &quot;,&quot; ~~ sigma == 2)), # 수식 표현 adj = 0) lines(x, y[,3], lty = 3, lwd = 2, col = &quot;green&quot;) lines(c(0.3, 2), rep(max(y[,3]), 2), lty = 1, col = &quot;gray&quot;) text(2.1, max(y[,3]), expression(paste(mu == 0, &quot;,&quot; ~~ sigma == 3)), # 수식 표현 adj = 0) mtext(&quot;Normal distribution&quot;, side = 3, adj = 0.2, cex = 2) 12.3.4 ablines() x-y 좌표에 직선을 그리는 함수로 lines() 함수와 유사하나 y 절편과 x 기울기, 또는 x 절편(y 축과 평행한 직선, (x, 0))과 y 절편(x축과 평행한 직선, (0, y))을 이용해 직선을 그릴 수 있음 a: y 절편 b: x 기울기 h: x축과 수평선(y 값) v: x축과 수직선(y축과 수평선, x 값) # 회귀직선과 x, y의 평균선, 회귀직선으로부터 각 점 까지 거리를 직선 표시 ## mtcars 데이터 plot(mpg ~ hp, data = mtcars, type = &quot;n&quot;, bty = &quot;n&quot;, xlim = c(50, 350), ylim = c(5, 40), main = &quot;abline() examples with mtcars dataset&quot;, xlab = &quot;Horse power&quot;, ylab = &quot;Miles/gallon&quot;, cex.main = 1.5) m &lt;- lm(mpg ~ hp, data = mtcars) # 일변량 회귀모형 yhat &lt;- predict(m) # 회귀모형의 예측값 # 회귀직선으로부터 각 관측점 까지 거리(오차) 직선 표시 함수 dist_error &lt;- function(i) { lines(c(mtcars$hp[i], mtcars$hp[i]), c(mtcars$mpg[i], yhat[i]), col = &quot;green&quot;, lwd = 0.8, lty = 1) } for (i in 1:nrow(mtcars)) dist_error(i) with(mtcars, points(hp, mpg, pch = 16, cex = 1)) abline(m, lty = 1, lwd = 3, col = &quot;red&quot;) abline(h = mean(mtcars$mpg), lty = 2, col = &quot;darkgray&quot;) # mpg 평균 abline(v = mean(mtcars$hp), lty = 2, col = &quot;darkgray&quot;) # hp 평균 text(mean(mtcars$hp), 40, # text 수식 표현 참고 bquote(paste(bar(x) == .(sprintf(&quot;%.1f&quot;, mean(mtcars$hp))))), adj = 0, pos = 4) text(350, mean(mtcars$mpg), bquote(paste(bar(x) == .(sprintf(&quot;%.1f&quot;, mean(mtcars$mpg))))), pos = 3) Figure 12.9: abline(), lines() 함수를 이용한 회귀직선 및 오차 거리 표시 예제 12.3.5 arrows() 화살표를 그리는 함수 x0, y0, x1, y1 형태의 숫자를 값으로 사용 (x0, y0): 시작점 좌표 (x1, y1): 끝점 좌표 angle, length, code 인수 조정을 통해 화살표 스타일 지정 par(mar = rep(0, 4)) plot(1, 1, type = &#39;n&#39;, axes = FALSE, ann = FALSE, xaxs = &#39;i&#39;, yaxs = &#39;i&#39;, xlim = c(0,11), ylim = c(0,11)) text(5.5, 10.5, &quot;Type of arrows by values of angle, length, and codes&quot;, font = 2, # 2=bold, 3=italic, 4=bold italic adj = c(0.5, 0), cex = 1.5) angle_val &lt;- c(60, 90, 120) length_val &lt;- c(0.25, 0.1, 0.5) code_val &lt;- c(0, 1, 3) for (i in 1:3) { arrows(1, 9-i+1, 5, 9-i+1, length = length_val[i]) text(6, 9-i+1, pos = 4, sprintf(&quot;angle = 30, length = %.2f, code = 2&quot;, length_val[i])) } for (i in 1:3) { arrows(1, 6-i+1, 5, 6-i+1, length = 0.25, angle = angle_val[i]) text(6, 6-i+1, pos = 4, sprintf(&quot;angle = %d, length = 0.25, code = 2&quot;, angle_val[i])) } for (i in 1:3) { arrows(1, 3-i+1, 5, 3-i+1, length = 0.25, angle = 30, code = code_val[i]) text(6, 3-i+1, pos = 4, sprintf(&quot;angle = 30, length = 0.25, code = %d&quot;, code_val[i])) } Figure 12.10: arrows() 함수 주요 파라미터 변경에 따른 화살표 출력 결과 12.3.6 rect() x-y 좌표 위에 사각형을 그리는 함수 xleft: 사각형의 왼쪽 x 좌표 ybottom: 사각형의 아래쪽 y 좌표 xright: 사각형의 오른쪽 x 좌표 ytop: 사각형의 위쪽 y 좌표 # 길이와 높이가 5인 정사각형 그리기 plot(x = 1:10, y = 1:10, type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;Rectangle coordinates used in rect()&quot;) rect(3, 3, 8, 8, density = 10, # 사각형 내부를 선으로 채움 angle = 315) # 내부 선의 기울기 각도(degree) text(3, 3, &quot;(xleft = 3, ybottom = 3)&quot;, adj = 0.5, pos = 1) text(8, 3, &quot;(xright = 8, ybottom = 3)&quot;, adj = 0.5, pos = 1) text(8, 8, &quot;(xright = 8, ytop = 8)&quot;, adj = 0.5, pos = 3) text(3, 8, &quot;(xleft = 3, ytop = 8)&quot;, adj = 0.5, pos = 3) grid() Figure 12.11: rect() 좌표 인수 12.3.7 polygon() x-y 좌표의 점을 연결해 폐 다각형을 만드는 함수 좌표 지정 방법은 plot() 함수와 동일 # polygon() 사용 예시 plot(x = 0:10, y = 0:10, type = &quot;n&quot;, bty = &quot;n&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;Polygon examples&quot;) # Pentagon theta1 &lt;- seq(-pi, pi, length = 6) x &lt;- cos(theta1 + 0.5*pi) # cosine 함수 y &lt;- sin(theta1 + 0.5*pi) x1 &lt;- 2*x + 2; y1 &lt;- -2*y + 7 polygon(x1, y1) text(2, 9.2, &quot;Pentagon&quot;, adj = 0.5, pos = 3, cex = 1.5) # Octagon theta2 &lt;- seq(-pi, pi, length = 9) x &lt;- cos(theta2) # cosine 함수 y &lt;- sin(theta2) x2 &lt;- 2*x + 7; y2 &lt;- -2*y + 7 polygon(x2, y2, col = &quot;#05B8FF&quot;, border = &quot;black&quot;, lwd = 4) text(7, 9.2, &quot;Octagon&quot;, adj = 0.5, pos = 3, cex = 1.5) # 별표시 x2 &lt;- c(2, 4/3, 0, 2/3, 0, 4/3, 2, 8/3, 4, 10/3, 4, 8/3) y2 &lt;- c(4, 3.0, 3, 2.0, 1, 1.0, 0, 1.0, 1, 2.0, 3, 3.0) polygon(x2, y2, density = 20, angle = 135, lty = 1, lwd = 2) text(2, 4.1, &quot;Star (Jewish)&quot;, adj = 0.5, pos = 3, cex = 1.5) # Triangle (perpendicular) x3 &lt;- c(5, 9, 5) y3 &lt;- c(0, 0, 4) polygon(x3, y3, lwd = 3, col = &quot;gray&quot;) x4 &lt;- c(5, 5.3, 5.3, 5) y4 &lt;- c(0, 0.0, 0.3, 0.3) polygon(x4, y4, lwd = 3) # 직각표시 text(7, 4.1, &quot;Triangle (perpendicular)&quot;, adj = 0.5, pos = 3, cex = 1.5) 확률분포 아래 면적 표시 \\(Z ~ \\stackrel{i.i.d}{\\sim} N(0, 1)\\) 라고 할 때 \\(P(-1.5 &lt; Z &lt; 0.7)\\)에 해당하는 부분 표시 # 표준정규분포 곡선 하 면적 표시 x &lt;- seq(-3, 3, by = 0.01) z &lt;- dnorm(x) plot(x, z, type = &quot;n&quot;, bty = &quot;n&quot;, xlab = expression(bold(Z)), ylab = &quot;Density&quot;, main = &quot;Standard normal distribution&quot;) idx &lt;- x &gt; -1.5 &amp; x &lt; 0.7 # 해당 구간 index 설정 polygon(c(-1.5, x[idx], 0.7), c(0, z[idx], 0), col = &quot;green&quot;, border = &quot;green&quot;) lines(x, z, lty = 1, lwd = 2) text(x = 0.5, y = 0.15, bquote(P({-1.5 &lt; Z} &lt; 0.7 ) == .(sprintf(&quot;%.3f&quot;, pnorm(0.7) - pnorm(-1.5)))), # pnorm = P(Z &lt;= c), 평균=0, 분산=1 인 경우 adj = 1) Figure 12.12: polygon()을 이용한 확률밀도함수 곡선 아래 면적 표시 예시 12.3.8 text(), mtext() text(): x-y 좌표에 문자열을 입력하는 함수 text(x, # x-좌표값 y, # y-좌표값 label, # 입력할 텍스트 문자열 adj, # 원점 좌표를 기준으로 텍스트 문자열 자리 맞춤 # 0 - 1 사이 값은 수평 맞추기 지정 # 0=오른쪽, 0.5=가운데 정렬, 1=왼쪽 정렬 (원점 기준) pos, # adj를 단순화하여 텍스트 자리 맞춤 # 1=bottom, 2=left, 3=top, 4=right, srt # 문자열 회전(in degree) ... ) Figure 12.13: text() 함수에서 adj 파라미터 값에 따른 텍스트 위치: AIMS-R-users 에서 발췌 Figure 12.14: text() 함수에서 pos 파라미터 값에 따른 텍스트 위치: AIMS-R-users 에서 발췌 Figure 12.15: text() 함수에서 srt 파라미터 값에 따른 텍스트 위치: AIMS-R-users 에서 발췌 mtext(): plot 여백 또는 outer 여백 상에 문자를 출력하는 함수 mtext( text, # 입력할 텍스트 문자열 side, # 텍스트 문자열이 출력되는 여백 지정 # 1=bottom, 2=left, 3=top, 4=right line, # 지정 여백에서 텍스트 출력 위치 지정 outer, # outer 여백 사용 여부 at, # line 내에서 텍스트 열 위치(좌표축 기준) 지정 adj, # text() 함수의 adj 파라미터와 동일 ... ) par(mar = c(4, 4, 4, 4), oma = c(4, 0, 0, 0)) set.seed(1345) plot(rnorm(20), type = &quot;o&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) # side = 3 (top), line=0, 1, 2, 3 변경 for (i in 0:4) { mtext(paste(&quot;Side = 3, line =&quot;, i), side = 3, line = i) } # side = 3 (top), outer 여백 사용, line=0, 1, 2, 3 변경 for (i in 0:4) { mtext(paste(&quot;Side = 1, outer = TRUE, line =&quot;, i), side = 1, line = i, outer = TRUE) } # adj 인수 조정 adj_par &lt;- c(0, 0.5, 1) for (i in 1:3) { mtext(sprintf(&quot;Side = 1, line = %d, adj = %.1f&quot;, i, adj_par[i]), side = 1, line = i, adj = adj_par[i]) } # side = 2 (left) for (i in 1:3) { mtext(sprintf(&quot;Side = 2, line = %d, adj = %.1f&quot;, i, adj_par[i]), side = 2, line = i, adj = adj_par[i]) } # side = 4 (right), at 조정 at_val &lt;- c(-1, 0, 1) for (i in 1:3) { mtext(sprintf(&quot;Side = 4, line = %d, at = %.1f&quot;, i, adj_par[i]), side = 4, line = i, at = at_val[i]) } mtext(&quot;mtext parameter check&quot;, col = &quot;blue&quot;, cex = 0.8, line = 0, adj = 0) 12.3.9 legend() 범례(legend)를 생성하는 함수로 그래프에 표시된 점, 선, 또는 색에 해당되는 정보를 설명하기 위해 이용 legend() 함수에서 범례 위치 지정 방법 x-y 좌표 이용 위치를 나타내는 문자 이용: bottomright, right, topright, top, topleft, left, bottomleft, bottom plot(Petal.Length ~ Sepal.Length, data = iris, type = &quot;n&quot;, bty = &quot;n&quot;, main = &quot;points() function example 2: iris dataset&quot;) points(iris$Sepal.Length, iris$Petal.Length, pch = shapes[as.numeric(iris$Species)], # 각 Species에 대해 shapes 할당 col = as.numeric(iris$Species), cex = 1.5) legend(&quot;bottomright&quot;, legend = unique(iris$Species), pch = 15:17, col = 1:3) legend(4.5, 6, legend = unique(iris$Species), pch = 15:17, col = 1:3) legend(&quot;top&quot;, legend = unique(iris$Species), pch = 15:17, col = 1:3, pt.cex = 3, # legend 점 크기 조정 ncol = 3) # # legend 영역 열 개수 지정 12.3.10 수식 표현 그래프 상 수식은 expression(), bquote(), substitute() 함수로 표현 가능 TeX14과 유사한 수식 형태를 표현하기 위해 복잡한 표현식들이 사용됨 \\(\\rightarrow\\) 아래 표 참고(demo(plotmath)를 통해 동일한 표 출력 가능) Figure 12.16: R expression() 함수 내 수식 표현 방법 Greek letters Figure 12.17: R 그리스 문자 표현 expression(): 문자 TeX 형태와 유사한 기호 및 표현을 이용해 수식 표현 bquote(): .() 안에 있는 표현을 먼저 평가 한 후 그 값을 변환해 수식 표현식 안에 들어가는 값으로 사용 \\(\\rightarrow\\) 그림 12.9, 그림 12.12 예시 및 스크립트 참고 두 함수 모두 paste() 함수와 같이 사용 하는 것이 일반적인 수식과 문자 표현 방법임. # 수식 표현 예시 expression() + paste() par(cex = 1.5 , cex.lab = 1.2) set.seed(202005) x &lt;- rnorm(10, 25, 3) y &lt;- rnorm(10, 25, 3) plot(x, y, type = &quot;p&quot;, axes = TRUE, ann = FALSE, bty = &quot;n&quot;) mtext(expression(paste(&quot;Temperature&quot;, ~(degree*C))), side = 1, line = 3, cex = 1.5) mtext(expression(paste(&quot;Respiration&quot;, ~(mL ~O[2] ~ h^-1))), side = 2, line = 3, cex = 1.5) par(cex = 1.5) plot(0:6, 0:6, type = &quot;n&quot;, bty = &quot;o&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, ann = FALSE) text(0.3, 5.8, &quot;Normal distribution:&quot;, adj = 0) text(0.3, 4.8, expression(paste(f, &quot;(&quot;, x, &quot;;&quot;, list(mu, sigma), &quot;)&quot; == frac(1, sigma*sqrt(2*pi))*~~exp * bgroup(&#39;(&#39;, -frac((x-mu)^2, 2*sigma^2), &#39;)&#39;) )), adj = 0) text(4, 5.8, &quot;Binomial distribution:&quot;, adj = 0) text(4, 4.8, expression(paste(f, &quot;(&quot;, x, &quot;;&quot;, list(n, p), &quot;)&quot; == bgroup(&quot;(&quot;, atop(n, x) ,&quot;)&quot;) *p^x*(1-p)^{n-x})), adj = 0) text(0.3, 3.5, &quot;Matrix:&quot;, adj = 0) text(0.3, 2.5, expression(bold(X) == bgroup(&quot;[&quot;, atop(1 ~~ 2 ~~ 3, 4 ~~ 5 ~~ 6), &quot;]&quot;)), adj = 0) text(2, 3.5, &quot;Multiple regression formula:&quot;, adj = 0) text(2, 2.5, expression(paste(y[i] == beta[0] + beta[1]*x[1] + beta[2]*x[2] + epsilon[i]~~ &quot;where&quot;, ~~i == list(1, ldots, n))), adj = 0) text(2, 1.5, &quot;Regression equation:&quot;, adj = 0) text(2, 0.5, expression(hat(bold(beta)) == bgroup(&quot;(&quot;, bold(X)^T*bold(X), &quot;)&quot;)^-1*bold(X)^T*bold(y)), adj = 0) Figure 12.18: R 그래픽 수식 표현 예시 12.3.11 R 기본 그래프 이미지 파일로 저장 12.1 절 R 기본 그래프 함수에서 언급한 그래픽 파일에 해당하는 함수로 그래픽 장치를 먼저 연 다음 그래프 생성 후 저장 # save-example.png에 cars 산점도 저장 png(&quot;figures/save-example.png&quot;) plot(cars) dev.off() pdf 2 "],["ggplot2-package.html", "12.4 ggplot2", " 12.4 ggplot2 Prerequisites: tidyverse 패키지 또는 ggplot2 패키지 읽어오기: require(tidyverse) 또는 require(ggplot2) 실행 데이터에 대한 그래프는 데이터의 속성(수치형, 범주형)과 시각적 속성(점, x-y 좌표 위치, 선, 색상, 막대의 높이) 간에 대응 또는 매핑(mapping) 으로 이루어짐 R 에서 가장 유명한 데이터 시각화 패키지 중 하나로 2005년 Hadley Wickham이 개발 및 배포 Leland Wilkinson 의 grammar of graphics (Wilkinson 2012) 를 구현 Grammar of graphics: 그래프를 구현하기 위한 일관적인 체계로 그래프를 데이터, 스케일, 레이어, 좌표 등과 같은 의미론적 요소(sementic components) 로 나눔 ggplot의 grammar of graphics Figure 12.19: ggplot의 grammar of graphics 주요 구성 요소 R 기본 graphics 패키지의 경우 데이터 속성을 시각적 속성으로 매핑 시 매 경우가 고유한 작업이고, 매핑이 변경될 경우 데이터를 재구성하거나 완전히 다른 plotting 함수를 적용해야 함. R base graphics와 ggplot의 비교 # R 기본 데이터셋: ToothGrowth ToothGrowth %&gt;% group_by(supp, dose) %&gt;% summarise(mean = mean(len)) %&gt;% mutate(dose = factor(dose, ordered = TRUE))-&gt; tg_long `summarise()` has grouped output by &#39;supp&#39;. You can override using the `.groups` argument. tg_long %&gt;% spread(supp, mean) %&gt;% column_to_rownames(&quot;dose&quot;) %&gt;% # 열 값을 열이름으로 변환(in tibble 패키지) as.matrix -&gt; tg_mat # R graphics: barplot() 사용 barplot(tg_mat, beside = TRUE) Figure 12.20: R 기본 barplot() 생성 그래프 dose 별 OJ와 VC 막대도표: dose로 그룹화를 하기 위해 데이터 구조 변경(전치) 필요 # tg_mat 행렬 전치 barplot(t(tg_mat), beside = TRUE) Figure 12.21: R 기본 barplot() 생성 그래프: 데이터 전치 막대 대신 선(line)으로 표현 plot(tg_mat[,1], type=&quot;l&quot;, col = &quot;blue&quot;) lines(tg_mat[,2], type=&quot;l&quot;, col = &quot;black&quot;) Figure 12.22: R 기본 선 그래프: plot(), lines() 함수 사용 plot() 함수 호출 시 y 축 범위가 첫 번째 선에 대해서만 설정 x 축이 범주 대신 번호가 사용 ggplot 사용: 데이터 프레임에만 적용 가능(데이터 구조는 long-format) # require(ggplot2) ggplot(data = tg_long, aes(y = mean)) -&gt; gmap # 기본 mapping 유지를 위해 # ggplot 클래스 객체 저장 gmap + geom_bar(aes(x = supp, fill = dose), stat = &quot;identity&quot;, # 데이터 고유값을 막대 높이로 사용 position = &quot;dodge&quot;) # 막대 위치 조정(beside 조건과 유사) Figure 12.23: ggplot()과 geom_bar()을 이용한 막대 도표 데이터 구조를 변경하지 않고 ggplot의 매핑 변수 변경 gmap + geom_bar(aes(x = dose, fill = supp), stat = &quot;identity&quot;, position = &quot;dodge&quot;) Figure 12.24: x와 fill의 mapping 변경 ggplot을 이용한 선 도표 생성 gmap + geom_line(aes(x = dose, group = supp, color = supp), size = 1) Figure 12.25: geom_line()을 이용한 선 그래프 생성 기본 그래프 함수를 이용해 막대도표 대신 선 도표 생성 시 완전히 다른 명령 사용 선 그래프 생성 시 기본 그래프는 하나씩 도표를 추가한 반면, geom_line()의 경우 모든 선이 한번에 그려짐 12.4.1 기본 문법 ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) + &lt;SCALE_FUNCTION&gt; + &lt;LABEL or GUIDES&gt; + &lt;ANNOTATION&gt; + &lt;THEME&gt; 용어(terminology) data: 시각화의 대상으로 관측값과 변수(열)로 이루어짐 geom: 데이터의 값을 시각적으로 보여주기 위한 레이어로 막대, 선, 점과 같은 기하학적 객체 aesthetic: geom의 시각적 속성을 정의하며, x, y 위치, 선 색상, 점 모양 등을 정의 mapping: 데이터 값을 asthetic에 매핑 scale: asthetic에 매핑 시 세부 값들을 제어 guide: 그래프 해석에 도움을 주는 속성으로 x-y 축의 눈금, 레이블, 범례(legend)를 포함 annotation: 생성한 그래프 위에 추가적인 정보(선, 화살표, 텍스트, 도형 등) 추가 theme: 그래프의 비데이터적 요소(제목, 레이블, 글꼴, 배경색, 격자, 범례 등) 제어를 통해 그래프의 미적 효과 극대화 ggplot 계열 함수에서 범주형 변수(categorical variable)은 이산형(discrete), 수치형 변수(numeric variable)을 연속형(continuous)이라고 명칭함. ggplot 그래프 생성 기본 단계(각 단계(layer)는 + 연산자로 덧붙혀짐) ggplot()으로 ggplot 객체 초기화 aes() 함수로 x-y 축 지정 geom 계열 함수로 데이터를 시각적 요소로 매핑. 이때 aes() 함수와 같이 색상, 크기 등 지정 scale 계열 함수를 이용해 asthetic의 세부 값을 조정 축 제목, 레이블, 범례 설정 조정 필요 시 theme 조정을 통해 시각적 요소 가미 ggplot(): ggplot 객체를 생성하는 함수로 시각화할 데이터가 무엇인지, 그리고 데이터에 포함된 변수들이 어떤 asthetic에 매핑되는지를 선언 aes(): 데이터 내 변수들이 어떤 geoms 레이어에서 어떤 시각적 속성을 갖는지를 지정해주는 함수로 ggplot() 함수 내, 혹은 독립적인 레이어로 추가 가능 ggplot에서 지정한 데이터 내에서 평가되기 때문에 변수명 지정 시 원래 데이터셋 참조할 필요 없음(예: ggplot(data = car, aes(x = speed))) # ggplot()을 이용한 ggplot 생성 # 표현식 1 ggplot(data = &lt;DATA&gt;, # 데이터 프레임, 티블 객체 mapping = aes(x = &lt;X-axis&gt;, y = &lt;Y-axis&gt;, color = &lt;색 속성을 부여할 변수 이름&gt;, fill = &lt;면의 색 속성을 부여할 변수 이름&gt;, group = &lt;group 변수 지정&gt; # 보통 선 그래프 작성 시 이을 선에 대한 # 그룹을 지정하기 위해 사용 group ...)) + &lt;GEOM_FUNCTION&gt; # 표현식 2 ggplot(data = &lt;DATA&gt;) + aes(...) + &lt;GEOM_FUNCTION&gt;(mapping = aes(...)) # 표현식 3 ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(x, y, ...)) # 표현식 4 &lt;GGPLOT_OBJECT&gt; &lt;- ggplot(data = &lt;DATA&gt;) &lt;GGPLOT_OBJECT&gt; + &lt;GEOM_FUNCTION&gt;(mapping = aes(...)) # cars 데이터셋 ## ggplot() 내에 aes() 지정 ggplot(data = cars, aes(x = speed, y = dist)) + geom_point() ## aesthetic을 ggplot() 함수 밖에서 지정 ggplot(data = cars) + aes(x = speed, y = dist) + geom_point() ## geom 계열 함수 내에서 asthetic 지정 ggplot(data = cars) + geom_point(aes(x = speed, y = dist)) ## ggplot 객체 생성 gp &lt;- ggplot(data = cars); gp gp &lt;- gp + aes(x = speed, y = dist); gp gp + geom_point() ## 참고: R 기본 plot()의 결과는 객체로 저장되지 않음 grph &lt;- plot(cars); grph 주요 aesthetics x, y: x-y 축에 해당하는 변수명. x와 y의 이름은 생략 가능(예: ggplot(data = car, aes(speed, dist)로도 사용 가능)) color: 점, 선, 텍스트 색상 fill: 면(막대, 상자, 도형 등) 색상 alpha: 색상의 투명도 group: 시각화에 사용할 데이터의 그룹 size: 점, 선, 텍스트의 크기 또는 굵기 shape: 점의 모양(그림 12.3 참고). R 기본 그래픽 파라미터 pch와 호환 linetype: 선의 형태 지정하며 그림 12.3 의 선 형태 지정 방법 준용(숫자, 문자열 모두 사용 가능) 색상 관련 aesthetics: color, fill, alpha aes() 함수 내부 또는 외부에서 인수 조정 가능(함수 내부: 변수명으로 지정, 함수 외부: 특정 값으로 지정) # 막대도표 예시 # `aes()` 함수 외부에서 사용 시 단일 값을 입력 gpcol &lt;- ggplot(data = mpg, aes(x = class)) gpcol + geom_bar() + labs(title = &quot;Default geom_bar()&quot;) # 그래프 제목 지정 gpcol + geom_bar(fill = &quot;navy&quot;) + labs(title = &quot;fill = &#39;navy&#39;&quot;) # 막대도표 예시 gpcol + geom_bar(color = &quot;red&quot;) + labs(title = &quot;color = &#39;red&#39;&quot;) gpcol + geom_bar(color = &quot;red&quot;, fill = &quot;white&quot;)+ labs(title = &quot;color = &#39;red&#39;, fill = &#39;white&#39;&quot;) # 연료 타입에 따라 면 색 지정 gpcol + geom_bar(aes(fill = fl)) + labs(title = &quot;Filled by fuel types (fl)&quot;) # 연료 타입에 따라 막대 선 색 지정 gpcol + geom_bar(aes(color = fl)) + labs(title = &quot;Colored by fuel types (fl)&quot;) # alpha: 0-1 사이 값을 갖고 투명도 지정 # 주로 aes() 함수 밖에서 사용됨 set.seed(20200605) df1 &lt;- tibble( x = rnorm(5000), y = rnorm(5000) ) gpalpha &lt;- ggplot(data = df1, aes(x, y)) gpalpha + geom_point() + labs(title = &quot;alpha = 1&quot;) gpalpha + geom_point(alpha = 0.1) + labs(title = &quot;alpha = 0.1&quot;) 그룹(group) aesthetic 기본적으로 aes() 내부에서 aesthetic에 대응하는 변수가 이산형(범주형) 변수로 정해짐 보통은 color, shape, linetype 으로 그룹 지정이 가능하지만 충분하지 않은 경우 group 인수 값 지정 # 다중 집단에 하나의 aesthetic만 적용한 경우 ## gapminder 데이터셋 gapm &lt;- read_csv(&quot;dataset/gapminder/gapminder_filter.csv&quot;) gapm_filter &lt;- gapm %&gt;% filter(grepl(&quot;Asia&quot;, region)) gpgroup &lt;- ggplot(data = gapm_filter, aes(x = year, y = life_expectancy)) gpgroup + geom_line(size = 0.5, alpha = 0.2) gpgroup_l &lt;- gpgroup + geom_line(aes(group = country), size = 0.5, alpha = 0.2) gpgroup_l # 전체 아시아 국가의 평균 추세선 ## geom_line과 geom_smooth 모두 group을 country로 지정 gpgroup_l + geom_smooth(aes(group = country), method = &quot;loess&quot;, size = 0.5, color = &quot;blue&quot;, se = FALSE) ## 모든 국가에 가장 적합한 하나의 곡선으로 fitting gpgroup_l + geom_smooth(aes(group = 1), method = &quot;loess&quot;, size = 1, color = &quot;blue&quot;, se = FALSE) 크기(size), 점 모양(shape), 선모양(linetype) aesthetic # size 지정 gpsize &lt;- ggplot(data = mtcars, aes(disp, mpg)) gpsize + geom_point(size = 4) gpsize + geom_point(aes(size = hp), alpha = 0.5) gpshape &lt;- ggplot(data = mtcars, aes(hp, mpg)) gpshape + geom_point(shape = 5) # # 실린더 개수에 따라 점 모양 지정 gpshape + geom_point(aes(shape = factor(cyl)), size = 4) ## pch를 인수로 사용해도 동일한 그래프 출력 # gpshape + # geom_point(aes(pch = factor(cyl)), # size = 4) # linetype 지정 ## economics_long 데이터셋 gplty &lt;- ggplot(data = economics_long, aes(x = date, y = value01)) gplty + geom_line(aes(group = variable, color = variable), size = 0.5, linetype = 6) # 실린더 개수에 따라 점 모양 지정 gplty + geom_line(aes(linetype = variable, color = variable), size = 0.5) 12.4.2 Geoms: 선 관련 geometric geom_line(): x축에 대응한 변수의 순서대로 관측값을 선으로 연결 geom_path(): 관측치가 데이터셋에 나타난 순서대로 선으로 연결 geom_abline(slope, intercept): 기울기(slope) 절편(intercept)에 대한 직선 \\(\\rightarrow\\) R 기본 그래픽 함수 abline(a=value, b=value)와 유사 geom_vline(xintercept): x축에 수직(y 축에 수평)인 직선 생성 geom_hline(yintecept): x축에 수평(y 축에 수직)인 직선 생성 # gap-minder 데이터 gpline &lt;- ggplot(data = gapm_filter, aes(y = gdp_cap)) # geom_line gpline + geom_line(aes(x = year, group = country), size = 0.5, alpha = 0.3, linetype = &quot;solid&quot;) -&gt; gpline gpline # geom_path highlight_country &lt;- c(&quot;South Korea&quot;, &quot;China&quot;, &quot;Japan&quot;, &quot;India&quot;, &quot;Taiwan&quot;, &quot;Singapore&quot;) # dplyr 패키지 체인과 ggplot 함수 연결 가능 gppath &lt;- gapm %&gt;% filter(year &gt;= 2000, country %in% highlight_country) %&gt;% ggplot(aes(x = gdp_cap, y = life_expectancy)) gppath + geom_path(aes(group = country)) # 선 굵기 및 색상 조정 gppath + geom_path(aes(color = country), size = 4, alpha = 0.5) -&gt; gppath # 선과 점 동시에 출력 gppath + geom_point(aes(shape = country), size = 2) # geom_abline, geom_hline, geom_vline ## abline m &lt;- lm(gdp_cap ~ year, data = gapm_filter) gpline + geom_abline(slope = coef(m)[2], intercept = coef(m)[1], size = 2, color = &quot;blue&quot;) -&gt; gplines gplines ## hline gplines + geom_hline(yintercept = mean(gapm_filter$gdp_cap, na.rm = TRUE), color = &quot;red&quot;, size = 1) -&gt; gplines gplines + ggtitle(&quot;Addling a horizontal line: mean of gdp_cap&quot;) ## vline gplines + geom_vline(xintercept = mean(gapm_filter$year, na.rm = TRUE), color = &quot;red&quot;, size = 1) + ggtitle(&quot;Adding a vertical line: mean of year&quot;) 12.4.3 Geoms: 점 geometrics geom_point(): ggplot 객체에 지정된 aesthetic (x-y에 대응하는 변수)에 대한 산점도를 생성 geom_jitter(): 각 점의 위치에 random noise를 추가해 overplotting 처리 \\(\\rightarrow\\) geom_point(position = \"jitter\")의 축약 버전 # geom_point ## 갭마인더 데이터: 2015년 기대수명 vs. 일인당 국민소득 산점도 gppoint &lt;- gapm %&gt;% mutate(continent = gsub(&quot;(.+\\\\s)&quot;, &quot;&quot;, region) %&gt;% # region 변수에서 공백 앞 문자 모두 제거 factor) %&gt;% filter(year == 2015) %&gt;% ggplot(aes(x = life_expectancy, y = gdp_cap)) gppoint + geom_point(size = 1) ## 점의 크기는 해당 국가 인구수(log10 변환) 에 비례 ## 각 대륙에 따라 색 구분 ## 투명도는 0.3 ## --&gt; Bubble plot gppoint + geom_point(aes(size = log(population, base=10), color = continent), alpha = 0.3) ## mpg 데이터 셋 ## cylinder 개수에 따른 시내 연비 gppoint2 &lt;- ggplot(data = mpg, aes(x = cyl, y = cty)) gppoint2 + geom_point(size = 3) # geom_jitter ## geom_point에서 position 인수 조정 gppoint2 + geom_point(position = &quot;jitter&quot;) + ggtitle(&quot;geom_point() with position = &#39;jitter&#39;&quot;) ## geom_jitter: jittering 크기는 0.3 ## class로 색 조정 gppoint2 + geom_jitter(aes(color = class), width = 0.3) + ggtitle(&quot;Jittering using geom_jitter()&quot;) 12.4.4 Geoms: 막대 geometrics geom_bar(): 범주형(factor 또는 문자열) 변수에 대응하는 케이스의 수를 막대의 높이로 나타냄. 기본적으로 stat_count()를 통해 각 집단 별 케이스 수가 그래프에 표현 함수 내 stat 인수 값을 “identity”로 설정 시 데이터 값 표현 가능 geom_col(): 데이터 값 자체를 높이로 표현 stat_identity()를 사용 # geom_bar(), geom_col() 주요 함수 인수 &lt;MAPPING&gt; = aes() 함수를 통해 수행 geom_bar()의 경우 aes() 내 x 위치에 대응하는 변수명만 입력해도 되지만, geom_col()의 경우, x, y 에 대응하는 변수 모두 입력 &lt;ARGUMENTS&gt; - width: 상자의 너비 조정 - positon: 문자열 또는 위치 조정 관련 함수 호출 가능 두 개 이상의 범주가 한 그래프에 표현된 경우, 디폴트 값은 &quot;stack&quot; (position_stack() 호출). 두 번째 범주에 해당하는 막대를 나란히 배열하고자 할 때, positon = &quot;dodge&quot;, &quot;dodge2&quot;, 또는 position_dodge(값) 사용 Examples # geom_bar()와 geom_col() 예시 p1 &lt;- ggplot(data = mpg, aes(x = class)) + geom_bar() + labs(title = &quot;p2: Barplot via geom_bar()&quot;, caption = &quot;The y-axis indicates the number of cases in each class&quot;) p2 &lt;- mpg %&gt;% group_by(class) %&gt;% summarise(mean = mean(cty)) %&gt;% ggplot(aes(x = class, y = mean)) + geom_col() + labs(title = &quot;p1: Barplot via geom_col()&quot;, caption = &quot;The y axis indicates the identical values of means&quot;) # geom_bar(stat = &quot;identity&quot;) 인 경우 geom_col()과 동일한 결과 도출 p1 &lt;- mpg %&gt;% group_by(class) %&gt;% summarise(mean = mean(cty)) %&gt;% ggplot(aes(x = class, y = mean)) + geom_bar(stat = &quot;identity&quot;) + labs(title = &quot;p1: Barplot via geom_bar(stat = &#39;identity&#39;)&quot;) # 막대도표 x-y 축 변환 # 이 경우 geom_bar()에 aesthetic 추가 p2 &lt;- ggplot(mpg) + geom_bar(aes(y = class)) + labs(title = &quot;p2: Map &#39;class&#39; variable to y&quot;) # diamonds dataset # 2개의 범주형 변수가 aesthetic에 mapping된 경우 # stacked barplot gbar_init &lt;- ggplot(data = diamonds) + aes(x = color, fill = cut) p1 &lt;- gbar_init + geom_bar() # fill에 해당하는 범주에 대해 나란히 배열 p2 &lt;- gbar_init + geom_bar(position = &quot;dodge2&quot;) 막대도표 값 순으로 정렬하기 # gapminder region 별 중위수 계산 gapm_median &lt;- gapm %&gt;% filter(year == 2015) %&gt;% group_by(region) %&gt;% summarise(median = median(gdp_cap, na.rm = TRUE)) p1 &lt;- ggplot(gapm_median) + aes(x = region, y = median) + geom_bar(stat = &quot;identity&quot;) + coord_flip() p2 &lt;- gapm_median %&gt;% mutate(region = reorder(region, median)) %&gt;% ggplot(aes(x = region, y = median)) + geom_bar(stat = &quot;identity&quot;) + coord_flip() # x-y 축 뒤집기 12.4.5 Geom: 수직 범위선 관련 geometrics 오차 막대, 신뢰구간 등을 도식화 할 때 많이 활용되며 데이터의 변수를 mapping 시 위치 관련 aesthetic에 x, y 외에 ymin(또는 xmin), ymax(또는 xmax)가 사용 geom_errorbar(): 주어진 범위(구간) 내 오차막대(errorbar) 생성 \\(\\rightarrow\\) 오차막대는 선 끝에 범위 선과 수직인 선이 생성 geom_linerange(): 주어진 범위(구간) 내 선 생성 # geom_errorbar(), geom_linerange() 주요 함수 인수 &lt;MAPPING&gt; = 기본 x, y에 대한 aesthetic 기본 mapping 이외 범위를 지정하는 ymin (ymax), xmin (ymax) 지정 필수 &lt;ARGUMENTS&gt; - width: geom_errorbar()에서 범위선에 수직인 선의 너비 짖어 - positon: 문자열 또는 위치 조정 관련 함수 호출 가능 positon = &quot;dodge&quot;, &quot;dodge2&quot;, 또는 position_dodge(값) 사용 # geom_errorbar() 예시 # diamonds cut, color에 따른 carat의 평균, 표준편차, 95% 신뢰구간 계산 # dplyr + pipe operator를 이용한 통계량 계산 carat_summ &lt;- diamonds %&gt;% group_by(cut, color) %&gt;% summarise(N = n(), mean = mean(carat), sd = sd(carat)) %&gt;% # 95 % 신뢰구간(모분산 모른다고 가정) mutate(lcl = mean - qt(0.975, N-1)*sd/sqrt(N), ucl = mean + qt(0.975, N-1)*sd/sqrt(N)) `summarise()` has grouped output by &#39;cut&#39;. You can override using the `.groups` argument. gerror_init &lt;- ggplot(data = carat_summ) + aes(x = cut, y = mean, color = color) # 오차 막대 도표 (디폴트) 오차 범위는 95 % 신뢰구간 gerror_init + geom_errorbar(aes(ymin = lcl, ymax = ucl)) # 오차 막대 도표2 # 선과 점 추가 # 집단 별 위치 및 막대 조정 gerror_init + geom_errorbar(aes(ymin = lcl, ymax = ucl), width = 0.1, # 선 너비 지정 position = position_dodge(0.8)) + geom_line(aes(group = color)) + geom_point(size = 3) 평균-95 % 신뢰구간 오차 막대 도표 예시 # 점과 선에 대해서도 동일하게 position 조정 필요 # position은 수동으로 조정(&quot;dodge&quot; 등 대신 position_dodge(value) 입력) gerror_init + geom_errorbar(aes(ymin = lcl, ymax = ucl), width = 0.1, # 선 너비 지정 position = position_dodge(0.8)) + geom_line(aes(group = color), position = position_dodge(0.8)) + geom_point(size = 3, position = position_dodge(0.8)) 막대도표 위에 오차 막대 표시 예제 # warpbreaks 데이터 # R 기본 그래픽스 barplot() 예제와 동일한 그래프 생성 break_summ &lt;- warpbreaks %&gt;% group_by(wool, tension) %&gt;% summarise(N = n(), mean = mean(breaks), sem = sd(breaks)/sqrt(N)) `summarise()` has grouped output by &#39;wool&#39;. You can override using the `.groups` argument. ggplot(data = break_summ) + aes(x = tension, y = mean, fill = wool) + # aesthetic 지정 geom_col(position = position_dodge(0.9), color = &quot;black&quot;) + # 테두리 선 색상 지정(검정) geom_errorbar(aes(ymin = mean - sem, ymax = mean + sem), position = position_dodge(0.9), width = 0.1) 95 % 신뢰구간 시뮬레이션 예제 # geom_linerange 예시 # 정규 난수 생성 # 표본 크기 n = 30, 반복 N = 200 # 평균 mu = 20, 표준편차 sx = 10 # 각 표본에 대한 95 % 신뢰구간 계산(모분산은 안다고 가정) set.seed(20200609) n &lt;- 30; N = 200 mu &lt;- 20; sx &lt;- 10 X &lt;- mapply(rnorm, rep(n, N), rep(mu, N), rep(sx, N)) mi &lt;- apply(X, 2, mean) # 각 반복에 대한 표본 평균 계산 si &lt;- apply(X, 2, sd) # 각 반복에 대한 표준편차 계산 alpha &lt;- 0.05 # 유의수준 lower_ci &lt;- mi - qnorm(1-alpha/2)*si/sqrt(n) # 신뢰구간 하한 upper_ci &lt;- mi + qnorm(1-alpha/2)*si/sqrt(n) # 신뢰구간 상한 df_ci &lt;- tibble(lower_ci, upper_ci) %&gt;% mutate(nsim = seq_len(N), mu_contain = lower_ci &lt;= mu &amp; mu &lt;= upper_ci) ggci_init &lt;- ggplot(df_ci) + aes(x = nsim) # simulation 횟수 정보 ggci_init + geom_linerange( aes(ymin = lower_ci, # 하한 ymax =upper_ci, # 상한 color = mu_contain), # 색 지정 size = 1.2, alpha = 0.3 ) + geom_hline(yintercept = mu, color = &quot;tomato&quot;, size = 1) 12.4.6 Geoms: 텍스트 관련 geometrics x-y 좌표축에 텍스트를 추가하기 위한 함수. 여기서 미리 지정된 x-y aesthetic에 대한 매핑은 사용할 수 있으며, 별도의 aesthetic 정의를 통해 새로운 좌표점에 텍스트 추가 가능 geom_text() geom_label(): 추가한 텍스트 뒤에 사각형을 동시에 출력 &lt;MAPPING&gt;: 필수 aesthetic은 x, y, label 임 다음 aesthetic 속성들은 geom_text() 또는 geom_label() 함수에서 인수(aes() 함수 외부)로 사용 가능 - angle: 텍스트 각도 조정 - family: 텍스트 폰트 페미리 - fontface: 텍스트 형태(&quot;bold&quot;, &quot;italic&quot;, &quot;bold.italic&quot;, &quot;plain&quot; 가능) - hjust: 텍스트 수평 위치 조정 - vjust: 텍스트 수직 위지 초정 &lt;ARGUMENTS&gt; (중요 인수) - parse: 논리값, 문자열을 parsing 하여 expression() 함수로 표현 - check_overlap: 이전에 생성된 텍스트 위에 새로운 텍스트가 중첩(overlapping)될 경우 인수값이 TRUE 이면 출력하지 않음. (geom_text()에서만 사용 가능) geom_text() 예시 gtext_init &lt;- mtcars %&gt;% rownames_to_column(var = &quot;model&quot;) %&gt;% ggplot(aes(x = wt, y = mpg)) gtext1 &lt;- gtext_init + geom_text(aes(label = model), size = 4) + # x-y aesthetic 사용 labs(title = &quot;geom_text() with size = 4&quot;) # 중첩되는 텍스트 제거 gtext2 &lt;- gtext_init + geom_text(aes(label = model), size = 4, check_overlap = TRUE) + labs(title = &quot;Remove overlapped text with check_overlap = TRUE&quot;) # geom_label() # check_overlap 옵션 사용할 수 없음 gtext3 &lt;- gtext_init + geom_label(aes(label = model), size = 4) + labs(title = &quot;geom_label()&quot;) gtext4 &lt;- gtext_init + geom_point(size = 1) + geom_text(aes(label = model, color = factor(cyl)), size = 4, fontface = &quot;italic&quot;, check_overlap = TRUE) + labs(title = &quot;Both points and texts: using italic fontface&quot;) ggplot 텍스트 위치 조정 R 기본 그래픽 함수 text() 함수의 adj 인수와 유사 vjust: (-) 방향 \\(\\uparrow\\); middle = 0.5; (+) 방향 \\(\\downarrow\\) hjust: (-) 방향 \\(\\rightarrow\\); middle = 0.5; (+) 방향 \\(\\leftarrow\\) vjust, hjust 모두 (0, 1) 밖의 값을 갖을 수 있으나, 이러한 위치 조정은 그래프의 크기에 상대적이기 때문에 해당 값들을 이용해 텍스트 위치를 과도하게 조정하는 것이 바람직한 방법은 아님. # hjust, vjust 별 문자 위치 표시 adj_val &lt;- c(-0.5, 0, 0.5, 1) df_adjust &lt;- expand.grid(hjust = adj_val, vjust = adj_val) df_adjust &lt;- df_adjust %&gt;% mutate(just_label = sprintf(&quot;(h=%.1f, v=%.1f)&quot;, hjust, vjust)) ggplot(data = df_adjust) + aes(x = hjust, y = vjust) + geom_point(color = &quot;gray&quot;, alpha = 0.8, size = 5) + geom_text(aes(label = just_label, hjust = hjust, vjust = vjust)) Figure 12.26: hjust와 vjust 값에 따른 텍스트 위치. https://ggplot2.tidyverse.org/articles/ggplot2-specs.html 인용 geom_text() 수식(math) 표기 R 기본 그래픽 함수에서 적용한 expression(), bquote() 함수를 이용해 수식 표현 가능. bquote()를 이용 시 생성한 표현을 다시 parsing (문자열을 expression 구문으로 해석) 하기 위해 deparse() 함수를 통해 문자열로 변환해줘야 함. 이 때 텍스트가 label의 값으로 입력이 되기 때문에 텍스트를 expression() 형태로 바꿔주기 위해 parse = TRUE 로 설정해야 수식 표현 가능 set.seed(12345) x &lt;- rnorm(100, 5, 2) df_dummy &lt;- data.frame(x = 0, y = 0) # 정규분포 pdf expr1 &lt;- expression(paste(f, &quot;(&quot;, x, &quot;;&quot;, list(mu, sigma), &quot;)&quot; == frac(1, sigma*sqrt(2*pi))*~~exp * bgroup(&#39;(&#39;, -frac((x-mu)^2, 2*sigma^2), &#39;)&#39;))) # 회귀계수 추정 공식 expr2 &lt;- expression(hat(bold(beta)) == bgroup(&quot;(&quot;, bold(X)^T*bold(X), &quot;)&quot;)^-1*bold(X)^T*bold(y)) # 그리스 문자 expr3 &lt;- expression(alpha[1]~~beta[2]~~gamma[3]~~delta[4] ~~epsilon[5]~~theta[6]~~pi[7]) # expr4 &lt;- bquote(paste(&quot;Estimated&quot; ~~ hat(mu) == .(sprintf(&quot;%.2f&quot;, mean(x))))) ggplot(data = df_dummy) + aes(x = x, y = y) + geom_point(size = 0) + geom_text(x = 0, y = 0, label = expr1, size = 10) + geom_text(x = 0, y = -0.025, label = expr2, size = 10) + geom_text(x = 0, y = -0.04, label = &quot;y[i] == beta[0] + beta[1]~x + epsilon[i]&quot;, parse = TRUE, # 수식 내용이 문자열로 label 값으로 사용 size = 10) + geom_text(x = 0, y = 0.025, label = expr3, size = 10) + geom_text(x = 0, y = 0.04, label = deparse(expr4), parse = TRUE, size = 10) ## ggplot 객체 저장 # ggsave(&quot;figures/ggplot-text-math.png&quot;, plot = last_plot()) 12.4.7 Geoms: 면적 관련 geometrics geom_ribbon(): 각 x 값에 대해 ymin과 ymax로 정의된 간격을 면적으로 표시 geom_area(): geom_ribbon()의 special csae 로 ymin = 0이고 ymax 대신 y 를 사용하여 면적 영역 표시 &lt;MAPPING&gt; = 기본 x, y에 대한 aesthetic 기본 mapping 이외 범위를 지정하는 ymin (ymax), xmin (xmax) 지정 필수 Examples geom_ribbon() 예시 # gapminder 데이터셋 gapm %&gt;% filter(iso == &quot;KOR&quot;) %&gt;% select(year, gdp_cap) %&gt;% ggplot(aes(x = year, y = gdp_cap)) + geom_ribbon(aes(ymin = gdp_cap - 5000, ymax = gdp_cap + 5000), fill = &quot;gray&quot;, alpha = 0.5) + geom_line(size = 1.5, color = &quot;black&quot;) 표준정규분포 밀도함수 곡선 아래 면적 표시(그림 12.12 참고) \\(Z ~ \\stackrel{i.i.d}{\\sim} N(0, 1)\\) 라고 할 때 \\(P(-1.2 &lt; Z &lt; 0.7)\\) 에 해당하는 영역과 확률값 표시 x &lt;- seq(-3, 3, by = 0.01) z &lt;- dnorm(x) df_norm &lt;- data.frame(x, z) idx &lt;- -1.2 &lt; x &amp; x &lt; 0.7 # 해당 구간 index 설정 df_area &lt;- df_norm %&gt;% filter(idx) expr &lt;- bquote(P({-1.2 &lt; Z} &lt; 0.7 ) == .(sprintf(&quot;%.3f&quot;, pnorm(0.7) - pnorm(-1.2)))) # 각 geom 별로 다른 데이터 적용 ggplot() + geom_line(data = df_norm, aes(x = x, y = z), size = 1) + geom_area(data = df_area, aes(x = x, y = z), fill = &quot;red&quot;, alpha = 0.2) + geom_text(aes(x = -1, y = 0.2, # expr 이 3 행으로 구성되었기 때문에 paste로 collapse label = paste(deparse(expr), collapse = &quot;&quot;)), parse = TRUE, size = 5, hjust = 0) 12.4.8 Geoms: 통계 그래프 관련 geometrics 다음 소개하는 그래프 함수는 기본적으로 stat_* 함수로 도출한 통계량을 바탕으로 그래프 생성 -geom_histogram(): stat_bin() (연속형 변수)를 사용한 히스토그램 생성 &lt;MAPPING&gt;: 하나의 변수를 x 또는 y에 대응 &lt;ARGUMENTS&gt; - binwidth: 히스토그램의 너비 조정. 결국 범주의 개수 조정 - bins: 히스토그램 생성 시 범주화 개수(기본값 = 30) geom_histogram 예시 히스토그램 인수 조정 # diamonds 데이터셋 p0 &lt;- ggplot(data = diamonds, aes(x = carat)) p1 &lt;- p0 + geom_histogram() + labs(title = &quot;bins, binwidth = default&quot;) p2 &lt;- p0 + geom_histogram(binwidth = 0.01) + labs(title = &quot;binwidth = 0.05&quot;) p3 &lt;- p0 + geom_histogram(bins = 150) + labs(title = &quot;bins = 150&quot;) p4 &lt;- ggplot(data = diamonds, aes(y = carat)) + geom_histogram() + # y 축 기준으로 히스토그램 생성 labs(title = &quot;Map to y (flipped)&quot;) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 다중 집단 히스토그램 # iris 데이터셋. 변수: Sepal Length p0 &lt;- ggplot(data = iris, aes(x = Petal.Length)) p1 &lt;- p0 + geom_histogram(aes(fill = Species), color = &quot;white&quot;, bins = 20, alpha = 0.2) + labs(title = &quot;p1: Histograms of petal length: frequency&quot;) p2 &lt;- p0 + geom_histogram(aes(fill = Species, y = ..density..), # y축을 밀도로 변경 color = &quot;white&quot;, # 막대 테두리선 지정 alpha = 0.2, bins = 20) + labs(title = &quot;p2: Histograms of petal length: density&quot;) -geom_density(): 막대 형태의 히스토그램을 부드러운(smoothed) 선(여기서 y 값은 밀도임)으로 나타낸 곡선으로, 커널 밀도 추정(kernel density estimate)을 통해 밀도 곡선 추정 &lt;MAPPING&gt;: 커널 밀도를 추정할 변수 (x 또는 y) &lt;ARGUMENTS&gt; - adjust: 커널 함수의 복잡도 조정(수치형 값 입력) # geom_histogram() 예시 이어서 # dataset: iris p1 &lt;- p0 + geom_density() + labs(title = &quot;p1: Basic geom_density()&quot;) p2 &lt;- p0 + geom_density(aes(color = Species)) + labs(title = &quot;p2: geom_density(aes(color = Species))&quot;) p3 &lt;- p0 + geom_density(aes(fill = Species, color = Species), alpha = 0.2) + labs(title = &quot;p3: geom_density(aes(color = Species))&quot;) p4 &lt;- p0 + geom_density(aes(fill = Species, color = Species), alpha = 0.2) + geom_histogram(aes(y = ..density.., # 밀도로 변환 필요 fill = Species), color = &quot;white&quot;, alpha = 0.3, bins = 20) + labs(title = &quot;p4: Overlaying multiple histograms with multiple densities&quot;) -geom_boxplot(): R 기본 그래픽스 함수 boxplot()과 유사. stat_boxplot() 함수의 결과값을 기반으로 그래프 도출 &lt;MAPPING&gt; - x: 이산형(discrete) 변수를 x에 대한 aesthetic으로 mapping - y: 상자그림으로 표현할 변수 &lt;ARGUMENTS&gt; - outlier.*: outlier의 aesthetic 조정 (*=color, fill, shape, size, ...) - width: 상자의 너비 조정 - varwidth: 논리값. 상자의 크기를 sqrt(n)에 비례하여 조정 # diamond 데이터 셋 ## cut 범주에 따른 carat의 분포 p0 &lt;- ggplot(data = diamonds, aes(y = carat)) p1 &lt;- p0 + geom_boxplot() # 디폴트 상자 그림 p2 &lt;- p0 + geom_boxplot(aes(x = cut, fill = cut)) p3 &lt;- p0 + geom_boxplot(aes(x = cut, fill = cut), width = 0.5) # 상자 크기 조정 p4 &lt;- p0 + geom_boxplot(aes(x = cut, # aesthetic에 x 이외의 factor가 추가된 경우 자동으로 dodge fill = color), # outlier 표시 모양 및 색상 지정 outlier.shape = 4, outlier.color = &quot;red&quot;) geom_boxplot() + geom_jitter() 콜라보레이션 # mpg 데이터셋 p0 &lt;- ggplot(data = mpg) + aes(x = class, y = cty) p1 &lt;- p0 + geom_boxplot(aes(fill = class), outlier.shape = NA, alpha = 0.1) + # 이상치 표시하지 않음 geom_jitter(aes(color = class), alpha = 0.5, width = 0.2) + labs(title = &quot;p1: boxplot with jittered data points per each class (unordered)&quot;) p2 &lt;- mpg %&gt;% # stats::reorder() 함수를 이용해 특정 통계량 기준으로 데이터 정렬 가능 mutate(class = reorder(class, cty, median)) %&gt;% ggplot(aes(x = class, y = cty)) + geom_boxplot(aes(fill = class), outlier.shape = NA, alpha = 0.1) + geom_jitter(aes(color = class), alpha = 0.5, width = 0.2) + labs(title = &quot;p2: ordered by median of cty for each car class&quot;) -geom_smooth(): x-y 관계에 대한 패턴을 도식화하기 위한 그래프로 아래와 같은 방법(method)을 이용해 추세선과 추정 직선의 오차 그래프 출력 선형 회귀 곡선(linear model, lm) 일반화 선형 모형(generalized linear model, glm) 국소 다항 회귀 곡선(locally estimated scatterplot smoothing, loess) generalized addictive model (GAM, gam) p0 &lt;- ggplot(data = diamonds) + aes(x = carat, y = price) p1 &lt;- p0 + geom_point(alpha = 0.2) + geom_smooth() + labs(title = &quot;p1: geom_smooth() default&quot;) p2 &lt;- p0 + geom_point(aes(color = color), alpha = 0.2) + geom_smooth(aes(color = color)) + labs(title = &quot;p2: geom_smooth() for different color groups&quot;) p3 &lt;- p0 + geom_point(aes(color = color), alpha = 0.2) + geom_smooth(aes(color = color), se = FALSE) + # 표준오차 영역 삭제 labs(title = &quot;p3: geom_smooth() without the SE region&quot;) p4 &lt;- p0 + geom_point(aes(color = color), alpha = 0.2) + geom_smooth(aes(color = color), se = FALSE, # 선형 회귀 곡선을 추세선으로 사용 method = &quot;lm&quot;) + labs(title = &quot;p4: geom_smooth() using the linear regression curve&quot;) `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; `geom_smooth()` using formula &#39;y ~ x&#39; 12.4.9 Scales: x-y 축 관련 aesthetic 조정 scale_x_*, scale_y_*: x-y 축의 범위, plot 상 눈금선, 축 제목 등을 조정 xlim(), ylim(): scale_x_*, scale_y_*의 특별한 케이스로 x-y 축의 범위 조정 12.4.10 Scales: 색상 관련 aesthetic 조정 scale_color_*, scale_fill_*: aes()에 color 또는 fill이 정의된 경우, 기본 색상 변경 가능 색상 조정은 palette를 통해 가능하며, 색상 파레트를 사용할 경우 scale_*_brewer()를 통해 palette 설정 가능 RColorBrewer 패키지 설치 시 보다 다양한 palette 사용 가능 12.4.11 Scales: 크기, 선 종류, 점 모양 aesthetic 조정 scale_size_*: size에 대한 세부적인 값 지정 가능 scale_shape_*: shape가 aes() 함수에 사용된 경우, shape에 대한 세부 값(점 모양, 크기, 색 등 지정 가능) scale_linetype_*: linetype이 aes() 함수에 사용된 경우, linetype에 대한 세부 값(선 종류, 굵기 등 조정 가능) 12.4.11.1 scale_size_* 예시 gppoint + geom_point(aes(size = population, color = continent), alpha = 0.3) + scale_size_continuous(range = c(1, 20)) 12.4.12 Coordinate systems coord_flip(): x-y 축 뒤집기 p0 &lt;- ggplot(data = diamonds, aes(y = carat)) p1 &lt;- p0 + geom_boxplot(aes(x = color, fill = color), width = 0.5) p2 &lt;- p1 + coord_flip() ggarrange(p1, p2, ncol = 2) 12.4.13 Guides: x-y 축 및 그래프 제목 관련 labs(): x-y 축 제목, 부제목, 캡션 조정 xlab(), ylab(), ggtitle(): labs()의 조정 인수를 개별 함수로 구현 guide_legend(): guides() 함수 내부에서 사용되며, 범례 영역 조정하기 위한 함수 이미 정의한 aesthetic에 대한 범례 영역의 세부 속성을 변경하고 싶은 경우 overrride.aes 인수 조정(입력값은 리스트) # gap-minder 데이터 gapm &lt;- read_csv(&quot;dataset/gapminder/gapminder_filter.csv&quot;) Rows: 13159 Columns: 7 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (3): iso, country, region dbl (4): year, population, life_expectancy, gdp_cap ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. gapm %&gt;% mutate(continent = gsub(&quot;(.+\\\\s)&quot;, &quot;&quot;, region) %&gt;% factor) %&gt;% filter(year == 2015) %&gt;% ggplot(aes(x = life_expectancy, y = gdp_cap)) + geom_point(aes(size = population, color = continent), alpha = 0.3) -&gt; p1 p2 &lt;- p1 + guides(size = FALSE, # size 관련 guide(범례는 출력하지 않음) color = guide_legend( title = &quot;Contient&quot;, # 범례 제목 변경 title.theme = element_text(face = &quot;bold&quot;), # 범례 제목 폰트 굵은체 override.aes = list(size = 5) # 범례 표시 점의 크기를 5로 )) + theme(legend.position = &quot;top&quot;) # 범례 위치를 맨 위로 조정 Warning: `guides(&lt;scale&gt; = FALSE)` is deprecated. Please use `guides(&lt;scale&gt; = &quot;none&quot;)` instead. 12.4.14 Facets: 국소 시각화 기법 facet_grid(): 행과 열에 대한 facet (면 또는 패널)을 정의한 변수에 의해 패널 행렬을 구성한 그래프로 두 개 이상의 범주형(이산) 변수가 있고 변수의 모든 조합이 데이터에 존제하는 경우 유용 facet_grid(&lt;ROW VARIABLE&gt; ~ &lt;COLUMN VARIABLE&gt;, ...) facet_wrap(): 1차원 패널을 2차원으로 변환. 일반적으로 facet_grid() 보다 화면 분할이 효율적이고, 서로 다른 단위로 측정된 변수를 패널 형태로 출력하고자 할 때 데이터를 long format으로 변환 후 적용 facet_wrap(~ &lt;DISCRETE VARIABLE&gt;, ncol = n, # 열 개수 nrow = m, # 행 개수 scale: x, y 스케일 &quot;fixed&quot;: x-y 스케일을 모든 패널에 동일하게 고정 &quot;free&quot;: x-y 모두 각 panel에 맞게 조정 &quot;free_x&quot;: y의 스케일은 모든 고정하고 x 만 각 페널에 맞게 조정 &quot;free_y&quot;: x의 스케일은 모든 고정하고 y 만 각 페널에 맞게 조정 ) # mpg 데이터 셋 p0 &lt;- ggplot(data = mpg) + aes(x = displ, y = hwy) # class 별 displ vs. hwy 산점도 p1 &lt;- p0 + geom_point(size = 2) + facet_grid(. ~ class) p1 cyl을 행, class를 열로 사용하여 cyl과 class의 수준 조합 별 산점도 출력 p2 &lt;- p0 + # 모든 facet에 동일한 데이터를 표현하려면 # geom 내부에서 데이터를 재정의 geom_point(data = mpg %&gt;% select(-class, -cyl), color = &quot;gray&quot;, alpha = 0.3) + geom_point(size = 2) + facet_grid(cyl ~ class) p2 facet_wrap()을 이용한 다변수 패널 도표 # economics_long 데이터셋 glimpse(economics_long) Rows: 2,870 Columns: 4 $ date &lt;date&gt; 1967-07-01, 1967-08-01, 1967-09-01, 1967-10-01, 1967-11-01, … $ variable &lt;chr&gt; &quot;pce&quot;, &quot;pce&quot;, &quot;pce&quot;, &quot;pce&quot;, &quot;pce&quot;, &quot;pce&quot;, &quot;pce&quot;, &quot;pce&quot;, &quot;pce&quot;… $ value &lt;dbl&gt; 506.7, 509.8, 515.6, 512.2, 517.4, 525.1, 530.9, 533.6, 544.3… $ value01 &lt;dbl&gt; 0.0000000000, 0.0002652497, 0.0007615234, 0.0004706043, 0.000… economics_long %&gt;% mutate(variable = factor(variable, levels = unique(variable), labels = c(&quot;Personal consumption expenditures&quot;, &quot;Total population&quot;, &quot;Personal saving rates&quot;, &quot;Median duration of unemployment&quot;, &quot;# of unemployed in thausand&quot;))) %&gt;% ggplot(aes(x = date, y = value)) + geom_line(size = 1) + facet_wrap(~ variable, nrow = 2, scale = &quot;free_y&quot;) + theme( strip.background = element_blank(), strip.text = element_text(hjust = 0, face = &quot;bold&quot;) ) 두 개 이상의 ggplot 객체를 한 화면에 출력하고자 할 때(R 기본 그래픽스에서 par(mfrow = c(n, m))와 유사하게), 별도의 패키지(예: gridExtra, ggpubr, cowplot 패키지 등)가 요구됨. 이 중 가장 사용하기 용이한 패키지와 함수는 ggubr::ggarrange() 임. 12.4.15 Themes theme(): ggplot의 결과에서 비데이터(non-data)적 요소(예: 제목, 레이블, 글꼴, 배경, 눈금선, 범례)를 조정하기 위한 함수로 출력 그래프의 전반적인 형태를 정의함. theme()을 이용한 비데이터적 요소는 다음의 4 가지 속성을 가짐 line: 모든 선 구성 요소(x-y 축선, 눈금선, 보조선 등) \\(\\rightarrow\\) element_line() rect: 모든 사각형 구성 요소(facet strips, 범례, 배경 등) \\(\\rightarrow\\) element_rect() text: 모든 텍스트 구성 요소(눈금선 레이블, 범례 표시 텍스트, …) \\(\\rightarrow\\) element_text() title: 모든 제목 요소(plot, 축, 범례 등) \\(\\rightarrow\\) element_text() element_blank(): 특정 요소를 없앨 때 사용 &lt;element_text()&gt; axis.title: ggplot에 표현된 모든 축의 제목 조정(크기, 폰트 등) axis.title.x, axis.title.y: x, y 축 각각의 제목 조정 axis.text: 모든 축의 눈금 레이블 크기 폰트 등 조정 axis.text.x, axis.text.y: x, y 축 각각의 눈금선 레이블 조정 legend.text: 범례표시의 텍스트 조정 legend.title: 범례 제목 조정 plot.title, plot.subtitle, plot.caption: ggplot 제목, 부제목, 캡션 텍스트 조정 strip.text: facet 레이블 텍스트 조정 strip.text.x, strip.text.y &lt;element_line()&gt;: 선과 관련된 모든 요소 조정 axis.ticks: 모든 눈금선 조정 axis.ticks.x, axis.ticks.y: x, y 축 각각의 눈금선 조정 axis.line: 모든 axis 선 설정 조정 axis.line.x, axis.line.y: panel.grid: plot 내 주(major) 또는 보조(minor) 격자선 조정 panel.grid.minor, panel.grid.minor.x, panel.grid.minor.y panel.grid.major, panel.grid.major.x, panel.grid.major.y &lt;element_rect()&gt;: plot 배경 및 범례 배경 및 표시 상자 설정 기타 legend.position: 범례 위치 조정 “none”, “left”, “right”, “bottom”, “top” 과 같은 문자열 값 또는 좌표의 상대적 위치(0에서 1사이 값)을 나타내는 2차원 벡터 값을 가짐 legend.direction: 범례 표시 방향 설정 “horizontal” (수평) 또는 “vertical” (수직) theme() 함수를 이용한 그래프 조정 옵션은 help(theme) 또는 ggplot2 공식 메뉴얼 또는 Statistical tools for high-throughput data analysis를 참고 가능한 완성 theme ggplot2 패키지 제공 theme theme_grey() theme_bw() theme_light() theme_minimal() theme_classic() p0 &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point() p1 &lt;- p0 + theme_grey() + labs(title = &quot;Basic theme: theme_grey() (default)&quot;) p2 &lt;- p0 + theme_bw() + labs(title = &quot;Basic theme: theme_bw()&quot;) p3 &lt;- p0 + theme_light() + labs(title = &quot;Basic theme: theme_light()&quot;) p4 &lt;- p0 + theme_minimal() + labs(title = &quot;Basic theme: theme_minimal()&quot;) p5 &lt;- p0 + theme_classic() + labs(title = &quot;Basic theme: theme_classic()&quot;) p6 &lt;- p0 + theme_linedraw() + labs(title = &quot;Basic theme: theme_linedraw()&quot;) **ggplot 관련 알아두면 유용한 팁 ggplot2는 ggplot2에 포함된 모든 함수에 대한 메뉴얼을 제공 r-statistics.co에서 ggplot 예시 확인 가능 ggplot2 패키지에서 제공하는 기본 theme 외에 ggtheme, ggpubr 과 같은 패키지를 통해 보다 다양한 theme을 적용할 수 있음 12.4.16 확장 예제 Our World in Data에서 각 국가별 코로나 19 바이러스 통계 데이터 제공 감염자 및 사망자 수 통계는 하루 단위로 업데이트가 되고 있고, 각 국가별 검사 수는 일주일 단위로 업데이트 데이터 전처리 데이터 불러오기: covid19-cases-20200601.txt, country_pubhealth.csv, country_info.txt covid19 &lt;- read_delim(&quot;dataset/covid-19-dataset/covid19-cases-20200601.txt&quot;, delim = &quot;\\t&quot;, show_col_types = FALSE) country &lt;- readxl::read_excel(&quot;dataset/covid-19-dataset/country_info.xlsx&quot;) country_pubhealth &lt;- read_csv(&quot;dataset/covid-19-dataset/country_pubhealth.csv&quot; , show_col_types = FALSE) # glimpse(covid19); glimpse(country); # glimpse(country_pubhealth) 데이터 코드북 데이터 전처리 Filtering covid19 에서 iso_code가 “OWID_WRL”인 케이스 제외 2020년 3월 1일 부터 2020년 5월 31 일 까지 데이터만 추출 covid19_full &lt;- covid19 %&gt;% filter(iso_code != &quot;OWID_WRL&quot;, date &gt;= as.Date(&quot;2020-03-01&quot;) &amp; date &lt;= as.Date(&quot;2020-05-31&quot;)) # glimpse(covid19_full) Join: covid19를 기준으로 나머지 두 데이터셋(country, country_pubhealth) 결합 covid19_full &lt;- covid19_full %&gt;% left_join(country, by = &quot;iso_code&quot;) %&gt;% #country의 siso_code와 공통 변수 left_join(country_pubhealth, by = c(&quot;location&quot;)) # 공통 변수: location # glimpse(covid19_full) 대륙(continent) 변수 생성(region 변수를 활용해서) covid19_full &lt;- covid19_full %&gt;% # 하나 이상의 어떤 문자와 공백을 포함한 문자열을 그룹화 mutate(continent = gsub(&quot;(.+\\\\s)&quot;, &quot;&quot;, region) %&gt;% factor) # glimpse(covid19_full) 케이스, 사망자 수 관련 변수를 이용해 100만명 당 확진자 수 및 사망자 수 계산(변수이름은 기존 변수명 마지막에 “_per_million”을 추가) covid19_full &lt;- covid19_full %&gt;% mutate_at(vars(matches(&quot;cases|deaths&quot;)), list(per_million =~ ./population * 10^6)) # glimpse(covid19_full) 2020년 5월 31일 기준 총 확진자 수가 2000 명 이상인 국가만 추출 # 각 국가별로 grouping을 한 후 total_case의 최댓값이 1000 명을 초과한 경우만 추출 covid19_full &lt;- covid19_full %&gt;% group_by(location) %&gt;% filter(max(total_cases) &gt; 1000) # glimpse(covid19_full) 각 국가별 total_test 결측값 대체 최초 시점의 total_test가 결측인 경우 0으로 대체 기록 중 중간에 결측이 발생한 경우 이전 시점 값으로 대체 # 위에서 location 에 대한 grouping이 유지가 되고 있음 # 각 국가별 첫 번째 행이고 그 첫 번째 행이 결측이면 0 값을 대체하고 # 아니면 원래 관측값을 반환 covid19_full &lt;- covid19_full %&gt;% mutate(total_tests = ifelse(row_number() == 1 &amp; # 첫 번째 값을 추출하기 위해 dplyr 제공 first() 함수 사용 is.na(first(total_tests)), 0, total_tests)) %&gt;% # help(fill) 참고 fill(total_tests, .direction = &quot;down&quot;) %&gt;% ungroup # glimpse(covid19_full) “_tests”가 포함된 변수들에 대해 인구 천 명당 검사 수 계산(변수이름은 기존 변수명 마지막에 “_per_thousand”을 추가) # 4 번과 유사 covid19_full &lt;- covid19_full %&gt;% mutate_at(vars(contains(&quot;_tests&quot;)), list(per_thousand = ~ ./population * 10^3)) # glimpse(covid19_full) iso_code, date, location, continent, population, 그리고 “case”, “deaths”, “tests”가 포함된 변수 선택 covid19_full &lt;- covid19_full %&gt;% select(iso_code:date, location, continent, population, matches(&quot;cases|deaths|tests&quot;)) glimpse(covid19_full) Rows: 9,733 Columns: 19 $ iso_code &lt;chr&gt; &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AFG&quot;, &quot;AF… $ date &lt;date&gt; 2020-03-01, 2020-03-02, 2020-03-08, 2… $ location &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghani… $ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, As… $ population &lt;dbl&gt; 38928341, 38928341, 38928341, 38928341… $ total_cases &lt;dbl&gt; 1, 1, 4, 7, 10, 16, 21, 22, 22, 22, 24… $ new_cases &lt;dbl&gt; 0, 0, 3, 3, 3, 6, 5, 1, 0, 0, 2, 0, 10… $ total_deaths &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… $ new_deaths &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… $ total_tests &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… $ new_tests &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… $ new_tests_smoothed &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… $ total_cases_per_million &lt;dbl&gt; 0.02568823, 0.02568823, 0.10275290, 0.… $ new_cases_per_million &lt;dbl&gt; 0.00000000, 0.00000000, 0.07706468, 0.… $ total_deaths_per_million &lt;dbl&gt; 0.00000000, 0.00000000, 0.00000000, 0.… $ new_deaths_per_million &lt;dbl&gt; 0.00000000, 0.00000000, 0.00000000, 0.… $ total_tests_per_thousand &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… $ new_tests_per_thousand &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… $ new_tests_smoothed_per_thousand &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… 시각화 대륙별 일별 일일 확진자 수(new_case 기준)에 대한 시각화 # Sys.setlocale(&quot;LC_TIME&quot;, &quot;english&quot;) # date 영문 표시를 위해 필요 Sys.setlocale(&quot;LC_TIME&quot;, &quot;en_US.UTF-8&quot;) [1] &quot;en_US.UTF-8&quot; covid19_full %&gt;% ungroup %&gt;% group_by(continent, date) %&gt;% summarise(confirm_case_date = sum(new_cases)) %&gt;% ungroup %&gt;% ggplot(aes(x = date)) + geom_bar(aes(y = confirm_case_date, fill = continent, alpha = continent), stat = &quot;identity&quot;, position = &quot;identity&quot;, # color = &quot;white&quot; alpha = 0.3) + scale_fill_brewer(palette = &quot;Set1&quot;) + scale_x_date(date_breaks = &quot;2 weeks&quot;, date_labels = &quot;%b-%d&quot;) + theme_minimal(base_size = 15) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;World COVID-19 cases over time&quot;) + theme( legend.position = &quot;bottom&quot;, panel.grid = element_line(size = 0.5, linetype = &quot;dashed&quot;), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank() ) `summarise()` has grouped output by &#39;continent&#39;. You can override using the `.groups` argument. 대한민국 일일 검사수와 검사수와 7일 이동평균선(new_tests_smoothed) 시각화 일일 검사수는 막대도표로 표시 7일 이동 평균선은 빨강색으로 표시 covid19_full %&gt;% filter(iso_code == &quot;KOR&quot;) %&gt;% mutate(total_tests_n = max(total_tests)) %&gt;% ungroup %&gt;% ggplot(aes(x = date)) + geom_bar(aes(y = new_tests), stat = &quot;identity&quot;, fill = &quot;lightblue&quot;, color = &quot;white&quot;) + geom_line(aes(y = new_tests_smoothed, group = location), size = 1, color = &quot;red&quot;) + # x의 데이터 유형이 date # date label에 대한 자세한 설명은 help(strptime)으로 확인 scale_x_date(date_breaks = &quot;2 weeks&quot;, date_labels = &quot;%b-%d&quot;) + # y = Inf 는 텍스트의 위치를 맨 위에 위치시킬 때 유용 geom_text(aes(x = as.Date(&#39;2020-03-01&#39;), y = Inf, label = paste(&quot;Total number of COVID-19 tests performed:&quot;, # 출력 숫자 자리수 콤마 표시를 위해 사 format(unique(total_tests_n), big.mark = &quot;,&quot;))), vjust = 1, hjust = 0, color = &quot;black&quot;, size = 4) + theme_minimal(base_size = 15) + # minimal theme 사용 labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;Daily COVID-19 tests in South Korea&quot;, subtitle = &quot;Test unit: people tested&quot;) + theme( legend.position = &quot;none&quot;, # 범례 표시 제거 panel.grid = element_line(size = 0.5, linetype = &quot;dashed&quot;), panel.grid.minor.x = element_blank(), panel.grid.major.x = element_blank(), axis.ticks = element_blank() ) Warning: Removed 2 rows containing missing values (position_stack). 2020년 5월 31일 기준 상위 24개 국가의 국가 별 확진자 대비 COVID-19 검사 수(전체, 전체 검사수/전체 확진자 수)를 도식화 막대도표 사용 require(RColorBrewer) 필요한 패키지를 로딩중입니다: RColorBrewer getPalette = colorRampPalette(brewer.pal(9, &quot;Set1&quot;)) covid19_full %&gt;% filter(date == as.Date(&quot;2020-05-31&quot;)) %&gt;% mutate(total_tests_per_cases = total_tests/total_cases) %&gt;% filter(total_tests_per_cases != 0) %&gt;% select(iso_code:continent, total_tests_per_cases) %&gt;% arrange(desc(total_tests_per_cases)) %&gt;% slice(1:24) %&gt;% mutate(location = factor(location, levels = unique(location))) %&gt;% ggplot(aes(x = reorder(location, desc(location)), y = total_tests_per_cases)) + geom_bar(aes(fill = location), stat = &quot;identity&quot;) + geom_text(aes(label = sprintf(&quot;%.1f&quot;, total_tests_per_cases)), hjust = -0.5, size = 4) + scale_y_continuous(expand = c(0, 0), limits = c(0, 300), breaks = c(0, 100, 200)) + scale_fill_manual(values = getPalette(24)) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;Total COVID-19 tests per each confirmed case at May 31, 2020&quot;) + coord_flip() + theme_minimal(base_size = 15) + theme( legend.position = &quot;none&quot;, panel.grid = element_line(size = 0.5, linetype = &quot;dashed&quot;), panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank() ) References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
